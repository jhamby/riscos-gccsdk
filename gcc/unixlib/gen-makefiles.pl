#!/usr/bin/perl -w
# Create various Unixlib Makefiles

use Getopt::Long;

my $libunixdir = "";
my $dynamicdeps = 0;
my $findstubs = 0;
my $help = 0;

GetOptions(
 "stubs" => \$findstubs,
 "dynamicdeps" => \$dynamicdeps,
 "objdir=s" => \$libunixdir,
 "help" => \$help
) or die;

if ($help) {
  print <<EOF
Usage: gen-makefiles.pl [--stubs] [--dynamicdeps] [--objdir=dir]
--stubs:       Generate source/clib/unixlib/stubs.h
--dynamicdeps: Add dynamic dependencies to makefile (cross compiler only)
--objdir:      Directory to store object files (cross compiler only)
EOF
}

my @dirs;
my @srcs;
my @objs;
my @hdrs;
my @hdrdirs;

# Find all source files
sub find_files {
  my $dir = $_[0];
  my @entries = glob("$dir/*");
  my $entry;
  foreach $entry (@entries) {
    # Make sure names are in unix format
    $entry =~ s/\/([cosh])\/([^\/\.]*)$/\/$2.$1/;
    $entry =~ s/^source\///;
    # Ignore special directories
    next if $entry =~ m/(CVS)|(.svn)/;
    next if $entry =~ m/^(test)|(clib)|(module)|(conform)/;
    if (-d "source/$entry") {
      push @dirs, $entry if !($entry =~ m/^(.*\/)?[cosh]$/);
      find_files("source/$entry");
    } else {
      if ($entry =~ m/\.[cs]$/) {
        my $obj = $entry;
        $obj =~ s/[cs]$/o/;
        push @objs, $obj;
        push @srcs, $entry;
      }
    }
  }
}

find_files("source");

# Generate source/clib/unixlib/stubs.h
if ($findstubs) {
  open(STUBS, ">source/clib/unixlib/stubs.h") or die $^E;

  print STUBS "/* This file is automatically generated.\n"
             ."It defines a symbol `__stub_FUNCTION' for each function\n"
             ."in the C library which is a stub, meaning it will fail\n"
             ."every time called, usually setting errno to ENOSYS.  */\n\n";

  foreach $src (@srcs) {
    # Only check c files
    next if !($src =~ m/\.c$/);
    open(SRC, "<source/".$src) or die $^E;
    my $funcname = "none";
    my $return = 1;
    while (<SRC>) {
      # Get function name
      if (/^(\w*) \([^\)]*\)\W*$/) {
        $funcname = $1;
        $return = 0;
      }
      # Find the return statement
      if (/^\W*return.*ENOSYS/) {
        $return = -1 if ($return == 0);
      } elsif (/^\W*return/) {
        # Only a stub iff there is one return that always returns ENOSYS
        $return = 1;
      }
      # Find function end
      if (/^\}\W*$/) {
        print STUBS "#define __stub_$funcname\n" if ($return == -1);
      }
    }
    close SRC;
  }
  close STUBS;
}

# Find all header files in source/clib
sub find_headers {
  my $dir = $_[0];
  my @entries = glob("$dir/*");
  my $entry;
  foreach $entry (@entries) {
    $entry =~ s/^source\/clib\///;
    next if $entry =~ m/(CVS)|(.svn)/;
    if (-d "source/clib/$entry") {
      push @hdrdirs, $entry;
      find_headers("source/clib/$entry");
    } else {
      if ($entry =~ m/\.[hs]$/) {
        push @hdrs, $entry;
      }
    }
  }
}

find_headers("source/clib");


# Write unixlib/Makefile
open(MAKEFILEIN, "<Makefile.in") or die $^E;
open(MAKEFILE, ">Makefile") or die $^E;
while (<MAKEFILEIN>) {
  print MAKEFILE;
  if (/^DIRS = \\$/) {
    foreach $dir (@dirs) {
      print MAKEFILE "\$(upath)/$dir \\\n";
    }
  }
}
close MAKEFILEIN;
close MAKEFILE;


# Write unixlib/source/object-list
open(OBJLIST, ">source/object-list") or die $^E;
foreach $obj (@objs) {
  print OBJLIST "$libunixdir/$obj\n";
}
close OBJLIST;


# Convert foo/bar.h to foo.h.bar
sub riscosify {
  my $name = $_[0];
  $name =~ s/([^\.\/]*)\.([cosh])$/$2.$1/;
  $name =~ s/\//\./g;
  return $name;
}


# Convert foo/bar.h to foo/h/bar
sub semiriscosify {
  my $name = $_[0];
  $name =~ s/([^\.\/]*)\.([cosh])$/$2\/$1/;
  return $name;
}


# Write unixlib/source/Makefile
open(SRCMAKEFILEIN, "<source/Makefile.in") or die $^E;
open(SRCMAKEFILE, ">source/Makefile") or die $^E;
while (<SRCMAKEFILEIN>) {
  print SRCMAKEFILE;

  # List of all object files
  if (/^OBJS = \\$/) {
    foreach $obj (@objs) {
      print SRCMAKEFILE "\$(libunixobj)/$obj \\\n";
    }
  }

  # List of all header files
  if (/^HDRS = \\$/) {
    foreach $hdr (@hdrs) {
      print SRCMAKEFILE "\$(ux_gccpkg)/\$(gn_cross_include_dir)/unixlib/$hdr \\\n";
      print SRCMAKEFILE "\$(ro_gccpkg)/\$(gn_cross_include_dir)/unixlib/".semiriscosify($hdr)." \\\n";
      print SRCMAKEFILE "\$(ro_unixlibpkg)/source/clib/".semiriscosify($hdr)." \\\n";
    }
    print SRCMAKEFILE "\n";

    # Copy all header files to cross include dir and to RISC OS packages
    foreach $hdr (@hdrs) {
      print SRCMAKEFILE "\$(ux_gccpkg)/\$(gn_cross_include_dir)/unixlib/$hdr";
      print SRCMAKEFILE " \$(ro_gccpkg)/\$(gn_cross_include_dir)/unixlib/".semiriscosify($hdr);
      print SRCMAKEFILE " \$(ro_unixlibpkg)/source/clib/".semiriscosify($hdr).": clib/$hdr\n";
      print SRCMAKEFILE "	mkdir -p \`dirname \$@\`\n";
      print SRCMAKEFILE "	cp \$< \$@\n\n";
    }
  }

  # Copy all source files to RISC OS Unixlib package
  if (/^SRCS = \\$/) {
    foreach $src (@srcs) {
      print SRCMAKEFILE "\$(ro_unixlibpkg)/source/".semiriscosify($src)." \\\n";
    }
    print SRCMAKEFILE "\n";

    foreach $src (@srcs) {
      print SRCMAKEFILE "\$(ro_unixlibpkg)/source/".semiriscosify($src).": $src\n";
      print SRCMAKEFILE "	mkdir -p \`dirname \$@\`\n";
      print SRCMAKEFILE "	cp \$< \$@\n\n";
    }
  }

  if (/^\# Dependencies\:$/) {
    foreach $src (@srcs) {
      my $obj = $src;
      $obj =~ s/[cs]$/o/;
      if ($src =~ m/\.s$/) {
        print SRCMAKEFILE "\$(libunixobj)/$obj\: $src clib/unixlib/asm_dec.s\n";
      } else {
        if ($dynamicdeps) {
          my $dir = $src;
          $dir =~ s/[^\/]*$//;
          print SRCMAKEFILE "\$(libunixobj)/$dir".`(cd source; gcc -M -isystem clib -D__UNIXLIB_INTERNALS $src)`;
        } else {
          print SRCMAKEFILE "\$(libunixobj)/$obj\: $src\n";
        }
      }
    }
  }
}
close SRCMAKEFILEIN;
close SRCMAKEFILE;


# Write unixlib/MKDir
open(MKDIR, ">MKDir,feb") or die $^E;
print MKDIR "cdir <obey\$dir>.objs.o\n";
print MKDIR "cdir <obey\$dir>.objs.clib.o\n";
print MKDIR "cdir <obey\$dir>.objs.module\n";
print MKDIR "cdir <obey\$dir>.objs.module.o\n";
foreach $dir (@dirs) {
  print MKDIR "cdir <obey\$dir>.objs.$dir\n";
  print MKDIR "cdir <obey\$dir>.objs.$dir.o\n";
}
close MKDIR;


# Write unixlib/objs/Makefile
open(NORCROFT, ">objs/Makefile,fe1") or die $^E;
open(NORCROFTIN, "<objs/Makefile.in") or die $^E;
while (<NORCROFTIN>) {
  print NORCROFT;
  if (/^OBJS = \\$/) {
    foreach $obj (@objs) {
      print NORCROFT riscosify($obj)." \\\n";
    }
  }
  if (/^clean:$/) {
    foreach $dir (@dirs) {
      print NORCROFT "	-wipe ".riscosify($dir).".o.* fv~r~c\n";
    }
  }
  if (/^\to.* \\$/) {
    foreach $dir (@dirs) {
      print NORCROFT "	".riscosify($dir).".o.* \\\n";
    }
  }
  if (/^\# Static dependencies\:$/) {
    foreach $src (@srcs) {
      my $obj = $src;
      $obj =~ s/[cs]$/o/;
      if ($src =~ m/\.s$/) {
        print NORCROFT riscosify($obj).": ".riscosify($src)." <UnixHdr\$Dir>.unixlib.s.asm_dec\n";
      } else {
        print NORCROFT riscosify($obj).": ".riscosify($src)."\n";
      }
    }
  }
}
close NORCROFT;
close NORCROFTIN;

