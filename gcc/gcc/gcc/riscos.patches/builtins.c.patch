--- /home/nick/riscos/masters/gcc-3.4/gcc/builtins.c	2004-05-31 11:33:10.923669008 +0100
+++ builtins.c	2004-05-31 12:49:14.293931280 +0100
@@ -437,6 +437,41 @@ expand_builtin_return_addr (enum built_i
     count--;
 #endif
 
+  /* NAB++ */
+#if defined(HAVE_BUILTIN_RETURN_ADDR_FUNC) || defined(HAVE_BUILTIN_FRAME_ADDR_FUNC)
+  {
+    char *func = NULL;
+
+    /* If HAVE_BUILTIN_RETURN_ADDR_FUNC or HAVE_BUILTIN_FRAME_ADDR_FUNC
+       are defined, and evaluate to something, then call
+       __builtin_return_address as a function.  */
+#ifdef HAVE_BUILTIN_RETURN_ADDR_FUNC
+    if (fndecl_code == BUILT_IN_RETURN_ADDRESS
+        && HAVE_BUILTIN_RETURN_ADDR_FUNC)
+      func = "__builtin_return_address";
+#endif
+#ifdef HAVE_BUILTIN_FRAME_ADDR_FUNC
+    if (fndecl_code == BUILT_IN_FRAME_ADDRESS
+        && HAVE_BUILTIN_FRAME_ADDR_FUNC)
+      func = "__builtin_frame_address";
+#endif
+
+    if (func != NULL)
+      {
+        rtx function_call;
+
+        tem = gen_reg_rtx (Pmode);
+        function_call = gen_rtx (SYMBOL_REF, Pmode, func);
+        emit_library_call_value (function_call, tem, LCT_NORMAL,
+                                 Pmode, 1,
+                                 GEN_INT (count), SImode);
+        return tem;
+      }
+  }
+#endif
+  /* NAB-- */
+
+
   /* Scan back COUNT frames to the specified frame.  */
   for (i = 0; i < count; i++)
     {
@@ -1203,6 +1238,11 @@ expand_builtin_apply (rtx function, rtx 
   rtx call_fusage = 0;
   rtx struct_value = targetm.calls.struct_value_rtx (cfun ? TREE_TYPE (cfun->decl) : 0, 0);
 
+#ifdef TARGET_RISCOSAOF
+  /* This is really broken on RISC OS.  */
+  abort ();
+#endif
+
   arguments = convert_memory_address (Pmode, arguments);
 
   /* Create a block where the return registers can be saved.  */
