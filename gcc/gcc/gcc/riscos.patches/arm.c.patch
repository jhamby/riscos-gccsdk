--- ../../../gcc-3.4.6/gcc/config/arm/arm.c	2005-10-01 15:31:38.000000000 +0200
+++ config/arm/arm.c	2006-04-18 00:22:01.000000000 +0200
@@ -110,6 +110,7 @@
 static unsigned long arm_compute_func_type (void);
 static tree arm_handle_fndecl_attribute (tree *, tree, tree, int, bool *);
 static tree arm_handle_isr_attribute (tree *, tree, tree, int, bool *);
+static int arm_leaf_function_p (void);
 static void arm_output_function_epilogue (FILE *, HOST_WIDE_INT);
 static void arm_output_function_prologue (FILE *, HOST_WIDE_INT);
 static void thumb_output_function_prologue (FILE *, HOST_WIDE_INT);
@@ -149,6 +150,8 @@
 static void aof_dump_pic_table (FILE *);
 static void aof_file_start (void);
 static void aof_file_end (void);
+static void arm_aof_asm_named_section (const char *, unsigned int);
+static void arm_aof_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED);
 #endif
 
 
@@ -585,6 +588,32 @@
 
       insn_flags = sel->flags;
       
+#ifdef TARGET_TUNE_DEFAULT
+      /* If the user didn't specify tuning either, use the target's
+	 preferred flags.  */
+      if (tune_flags == 0)
+	{
+	  const struct processors * tunesel;
+	  const struct cpu_default * tunedef;
+
+	  for (tunedef = cpu_defaults; tunedef->name; tunedef++)
+	    if (tunedef->cpu == TARGET_TUNE_DEFAULT)
+	      break;
+
+	  if (tunedef->name == NULL)
+	    abort ();
+
+	  for (tunesel = all_cores; tunesel->name != NULL; tunesel++)
+	    if (streq (tunedef->name, tunesel->name))
+	      break;
+
+	  if (tunesel->name == NULL)
+	    abort ();
+
+	  tune_flags = tunesel->flags;
+	}
+#endif
+
       /* Now check to see if the user has specified some command line
 	 switch that require certain abilities from the cpu.  */
       sought = 0;
@@ -750,6 +779,15 @@
   if (TARGET_APCS_FLOAT)
     warning ("passing floating point arguments in fp regs not yet supported");
   
+  /* RISC OS RMA module support.  */
+  if (TARGET_MODULE)
+    {
+      flag_pic = 1;
+      /* We use r8 as the PIC register as r9 is reserved for the frame
+	 pointer and r10 is the stack-limit register.  */
+      arm_pic_register = 8;
+    }
+
   /* Initialize boolean versions of the flags, for use in the arm.md file.  */
   arm_fast_multiply = (insn_flags & FL_FAST_MULT) != 0;
   arm_arch4         = (insn_flags & FL_ARCH4) != 0;
@@ -1030,7 +1068,7 @@
     return 0;
 
   /* So do interrupt functions that use the frame pointer.  */
-  if (IS_INTERRUPT (func_type) && frame_pointer_needed)
+  if (IS_INTERRUPT (func_type) && arm_apcs_frame_needed ())
     return 0;
 
   stack_adjust = arm_get_frame_size () + current_function_outgoing_args_size;
@@ -1040,11 +1078,13 @@
       || cfun->machine->uses_anonymous_args
       /* Or if the function calls __builtin_eh_return () */
       || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER
-      /* Or if the function calls alloca */
-      || current_function_calls_alloca
+      /* NAB++ */
+      || (current_function_calls_alloca && ! TARGET_APCS_FRAME)
+      /* NAB-- */
       /* Or if there is a stack adjustment.  However, if the stack pointer
 	 is saved on the stack, we can use a pre-incrementing stack load.  */
-      || !(stack_adjust == 0 || (frame_pointer_needed && stack_adjust == 4)))
+      || !(stack_adjust == 0 ||
+	   (arm_apcs_frame_needed () && stack_adjust == 4)))
     return 0;
 
   saved_int_regs = arm_compute_save_reg_mask ();
@@ -2485,8 +2525,9 @@
     return false;
 
   /* Never tailcall something for which we have no decl, or if we
-     are in Thumb mode.  */
-  if (decl == NULL || TARGET_THUMB)
+     are in Thumb mode.  With explicit stack checking, tail calls
+     result in undefined behaviour.  */
+  if (decl == NULL || TARGET_THUMB || TARGET_APCS_STACK) /* NAB */
     return false;
 
   /* Get the calling method.  */
@@ -2559,6 +2600,26 @@
 #ifdef AOF_ASSEMBLER
       /* The AOF assembler can generate relocations for these directly, and
 	 understands that the PIC register has to be added into the offset.  */
+      if (TARGET_MODULE)
+	{
+	  tree ftree;
+	  /* printf ("legitimize_pic: sym=%s, local=%d, constp=%d\n",
+		  XSTR (orig, 0),
+		  SYMBOL_REF_LOCAL_P (orig),
+		  TREE_CONSTANT_POOL_ADDRESS_P (orig));*/
+
+	  insn = emit_insn (gen_pic_load_addr_arm (reg, orig));
+	  /* Don't do reallocation based on PIC register when our
+	     symbol is a function, i.e. do this only for global/local
+	     variables.  */
+	  /* FIXME: this requires more attention : in case ftree is NULL
+	     it is not clear what should be done with symbols generated
+	     by the compiler itself and not coming from src code.  */
+	  ftree = SYMBOL_REF_DECL(orig);
+	  if (ftree != NULL && TREE_CODE(ftree) != FUNCTION_DECL)
+	    insn = emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));
+	}
+      else
       insn = emit_insn (gen_pic_load_addr_based (reg, orig));
 #else
       if (subregs)
@@ -2656,8 +2717,34 @@
 void
 arm_finalize_pic (int prologue ATTRIBUTE_UNUSED)
 {
-#ifndef AOF_ASSEMBLER
-  rtx l1, pic_tmp, pic_tmp2, seq, pic_rtx;
+#ifdef AOF_ASSEMBLER
+  rtx seq;
+  rtx sb_reg, sl_reg, sb_ref;
+  int static_data_offset;
+
+  if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)
+    return;
+
+  if (!flag_pic)
+    abort ();
+
+  start_sequence ();
+
+  if (TARGET_LIBSTATICS)
+    static_data_offset = -540;
+  else
+    static_data_offset = -536;
+
+  sl_reg = gen_rtx_REG (Pmode, SL_REGNUM);
+  sb_ref = gen_rtx_MEM (Pmode,
+			gen_rtx_PLUS (Pmode,
+				      sl_reg, GEN_INT (static_data_offset)));
+  RTX_UNCHANGING_P (sb_ref) = 1;
+  emit_insn (gen_rtx_SET (SImode, pic_offset_table_rtx, sb_ref));
+
+#else /* ! AOF_ASSEMBLER */
+  rtx seq;
+  rtx l1, pic_tmp, pic_tmp2, pic_rtx;
   rtx global_offset_table;
 
   if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)
@@ -2667,6 +2754,7 @@
     abort ();
 
   start_sequence ();
+
   l1 = gen_label_rtx ();
 
   global_offset_table = gen_rtx_SYMBOL_REF (Pmode, "_GLOBAL_OFFSET_TABLE_");
@@ -2691,6 +2779,7 @@
       emit_insn (gen_pic_load_addr_thumb (pic_offset_table_rtx, pic_rtx));
       emit_insn (gen_pic_add_dot_plus_four (pic_offset_table_rtx, l1));
     }
+#endif /* AOF_ASSEMBLER */
 
   seq = get_insns ();
   end_sequence ();
@@ -2702,7 +2791,6 @@
   /* Need to emit this whether or not we obey regdecls,
      since setjmp/longjmp can cause life info to screw up.  */
   emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));
-#endif /* AOF_ASSEMBLER */
 }
 
 /* Return nonzero if X is valid as an ARM state addressing register.  */
@@ -6884,8 +6972,8 @@
   /* PIC symbol references need to be converted into offsets into the
      based area.  */
   /* XXX This shouldn't be done here.  */
-  if (flag_pic && GET_CODE (value) == SYMBOL_REF)
-    value = aof_pic_entry (value);
+  if (flag_pic && GET_CODE (value) == SYMBOL_REF && ! TARGET_MODULE)
+    value = aof_pic_entry (value, 0);
 #endif /* AOF_ASSEMBLER */
 
   fix->insn = insn;
@@ -6901,7 +6989,7 @@
   /* If an insn doesn't have a range defined for it, then it isn't
      expecting to be reworked by this code.  Better to abort now than
      to generate duff assembly code.  */
-  if (fix->forwards == 0 && fix->backwards == 0)
+  if (fix->forwards == 0 && fix->backwards == 0 /*&& !TARGET_MODULE*/)
     abort ();
 
   /* With iWMMXt enabled, the pool is aligned to an 8-byte boundary.
@@ -7296,6 +7384,7 @@
   return "";
 }
 
+
 /* Output a move from arm registers to an fpa registers.
    OPERANDS[0] is an fpa register.
    OPERANDS[1] is the first registers of an arm register pair.  */
@@ -8046,7 +8135,7 @@
   fputs ("\"\n", stream);
 }
 
-/* Compute the register sabe mask for registers 0 through 12
+/* Compute the register save mask for registers 0 through 12
    inclusive.  This code is used by both arm_compute_save_reg_mask
    and arm_compute_initial_elimination_offset.  */
 static unsigned long
@@ -8090,10 +8179,10 @@
 
       /* Handle the frame pointer as a special case.  */
       if (! TARGET_APCS_FRAME
-	  && ! frame_pointer_needed
-	  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]
-	  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])
-	save_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;
+	  && ! arm_apcs_frame_needed ()
+	  && regs_ever_live[ARM_HARD_FRAME_POINTER_REGNUM]
+	  && ! call_used_regs[ARM_HARD_FRAME_POINTER_REGNUM])
+	save_reg_mask |= 1 << ARM_HARD_FRAME_POINTER_REGNUM;
 
       /* If we aren't loading the PIC register,
 	 don't stack it even though it may be live.  */
@@ -8121,7 +8210,7 @@
 
   /* If we are creating a stack frame, then we must save the frame pointer,
      IP (which will hold the old stack pointer), LR and the PC.  */
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     save_reg_mask |=
       (1 << ARM_HARD_FRAME_POINTER_REGNUM)
       | (1 << IP_REGNUM)
@@ -8250,7 +8339,7 @@
 	     corrupted it, or 3) it was saved to align the stack on
 	     iWMMXt.  In case 1, restore IP into SP, otherwise just
 	     restore IP.  */
-	  if (frame_pointer_needed)
+	  if (arm_apcs_frame_needed ())
 	    {
 	      live_regs_mask &= ~ (1 << IP_REGNUM);
 	      live_regs_mask |=   (1 << SP_REGNUM);
@@ -8286,9 +8375,17 @@
 	  char *p;
 	  int first = 1;
 
+#ifdef TARGET_RISCOSAOF
+          if (arm_apcs_frame_needed ())
+            sprintf (instr, "ldm%sea\t%%|fp, {", conditional);
+          else if (live_regs_mask & (1 << SP_REGNUM))
+            sprintf (instr, "ldm%sfd\t%%|sp, {", conditional);
+          else
+            sprintf (instr, "ldm%sfd\t%%|sp!, {", conditional);
+#else
 	  /* Generate the load multiple instruction to restore the
 	     registers.  Note we can get here, even if
-	     frame_pointer_needed is true, but only if sp already
+	     arm_apcs_frame_needed () is true, but only if sp already
 	     points to the base of the saved core registers.  */
 	  if (live_regs_mask & (1 << SP_REGNUM))
 	    {
@@ -8306,11 +8403,13 @@
 		     instead.  */
 		  if (stack_adjust)
 		    live_regs_mask |= 1 << 3;
+
 		  sprintf (instr, "ldm%sfd\t%%|sp, {", conditional);
 		}
 	    }
 	  else
 	    sprintf (instr, "ldm%sfd\t%%|sp!, {", conditional);
+#endif
 
 	  p = instr + strlen (instr);
 
@@ -8495,19 +8594,28 @@
   if (IS_NESTED (func_type))
     asm_fprintf (f, "\t%@ Nested: function declared inside another function.\n");
     
-  asm_fprintf (f, "\t%@ args = %d, pretend = %d, frame = %wd\n",
+  asm_fprintf (f, "\t%@ args = %d, pretend = %d, frame = %wd, alloca = %d\n",
 	       current_function_args_size,
-	       current_function_pretend_args_size, frame_size);
+	       current_function_pretend_args_size, frame_size,
+	       current_function_calls_alloca);
 
   asm_fprintf (f, "\t%@ frame_needed = %d, uses_anonymous_args = %d\n",
-	       frame_pointer_needed,
+	       arm_apcs_frame_needed (),
 	       cfun->machine->uses_anonymous_args);
 
+  asm_fprintf (f, "\t%@ nonlocal_label = %d, nonlocal_goto = %d, leaf = %d\n",
+               current_function_has_nonlocal_label,
+               current_function_has_nonlocal_goto,
+               arm_leaf_function_p ());
+
+  asm_fprintf (f, "\t%@ outgoing_args = %d, pops_args = %d\n",
+	       cfun->outgoing_args_size, cfun->pops_args);
+
   if (cfun->machine->lr_save_eliminated)
     asm_fprintf (f, "\t%@ link register save eliminated.\n");
 
 #ifdef AOF_ASSEMBLER
-  if (flag_pic)
+  if (flag_pic && ! TARGET_MODULE)
     asm_fprintf (f, "\tmov\t%r, %r\n", IP_REGNUM, PIC_OFFSET_TABLE_REGNUM);
 #endif
 
@@ -8572,7 +8680,7 @@
     if (saved_regs_mask & (1 << reg))
       floats_offset += 4;
   
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     {
       int vfp_offset = 4;
 
@@ -8661,6 +8769,9 @@
       else
 	saved_regs_mask &= ~ (1 << PC_REGNUM);
 
+#ifdef TARGET_RISCOSAOF
+      print_multi_reg (f, "ldmea\t%r", FP_REGNUM, saved_regs_mask);
+#else
       /* We must use SP as the base register, because SP is one of the
          registers being restored.  If an interrupt or page fault
          happens in the ldm instruction, the SP might or might not
@@ -8676,6 +8787,7 @@
 	asm_fprintf (f, "\tsub\t%r, %r, #%d\n", SP_REGNUM, FP_REGNUM,
 		     4 * bit_count (saved_regs_mask));
       print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+#endif
 
       if (IS_INTERRUPT (func_type))
 	/* Interrupt handlers will have pushed the
@@ -8808,7 +8920,7 @@
       break;
 
     default:
-      if (frame_pointer_needed)
+      if (arm_apcs_frame_needed ())
 	/* If we used the frame pointer then the return address
 	   will have been loaded off the stack directly into the
 	   PC, so there is no need to issue a MOV instruction
@@ -8847,8 +8959,8 @@
 
       if (use_return_insn (FALSE, NULL)
 	  && return_used_this_function
-	  && (frame_size + current_function_outgoing_args_size) != 0
-	  && !frame_pointer_needed)
+/* NAB */ && abs (frame_size + current_function_outgoing_args_size) > 256
+	  && !arm_apcs_frame_needed ())
 	abort ();
 
       /* Reset the ARM-specific per-function variables.  */
@@ -9034,6 +9146,49 @@
   return par;
 }
 
+/* NAB++ */
+/* Given FROM and TO register numbers, say whether this elimination is
+   allowed.  Frame pointer elimination is automatically handled.  */
+int
+arm_can_eliminate (from, to)
+     int from, to;
+{
+#ifdef TARGET_RISCOSAOF
+  /* We can eliminate ARGP to STACKP if no alloca, no stack checks needed
+     and frame not needed.  */
+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM
+      && ! arm_apcs_frame_needed ())
+    return 1;
+
+  /* FRAMEP can be eliminated to STACKP.  */
+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+    return 1;
+
+  /* Can't do any other eliminations.  */
+  return 0;
+#else
+  /*  All eliminations are permissible.  Note that ARG_POINTER_REGNUM and
+      HARD_FRAME_POINTER_REGNUM are in fact the same thing.  If we need a frame
+      pointer, we must eliminate FRAME_POINTER_REGNUM into
+      HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM or
+      ARG_POINTER_REGNUM.  */
+  if (to == FRAME_POINTER_REGNUM && from == ARG_POINTER_REGNUM)
+    return 0;
+
+  if (to == STACK_POINTER_REGNUM && arm_apcs_frame_needed ())
+    return 0;
+
+  if (to == ARM_HARD_FRAME_POINTER_REGNUM && TARGET_THUMB)
+    return 0;
+
+  if (to == THUMB_HARD_FRAME_POINTER_REGNUM && TARGET_ARM)
+    return 0;
+
+  return 1;
+#endif
+}
+/* NAB-- */
+
 /* Compute the distance from register FROM to register TO.
    These can be the arg pointer (26), the soft frame pointer (25),
    the stack pointer (13) or the hard frame pointer (11).
@@ -9108,7 +9263,7 @@
 	 doing so will preserve the stack's alignment.  Hence we
 	 must count them here.  For each set bit we need 4 bytes
 	 of stack space.  */
-      if (frame_pointer_needed)
+      if (arm_apcs_frame_needed ())
 	reg_mask &= 0x07ff;
       call_saved_registers += 4 * bit_count (reg_mask);
 
@@ -9129,8 +9284,23 @@
   /* The stack frame contains 4 registers - the old frame pointer,
      the old stack pointer, the return address and PC of the start
      of the function.  */
-  stack_frame = frame_pointer_needed ? 16 : 0;
+  stack_frame = arm_apcs_frame_needed () ? 16 : 0;
 
+#ifdef TARGET_RISCOSAOF
+  if (from == ARG_POINTER_REGNUM || to == ARG_POINTER_REGNUM)
+    {
+      /* printf ("eliminate offset: local = %d, outgoing = %d, call_saved = %d, stack_frame = %d, total = %d\n",
+	      local_vars, outgoing_args, call_saved_registers, stack_frame,
+	      local_vars + outgoing_args + call_saved_registers + stack_frame - 4); */
+      return (local_vars + outgoing_args + call_saved_registers
+	      + stack_frame - 4);
+    }
+
+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+    return 0;
+
+  abort ();
+#else
   /* OK, now we have enough information to compute the distances.
      There must be an entry in these switch tables for each pair
      of registers in ELIMINABLE_REGS, even if some of the entries
@@ -9156,7 +9326,7 @@
 	  if (stack_frame == 0 && call_saved_registers != 0)
 	    return 0;
 	  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
-	  return (frame_pointer_needed
+	  return (arm_apcs_frame_needed ()
 		  && current_function_needs_context
 		  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;
 
@@ -9201,8 +9371,69 @@
 	 hard frame pointer will never be used.  */
       abort ();
     }
+#endif /* ! TARGET_RISCOSAOF */
+}
+
+/* NAB++ */
+/* Return non-zero if this is a leaf function.  */
+static int
+arm_leaf_function_p (void)
+{
+  if (cfun->machine->leaf < 0)
+    cfun->machine->leaf = leaf_function_p ();
+
+  return cfun->machine->leaf;
 }
 
+/* Return 1 if the function prologue should contain an explicit
+   stack check.  */
+static int
+arm_stack_check_needed (void)
+{
+  /* Don't do any stack checking if it was not asked for.  */
+  if (! TARGET_APCS_STACK)
+    return 0;
+
+  /* We will always use stack checking for non-optimising
+     circumstances.  */
+  if (! optimize)
+    return 1;
+
+  /* Don't do any stack checking if the function is a leaf function
+     and the amount of stack actually needed <= 256 bytes.  */
+  if (arm_leaf_function_p () && abs (cfun->machine->frame_size) <= 256)
+    return 0;
+
+  return 1;
+}
+
+/* Return 1 if the function prologue really needs to setup an APCS
+   frame.  */
+int
+arm_apcs_frame_needed ()
+{
+  /* If we are not targeting the APCS, we will not use a stack frame.  */
+  if (! TARGET_APCS_FRAME)
+    return 0;
+
+  /* If we are not optimising, or we call alloca, we will always
+     setup a frame.  */
+  if (current_function_calls_alloca
+      || current_function_has_nonlocal_goto
+      || current_function_has_nonlocal_label
+      || ! optimize)
+    return 1;
+
+  /* A frame will need to be setup for the cases where there are external
+     function calls within the current function or there is a need
+     for definite stack checking.  */
+  if (! arm_leaf_function_p () || arm_stack_check_needed ())
+    return 1;
+
+  return 0;
+}
+/* NAB-- */
+
 /* Calculate the size of the stack frame, taking into account any
    padding that is required to ensure stack-alignment.  */
 HOST_WIDE_INT
@@ -9236,7 +9467,7 @@
   if (reload_completed)
     return cfun->machine->frame_size;
 
-  leaf = leaf_function_p ();
+  leaf = arm_leaf_function_p (); /* NAB++ */
 
   /* A leaf function does not need any stack alignment if it has nothing
      on the stack.  */
@@ -9287,7 +9518,7 @@
 void
 arm_expand_prologue (void)
 {
-  int reg;
+  int reg, frame_size;
   rtx amount;
   rtx insn;
   rtx ip_rtx;
@@ -9311,7 +9542,7 @@
 
   ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);
 
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     {
       if (IS_INTERRUPT (func_type))
 	{
@@ -9431,7 +9662,7 @@
      can be done with a single instruction.  */
   if ((func_type == ARM_FT_ISR || func_type == ARM_FT_FIQ)
       && (live_regs_mask & (1 << LR_REGNUM)) != 0
-      && ! frame_pointer_needed)
+      && ! arm_apcs_frame_needed ())
     emit_insn (gen_rtx_SET (SImode, 
 			    gen_rtx_REG (SImode, LR_REGNUM),
 			    gen_rtx_PLUS (SImode,
@@ -9505,13 +9736,48 @@
 	}
     }
 
-  if (frame_pointer_needed)
-    {
+  /* NAB++ */
+  frame_size = -(arm_get_frame_size ()
+                 + current_function_outgoing_args_size);
+  /* NAB-- */
+  if (arm_apcs_frame_needed ())
+    {
+      /* NAB++ */
+      rtx fp_rtx = gen_rtx_REG (SImode, FP_REGNUM);
+      /* NAB -- */
+
       /* Create the new frame pointer.  */
       insn = GEN_INT (-(4 + args_to_push + fp_offset));
-      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));
+      insn = emit_insn (gen_addsi3 (fp_rtx, ip_rtx, insn)); /* NAB++ */
       RTX_FRAME_RELATED_P (insn) = 1;
       
+#ifdef TARGET_RISCOSAOF
+      /* Explicit stack checks.  */
+      if (TARGET_APCS_STACK)
+        {
+	  rtx sl_reg = gen_rtx_REG (GET_MODE (stack_pointer_rtx), 10);
+          if (frame_size <= -256)
+            {
+              rtx stkovf = gen_rtx_SYMBOL_REF (Pmode, ARM_STKOVF_SPLIT_BIG);
+              insn = emit_insn (gen_addsi3 (ip_rtx, stack_pointer_rtx,
+                                            GEN_INT (frame_size)));
+              RTX_FRAME_RELATED_P (insn) = 1;
+              insn = emit_insn (gen_rt_stkovf (ip_rtx, sl_reg, stkovf));
+              /* Create barrier to prevent real stack adjustment from being
+                 scheduled before call to stack checker.  */
+              emit_insn (gen_blockage ());
+            }
+          else
+            {
+              rtx stkovf = gen_rtx_SYMBOL_REF (Pmode, ARM_STKOVF_SPLIT_SMALL);
+
+              insn = emit_insn (gen_rt_stkovf (stack_pointer_rtx,
+                                               sl_reg, stkovf));
+            }
+          RTX_FRAME_RELATED_P (insn) = 1;
+        }
+#endif
+
       if (IS_NESTED (func_type))
 	{
 	  /* Recover the static chain register.  */
@@ -9520,8 +9786,13 @@
 	    insn = gen_rtx_REG (SImode, 3);
 	  else /* if (current_function_pretend_args_size == 0) */
 	    {
+#ifdef TARGET_RISCOSAOF
+	      insn = gen_rtx_PLUS (SImode, fp_rtx,
+				   GEN_INT (4));
+#else
 	      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx,
 				   GEN_INT (4));
+#endif
 	      insn = gen_rtx_MEM (SImode, insn);
 	    }
 
@@ -9531,16 +9802,14 @@
 	}
     }
 
-  amount = GEN_INT (-(arm_get_frame_size ()
-		      + current_function_outgoing_args_size));
 
-  if (amount != const0_rtx)
+  if (frame_size != 0) /* NAB++ */
     {
       /* This add can produce multiple insns for a large constant, so we
 	 need to get tricky.  */
       rtx last = get_last_insn ();
       insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-				    amount));
+				    GEN_INT (frame_size)));
       do
 	{
 	  last = last ? NEXT_INSN (last) : get_insns ();
@@ -9551,9 +9820,20 @@
       /* If the frame pointer is needed, emit a special barrier that
 	 will prevent the scheduler from moving stores to the frame
 	 before the stack adjustment.  */
-      if (frame_pointer_needed)
+      if (arm_apcs_frame_needed ())
 	insn = emit_insn (gen_stack_tie (stack_pointer_rtx,
 					 hard_frame_pointer_rtx));
+
+      /* NAB++ */
+#ifdef TARGET_RISCOSAOF
+      if (cfun->machine->apply_args || ! optimize)
+        {
+          insn = emit_insn (gen_movsi (frame_pointer_rtx,
+                                       stack_pointer_rtx));
+          RTX_FRAME_RELATED_P (insn) = 1;
+        }
+#endif
+      /* NAB-- */
     }
 
   /* If we are profiling, make sure no instructions are scheduled before
@@ -10513,7 +10793,7 @@
   
   /* If we are using the stack pointer to point at the
      argument, then an offset of 0 is correct.  */
-  if ((TARGET_THUMB || !frame_pointer_needed)
+  if ((TARGET_THUMB || !arm_apcs_frame_needed ())
       && REGNO (addr) == SP_REGNUM)
     return 0;
   
@@ -12087,6 +12367,8 @@
 #if ARM_FT_UNKNOWN != 0  
   machine->func_type = ARM_FT_UNKNOWN;
 #endif
+  machine->leaf = -1; /* NAB */
+  machine->apply_args = 0;
   return machine;
 }
 
@@ -12224,7 +12506,7 @@
       return;
     }
 
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     {
       insn = emit_insn (gen_movsi (hard_frame_pointer_rtx, stack_pointer_rtx));
       RTX_FRAME_RELATED_P (insn) = 1;
@@ -12261,7 +12543,7 @@
 	     it now.  */
 	  for (regno = LAST_ARG_REGNUM + 1; regno <= LAST_LO_REGNUM; regno++)
 	    if (THUMB_REG_PUSHED_P (regno)
-		&& !(frame_pointer_needed
+		&& !(arm_apcs_frame_needed ()
 		     && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))
 	      break;
 
@@ -12334,7 +12616,7 @@
   if (IS_NAKED (arm_current_func_type ()))
     return;
 
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));
   else if (amount)
     {
@@ -12931,10 +13213,24 @@
       name += skip;
     }
 
+/* NAB++ */
+#ifdef AOF_ASSEMBLER
+  if (name[0] != '|')
+    fputc ('|', stream);
+#endif
+/* NAB-- */
+
   if (verbatim)
     fputs (name, stream);
   else
     asm_fprintf (stream, "%U%s", name);
+
+/* NAB++ */
+#ifdef AOF_ASSEMBLER
+  if (name[0] != '|')
+    fputc ('|', stream);
+#endif
+/* NAB-- */
 }
 
 rtx aof_pic_label;
@@ -12950,8 +13246,10 @@
 
 static struct pic_chain * aof_pic_chain = NULL;
 
+/* If type == 0, then return an offset against x$adcons, otherwise
+   just supply an RTX const.  */
 rtx
-aof_pic_entry (rtx x)
+aof_pic_entry (rtx x, int type)
 {
   struct pic_chain ** chainp;
   int offset;
@@ -12964,12 +13262,18 @@
   for (offset = 0, chainp = &aof_pic_chain; *chainp;
        offset += 4, chainp = &(*chainp)->next)
     if ((*chainp)->symname == XSTR (x, 0))
+      {
+	if (type == 0)
       return plus_constant (aof_pic_label, offset);
+	return GEN_INT (offset);
+      }
 
   *chainp = (struct pic_chain *) xmalloc (sizeof (struct pic_chain));
   (*chainp)->next = NULL;
   (*chainp)->symname = XSTR (x, 0);
+  if (type == 0)
   return plus_constant (aof_pic_label, offset);
+  return GEN_INT (offset);
 }
 
 void
@@ -12980,6 +13284,9 @@
   if (aof_pic_chain == NULL)
     return;
 
+  if (TARGET_MODULE)
+    asm_fprintf (f, "\tAREA |%r$$adcons|\n", PIC_OFFSET_TABLE_REGNUM);
+  else
   asm_fprintf (f, "\tAREA |%r$$adcons|, BASED %r\n",
 	       PIC_OFFSET_TABLE_REGNUM,
 	       PIC_OFFSET_TABLE_REGNUM);
@@ -13001,7 +13308,7 @@
   static char buf[100];
   sprintf (buf, "\tAREA |C$$code%d|, CODE, READONLY",
 	   arm_text_section_count++);
-  if (flag_pic)
+  if (flag_pic && !TARGET_MODULE)
     strcat (buf, ", PIC, REENTRANT");
   return buf;
 }
@@ -13016,6 +13323,30 @@
   return buf;
 }
 
+/* NAB ++ */
+static int arm_rodata_section_count = 1;
+
+char *
+aof_rodata_section ()
+{
+  static char buf[100];
+  sprintf (buf, "\tAREA |C$$rodata%d|, DATA, READONLY",
+           arm_rodata_section_count++);
+  return buf;
+}
+
+static int arm_bss_section_count = 1;
+
+char *
+aof_bss_section ()
+{
+  static char buf[100];
+  sprintf (buf, "\tAREA |C$$bss%d|, DATA, NOINIT",
+           arm_data_section_count++);
+  return buf;
+}
+/* NAB -- */
+
 /* The AOF assembler is religiously strict about declarations of
    imported and exported symbols, so that it is impossible to declare
    a function as imported near the beginning of the file, and then to
@@ -13075,8 +13406,8 @@
   if (arm_main_function)
     {
       text_section ();
-      fputs ("\tIMPORT __main\n", f);
-      fputs ("\tDCD __main\n", f);
+      fputs ("\tIMPORT\t|__main|\n", f);
+      fputs ("\tDCD\t|__main|\n", f);
     }
 
   /* Now dump the remaining imports.  */
@@ -13100,31 +13431,8 @@
 static void
 aof_file_start (void)
 {
-  fputs ("__r0\tRN\t0\n", asm_out_file);
-  fputs ("__a1\tRN\t0\n", asm_out_file);
-  fputs ("__a2\tRN\t1\n", asm_out_file);
-  fputs ("__a3\tRN\t2\n", asm_out_file);
-  fputs ("__a4\tRN\t3\n", asm_out_file);
-  fputs ("__v1\tRN\t4\n", asm_out_file);
-  fputs ("__v2\tRN\t5\n", asm_out_file);
-  fputs ("__v3\tRN\t6\n", asm_out_file);
-  fputs ("__v4\tRN\t7\n", asm_out_file);
-  fputs ("__v5\tRN\t8\n", asm_out_file);
-  fputs ("__v6\tRN\t9\n", asm_out_file);
-  fputs ("__sl\tRN\t10\n", asm_out_file);
-  fputs ("__fp\tRN\t11\n", asm_out_file);
-  fputs ("__ip\tRN\t12\n", asm_out_file);
-  fputs ("__sp\tRN\t13\n", asm_out_file);
-  fputs ("__lr\tRN\t14\n", asm_out_file);
-  fputs ("__pc\tRN\t15\n", asm_out_file);
-  fputs ("__f0\tFN\t0\n", asm_out_file);
-  fputs ("__f1\tFN\t1\n", asm_out_file);
-  fputs ("__f2\tFN\t2\n", asm_out_file);
-  fputs ("__f3\tFN\t3\n", asm_out_file);
-  fputs ("__f4\tFN\t4\n", asm_out_file);
-  fputs ("__f5\tFN\t5\n", asm_out_file);
-  fputs ("__f6\tFN\t6\n", asm_out_file);
-  fputs ("__f7\tFN\t7\n", asm_out_file);
+  fprintf (asm_out_file, "%s Generated by gcc %s for ARM/%s\n",
+	   ASM_COMMENT_START, version_string, ARM_OS_NAME);
   text_section ();
 }
 
@@ -13136,6 +13444,57 @@
   aof_dump_imports (asm_out_file);
   fputs ("\tEND\n", asm_out_file);
 }
+
+/* Switch to an arbitrary section NAME with attributes as specified
+   by FLAGS.  ALIGN specifies any known alignment requirements for
+   the section; 0 if the default should be used.
+
+   Differs from the default elf version only in the prefix character
+   used before the section type.  */
+
+static void
+arm_aof_asm_named_section (const char *name, unsigned int flags)
+{
+  char flagchars[10], *f = flagchars;
+
+  fprintf (asm_out_file, "\tAREA\t|C$$%s|", name);
+
+  if (flags & SECTION_DEBUG)
+    fprintf (asm_out_file, ", DEBUG");
+  if (!(flags & SECTION_WRITE))
+    fprintf (asm_out_file, ", READONLY");
+  if (flags & SECTION_CODE)
+    fprintf (asm_out_file, ", CODE");
+  else
+    fprintf (asm_out_file, ", DATA");
+  if (flags & SECTION_BSS)
+    {
+      fprintf (asm_out_file, ", NOINIT");
+      if (flags & SECTION_LINKONCE)
+        fprintf (asm_out_file, ", COMMON");
+    }
+  else if (flags & SECTION_LINKONCE)
+    fprintf (asm_out_file, ", COMDEF, LINKONCE");
+
+  putc ('\n', asm_out_file);
+}
+
+/* This filters out the COMDEF area (section) before calling
+   the "lame default section selector".  */
+
+static void
+arm_aof_select_section (tree decl, int reloc,
+		        unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
+{
+  if (DECL_P (decl) && DECL_COMMON (decl))
+    {
+      comdef_section ();
+      fprintf (asm_out_file, "\tAREA\t|%s|, DATA, COMDEF\n",
+               XSTR (XEXP (DECL_RTL (decl), 0), 0));
+    }
+  else
+    default_select_section (decl, reloc, align);
+}
 #endif /* AOF_ASSEMBLER */
 
 #ifdef OBJECT_FORMAT_ELF
