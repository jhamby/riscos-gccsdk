--- /home/nick/riscos/masters/gcc-3.4/gcc/config/arm/arm.c	2004-05-03 15:24:51.000000000 +0100
+++ config/arm/arm.c	2004-12-03 13:40:15.834665736 +0000
@@ -110,6 +110,7 @@ static unsigned long arm_isr_value (tree
 static unsigned long arm_compute_func_type (void);
 static tree arm_handle_fndecl_attribute (tree *, tree, tree, int, bool *);
 static tree arm_handle_isr_attribute (tree *, tree, tree, int, bool *);
+static int arm_leaf_function_p (void);
 static void arm_output_function_epilogue (FILE *, HOST_WIDE_INT);
 static void arm_output_function_prologue (FILE *, HOST_WIDE_INT);
 static void thumb_output_function_prologue (FILE *, HOST_WIDE_INT);
@@ -149,6 +150,7 @@ static void aof_dump_imports (FILE *);
 static void aof_dump_pic_table (FILE *);
 static void aof_file_start (void);
 static void aof_file_end (void);
+static void arm_aof_asm_named_section (const char *, unsigned int);
 #endif
 
 
@@ -1030,7 +1032,7 @@ use_return_insn (int iscond, rtx sibling
     return 0;
 
   /* So do interrupt functions that use the frame pointer.  */
-  if (IS_INTERRUPT (func_type) && frame_pointer_needed)
+  if (IS_INTERRUPT (func_type) && arm_apcs_frame_needed ())
     return 0;
 
   stack_adjust = arm_get_frame_size () + current_function_outgoing_args_size;
@@ -1040,11 +1042,13 @@ use_return_insn (int iscond, rtx sibling
       || cfun->machine->uses_anonymous_args
       /* Or if the function calls __builtin_eh_return () */
       || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER
-      /* Or if the function calls alloca */
-      || current_function_calls_alloca
+      /* NAB++ */
+      || (current_function_calls_alloca && ! TARGET_APCS_FRAME)
+      /* NAB-- */
       /* Or if there is a stack adjustment.  However, if the stack pointer
-	 is saved on the stack, we can use a pre-incrementing stack load.  */
-      || !(stack_adjust == 0 || (frame_pointer_needed && stack_adjust == 4)))
+         is saved on the stack, we can use a pre-incrementing stack load.  */
+      || !(stack_adjust == 0 ||
+	   (arm_apcs_frame_needed () && stack_adjust == 4)))
     return 0;
 
   saved_int_regs = arm_compute_save_reg_mask ();
@@ -2485,8 +2489,9 @@ arm_function_ok_for_sibcall (tree decl, 
     return false;
 
   /* Never tailcall something for which we have no decl, or if we
-     are in Thumb mode.  */
-  if (decl == NULL || TARGET_THUMB)
+     are in Thumb mode.  With explicit stack checking, tail calls
+     result in undefined behaviour.  */
+  if (decl == NULL || TARGET_THUMB || TARGET_APCS_STACK) /* NAB */
     return false;
 
   /* Get the calling method.  */
@@ -8096,7 +8101,7 @@ arm_compute_save_reg0_reg12_mask (void)
 
       /* Handle the frame pointer as a special case.  */
       if (! TARGET_APCS_FRAME
-	  && ! frame_pointer_needed
+	  && ! arm_apcs_frame_needed ()
 	  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]
 	  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])
 	save_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;
@@ -8127,7 +8132,7 @@ arm_compute_save_reg_mask (void)
 
   /* If we are creating a stack frame, then we must save the frame pointer,
      IP (which will hold the old stack pointer), LR and the PC.  */
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     save_reg_mask |=
       (1 << ARM_HARD_FRAME_POINTER_REGNUM)
       | (1 << IP_REGNUM)
@@ -8256,7 +8261,7 @@ output_return_instruction (rtx operand, 
 	     corrupted it, or 3) it was saved to align the stack on
 	     iWMMXt.  In case 1, restore IP into SP, otherwise just
 	     restore IP.  */
-	  if (frame_pointer_needed)
+	  if (arm_apcs_frame_needed ())
 	    {
 	      live_regs_mask &= ~ (1 << IP_REGNUM);
 	      live_regs_mask |=   (1 << SP_REGNUM);
@@ -8292,15 +8297,23 @@ output_return_instruction (rtx operand, 
 	  char *p;
 	  int first = 1;
 
+#ifdef TARGET_RISCOSAOF
+          if (arm_apcs_frame_needed ())
+            sprintf (instr, "ldm%sea\t%%|fp, {", conditional);
+          else if (live_regs_mask & (1 << SP_REGNUM))
+            sprintf (instr, "ldm%sfd\t%%|sp, {", conditional);
+          else
+            sprintf (instr, "ldm%sfd\t%%|sp!, {", conditional);
+#else
 	  /* Generate the load multiple instruction to restore the
 	     registers.  Note we can get here, even if
-	     frame_pointer_needed is true, but only if sp already
+	     arm_apcs_frame_needed () is true, but only if sp already
 	     points to the base of the saved core registers.  */
 	  if (live_regs_mask & (1 << SP_REGNUM))
 	    {
 	      unsigned HOST_WIDE_INT stack_adjust =
 		arm_get_frame_size () + current_function_outgoing_args_size;
-	      
+
 	      if (stack_adjust != 0 && stack_adjust != 4)
 		abort ();
 
@@ -8312,11 +8325,13 @@ output_return_instruction (rtx operand, 
 		     instead.  */
 		  if (stack_adjust)
 		    live_regs_mask |= 1 << 3;
+
 		  sprintf (instr, "ldm%sfd\t%%|sp, {", conditional);
 		}
 	    }
 	  else
 	    sprintf (instr, "ldm%sfd\t%%|sp!, {", conditional);
+#endif
 
 	  p = instr + strlen (instr);
 
@@ -8501,14 +8516,23 @@ arm_output_function_prologue (FILE *f, H
   if (IS_NESTED (func_type))
     asm_fprintf (f, "\t%@ Nested: function declared inside another function.\n");
     
-  asm_fprintf (f, "\t%@ args = %d, pretend = %d, frame = %wd\n",
+  asm_fprintf (f, "\t%@ args = %d, pretend = %d, frame = %wd, alloca = %d\n",
 	       current_function_args_size,
-	       current_function_pretend_args_size, frame_size);
+	       current_function_pretend_args_size, frame_size,
+	       current_function_calls_alloca);
 
   asm_fprintf (f, "\t%@ frame_needed = %d, uses_anonymous_args = %d\n",
-	       frame_pointer_needed,
+	       arm_apcs_frame_needed (),
 	       cfun->machine->uses_anonymous_args);
 
+  asm_fprintf (f, "\t%@ nonlocal_label = %d, nonlocal_goto = %d, leaf = %d\n",
+               current_function_has_nonlocal_label,
+               current_function_has_nonlocal_goto,
+               arm_leaf_function_p ());
+
+  asm_fprintf (f, "\t%@ outgoing_args = %d, pops_args = %d\n",
+	       cfun->outgoing_args_size, cfun->pops_args);
+
   if (cfun->machine->lr_save_eliminated)
     asm_fprintf (f, "\t%@ link register save eliminated.\n");
 
@@ -8578,7 +8602,7 @@ arm_output_epilogue (rtx sibling)
     if (saved_regs_mask & (1 << reg))
       floats_offset += 4;
   
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     {
       int vfp_offset = 4;
 
@@ -8667,6 +8691,9 @@ arm_output_epilogue (rtx sibling)
       else
 	saved_regs_mask &= ~ (1 << PC_REGNUM);
 
+#ifdef TARGET_RISCOSAOF
+      print_multi_reg (f, "ldmea\t%r", FP_REGNUM, saved_regs_mask);
+#else
       /* We must use SP as the base register, because SP is one of the
          registers being restored.  If an interrupt or page fault
          happens in the ldm instruction, the SP might or might not
@@ -8682,6 +8709,7 @@ arm_output_epilogue (rtx sibling)
 	asm_fprintf (f, "\tsub\t%r, %r, #%d\n", SP_REGNUM, FP_REGNUM,
 		     4 * bit_count (saved_regs_mask));
       print_multi_reg (f, "ldmfd\t%r", SP_REGNUM, saved_regs_mask);
+#endif
 
       if (IS_INTERRUPT (func_type))
 	/* Interrupt handlers will have pushed the
@@ -8814,7 +8842,7 @@ arm_output_epilogue (rtx sibling)
       break;
 
     default:
-      if (frame_pointer_needed)
+      if (arm_apcs_frame_needed ())
 	/* If we used the frame pointer then the return address
 	   will have been loaded off the stack directly into the
 	   PC, so there is no need to issue a MOV instruction
@@ -8853,8 +8881,8 @@ arm_output_function_epilogue (FILE *file
 
       if (use_return_insn (FALSE, NULL)
 	  && return_used_this_function
-	  && (frame_size + current_function_outgoing_args_size) != 0
-	  && !frame_pointer_needed)
+/* NAB */ && abs (frame_size + current_function_outgoing_args_size) > 256
+	  && !arm_apcs_frame_needed ())
 	abort ();
 
       /* Reset the ARM-specific per-function variables.  */
@@ -9040,6 +9068,49 @@ emit_sfm (int base_reg, int count)
   return par;
 }
 
+/* NAB++ */
+/* Given FROM and TO register numbers, say whether this elimination is
+   allowed.  Frame pointer elimination is automatically handled.  */
+int
+arm_can_eliminate (from, to)
+     int from, to;
+{
+#ifdef TARGET_RISCOSAOF
+  /* We can eliminate ARGP to STACKP if no alloca, no stack checks needed
+     and frame not needed.  */
+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM
+      && ! arm_apcs_frame_needed ())
+    return 1;
+  
+  /* FRAMEP can be eliminated to STACKP.  */
+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+    return 1;
+  
+  /* Can't do any other eliminations.  */
+  return 0;
+#else
+  /*  All eliminations are permissible.  Note that ARG_POINTER_REGNUM and
+      HARD_FRAME_POINTER_REGNUM are in fact the same thing.  If we need a frame
+      pointer, we must eliminate FRAME_POINTER_REGNUM into
+      HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM or
+      ARG_POINTER_REGNUM.  */
+  if (to == FRAME_POINTER_REGNUM && from == ARG_POINTER_REGNUM)
+    return 0;
+
+  if (to == STACK_POINTER_REGNUM && arm_apcs_frame_needed ())
+    return 0;
+
+  if (to == ARM_HARD_FRAME_POINTER_REGNUM && TARGET_THUMB)
+    return 0;
+
+  if (to == THUMB_HARD_FRAME_POINTER_REGNUM && TARGET_ARM)
+    return 0;
+
+  return 1;
+#endif
+}
+/* NAB-- */
+
 /* Compute the distance from register FROM to register TO.
    These can be the arg pointer (26), the soft frame pointer (25),
    the stack pointer (13) or the hard frame pointer (11).
@@ -9114,7 +9185,7 @@ arm_compute_initial_elimination_offset (
 	 doing so will preserve the stack's alignment.  Hence we
 	 must count them here.  For each set bit we need 4 bytes
 	 of stack space.  */
-      if (frame_pointer_needed)
+      if (arm_apcs_frame_needed ())
 	reg_mask &= 0x07ff;
       call_saved_registers += 4 * bit_count (reg_mask);
 
@@ -9135,8 +9206,23 @@ arm_compute_initial_elimination_offset (
   /* The stack frame contains 4 registers - the old frame pointer,
      the old stack pointer, the return address and PC of the start
      of the function.  */
-  stack_frame = frame_pointer_needed ? 16 : 0;
+  stack_frame = arm_apcs_frame_needed () ? 16 : 0;
+
+#ifdef TARGET_RISCOSAOF
+  if (from == ARG_POINTER_REGNUM || to == ARG_POINTER_REGNUM)
+    {
+      /* printf ("eliminate offset: local = %d, outgoing = %d, call_saved = %d, stack_frame = %d, total = %d\n",
+	      local_vars, outgoing_args, call_saved_registers, stack_frame,
+	      local_vars + outgoing_args + call_saved_registers + stack_frame - 4); */
+      return (local_vars + outgoing_args + call_saved_registers
+	      + stack_frame - 4);
+    }
+
+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
+    return 0;
 
+  abort ();
+#else
   /* OK, now we have enough information to compute the distances.
      There must be an entry in these switch tables for each pair
      of registers in ELIMINABLE_REGS, even if some of the entries
@@ -9162,7 +9248,7 @@ arm_compute_initial_elimination_offset (
 	  if (stack_frame == 0 && call_saved_registers != 0)
 	    return 0;
 	  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
-	  return (frame_pointer_needed
+	  return (arm_apcs_frame_needed ()
 		  && current_function_needs_context
 		  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;
 
@@ -9207,8 +9293,69 @@ arm_compute_initial_elimination_offset (
 	 hard frame pointer will never be used.  */
       abort ();
     }
+#endif /* ! TARGET_RISCOSAOF */
 }
 
+/* NAB++ */
+/* Return non-zero if this is a leaf function.  */
+static int
+arm_leaf_function_p (void)
+{
+  if (cfun->machine->leaf < 0)
+    cfun->machine->leaf = leaf_function_p ();
+
+  return cfun->machine->leaf;
+}
+
+/* Return 1 if the function prologue should contain an explicit
+   stack check.  */
+static int
+arm_stack_check_needed (void)
+{
+  /* Don't do any stack checking if it was not asked for.  */
+  if (! TARGET_APCS_STACK)
+    return 0;
+
+  /* We will always use stack checking for non-optimising
+     circumstances.  */
+  if (! optimize)
+    return 1;
+
+  /* Don't do any stack checking if the function is a leaf function
+     and the amount of stack actually needed <= 256 bytes.  */
+  if (arm_leaf_function_p () && abs (cfun->machine->frame_size) <= 256)
+    return 0;
+
+  return 1;
+}
+
+/* Return 1 if the function prologue really needs to setup an APCS
+   frame.  */
+int
+arm_apcs_frame_needed ()
+{
+  /* If we are not targeting the APCS, we will not use a stack frame.  */
+  if (! TARGET_APCS_FRAME)
+    return 0;
+
+  /* If we are not optimising, or we call alloca, we will always
+     setup a frame.  */
+  if (current_function_calls_alloca
+      || current_function_has_nonlocal_goto
+      || current_function_has_nonlocal_label
+      || ! optimize)
+    return 1;
+
+  /* A frame will need to be setup for the cases where there are external
+     function calls within the current function or there is a need
+     for definite stack checking.  */
+  if (! arm_leaf_function_p () || arm_stack_check_needed ())
+    return 1;
+
+  return 0;
+}
+/* NAB-- */
+
 /* Calculate the size of the stack frame, taking into account any
    padding that is required to ensure stack-alignment.  */
 HOST_WIDE_INT
@@ -9242,7 +9389,7 @@ arm_get_frame_size (void)
   if (reload_completed)
     return cfun->machine->frame_size;
 
-  leaf = leaf_function_p ();
+  leaf = arm_leaf_function_p (); /* NAB++ */
 
   /* A leaf function does not need any stack alignment if it has nothing
      on the stack.  */
@@ -9293,7 +9440,7 @@ arm_get_frame_size (void)
 void
 arm_expand_prologue (void)
 {
-  int reg;
+  int reg, frame_size;
   rtx amount;
   rtx insn;
   rtx ip_rtx;
@@ -9317,7 +9464,7 @@ arm_expand_prologue (void)
 
   ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);
 
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     {
       if (IS_INTERRUPT (func_type))
 	{
@@ -9437,7 +9584,7 @@ arm_expand_prologue (void)
      can be done with a single instruction.  */
   if ((func_type == ARM_FT_ISR || func_type == ARM_FT_FIQ)
       && (live_regs_mask & (1 << LR_REGNUM)) != 0
-      && ! frame_pointer_needed)
+      && ! arm_apcs_frame_needed ())
     emit_insn (gen_rtx_SET (SImode, 
 			    gen_rtx_REG (SImode, LR_REGNUM),
 			    gen_rtx_PLUS (SImode,
@@ -9511,13 +9658,49 @@ arm_expand_prologue (void)
 	}
     }
 
-  if (frame_pointer_needed)
-    {
+  /* NAB++ */
+  frame_size = -(arm_get_frame_size ()
+                 + current_function_outgoing_args_size);
+  /* NAB-- */
+  if (arm_apcs_frame_needed ())
+    {
+      /* NAB++ */
+      rtx fp_rtx = gen_rtx_REG (SImode, FP_REGNUM);
+      /* NAB -- */
+
       /* Create the new frame pointer.  */
       insn = GEN_INT (-(4 + args_to_push + fp_offset));
-      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));
+      insn = emit_insn (gen_addsi3 (fp_rtx, ip_rtx, insn)); /* NAB++ */
       RTX_FRAME_RELATED_P (insn) = 1;
       
+#ifdef TARGET_RISCOSAOF
+      /* Explicit stack checks.  */
+      if (TARGET_APCS_STACK)
+        {
+          rtx sl_reg = gen_rtx_REG (GET_MODE (stack_pointer_rtx), 10);
+	  
+          if (frame_size <= -256)
+            {
+              rtx stkovf = gen_rtx_SYMBOL_REF (Pmode, ARM_STKOVF_SPLIT_BIG);
+              insn = emit_insn (gen_addsi3 (ip_rtx, stack_pointer_rtx,
+                                            GEN_INT (frame_size)));
+              RTX_FRAME_RELATED_P (insn) = 1;
+              insn = emit_insn (gen_rt_stkovf (ip_rtx, sl_reg, stkovf));
+              /* Create barrier to prevent real stack adjustment from being
+                 scheduled before call to stack checker.  */
+              emit_insn (gen_blockage ());
+            }
+          else
+            {
+              rtx stkovf = gen_rtx_SYMBOL_REF (Pmode, ARM_STKOVF_SPLIT_SMALL);
+
+              insn = emit_insn (gen_rt_stkovf (stack_pointer_rtx,
+                                               sl_reg, stkovf));
+            }
+          RTX_FRAME_RELATED_P (insn) = 1;
+        }
+#endif
+
       if (IS_NESTED (func_type))
 	{
 	  /* Recover the static chain register.  */
@@ -9526,8 +9709,13 @@ arm_expand_prologue (void)
 	    insn = gen_rtx_REG (SImode, 3);
 	  else /* if (current_function_pretend_args_size == 0) */
 	    {
+#ifdef TARGET_RISCOSAOF
+	      insn = gen_rtx_PLUS (SImode, fp_rtx,
+				   GEN_INT (4));
+#else
 	      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx,
 				   GEN_INT (4));
+#endif
 	      insn = gen_rtx_MEM (SImode, insn);
 	    }
 
@@ -9537,16 +9725,14 @@ arm_expand_prologue (void)
 	}
     }
 
-  amount = GEN_INT (-(arm_get_frame_size ()
-		      + current_function_outgoing_args_size));
 
-  if (amount != const0_rtx)
+  if (frame_size != 0) /* NAB++ */
     {
       /* This add can produce multiple insns for a large constant, so we
 	 need to get tricky.  */
       rtx last = get_last_insn ();
       insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,
-				    amount));
+				    GEN_INT (frame_size)));
       do
 	{
 	  last = last ? NEXT_INSN (last) : get_insns ();
@@ -9557,9 +9743,20 @@ arm_expand_prologue (void)
       /* If the frame pointer is needed, emit a special barrier that
 	 will prevent the scheduler from moving stores to the frame
 	 before the stack adjustment.  */
-      if (frame_pointer_needed)
+      if (arm_apcs_frame_needed ())
 	insn = emit_insn (gen_stack_tie (stack_pointer_rtx,
 					 hard_frame_pointer_rtx));
+
+      /* NAB++ */
+#ifdef TARGET_RISCOSAOF
+      if (cfun->machine->apply_args || ! optimize)
+        {
+          insn = emit_insn (gen_movsi (frame_pointer_rtx,
+                                       stack_pointer_rtx));
+          RTX_FRAME_RELATED_P (insn) = 1;
+        }
+#endif
+      /* NAB-- */
     }
 
   /* If we are profiling, make sure no instructions are scheduled before
@@ -10519,7 +10716,7 @@ arm_debugger_arg_offset (int value, rtx 
   
   /* If we are using the stack pointer to point at the
      argument, then an offset of 0 is correct.  */
-  if ((TARGET_THUMB || !frame_pointer_needed)
+  if ((TARGET_THUMB || !arm_apcs_frame_needed ())
       && REGNO (addr) == SP_REGNUM)
     return 0;
   
@@ -12093,6 +12290,8 @@ arm_init_machine_status (void)
 #if ARM_FT_UNKNOWN != 0  
   machine->func_type = ARM_FT_UNKNOWN;
 #endif
+  machine->leaf = -1; /* NAB */
+  machine->apply_args = 0;
   return machine;
 }
 
@@ -12230,7 +12429,7 @@ thumb_expand_prologue (void)
       return;
     }
 
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     {
       insn = emit_insn (gen_movsi (hard_frame_pointer_rtx, stack_pointer_rtx));
       RTX_FRAME_RELATED_P (insn) = 1;
@@ -12267,7 +12466,7 @@ thumb_expand_prologue (void)
 	     it now.  */
 	  for (regno = LAST_ARG_REGNUM + 1; regno <= LAST_LO_REGNUM; regno++)
 	    if (THUMB_REG_PUSHED_P (regno)
-		&& !(frame_pointer_needed
+		&& !(arm_apcs_frame_needed ()
 		     && (regno == THUMB_HARD_FRAME_POINTER_REGNUM)))
 	      break;
 
@@ -12340,7 +12539,7 @@ thumb_expand_epilogue (void)
   if (IS_NAKED (arm_current_func_type ()))
     return;
 
-  if (frame_pointer_needed)
+  if (arm_apcs_frame_needed ())
     emit_insn (gen_movsi (stack_pointer_rtx, hard_frame_pointer_rtx));
   else if (amount)
     {
@@ -12937,10 +13136,22 @@ arm_asm_output_labelref (FILE *stream, c
       name += skip;
     }
 
+/* NAB++ */
+#ifdef AOF_ASSEMBLER
+  fputc ('|', stream);
+#endif
+/* NAB-- */
+
   if (verbatim)
     fputs (name, stream);
   else
     asm_fprintf (stream, "%U%s", name);
+
+/* NAB++ */
+#ifdef AOF_ASSEMBLER
+  fputc ('|', stream);
+#endif
+/* NAB-- */
 }
 
 rtx aof_pic_label;
@@ -13022,6 +13233,30 @@ aof_data_section (void)
   return buf;
 }
 
+/* NAB ++ */
+static int arm_rodata_section_count = 1;
+
+char *
+aof_rodata_section ()
+{
+  static char buf[100];
+  sprintf (buf, "\tAREA |C$$rodata%d|, DATA, READONLY",
+           arm_rodata_section_count++);
+  return buf;
+}
+
+static int arm_bss_section_count = 1;
+
+char *
+aof_bss_section ()
+{
+  static char buf[100];
+  sprintf (buf, "\tAREA |C$$bss%d|, DATA, NOINIT",
+           arm_data_section_count++);
+  return buf;
+}
+/* NAB -- */
+
 /* The AOF assembler is religiously strict about declarations of
    imported and exported symbols, so that it is impossible to declare
    a function as imported near the beginning of the file, and then to
@@ -13081,8 +13316,8 @@ aof_dump_imports (FILE *f)
   if (arm_main_function)
     {
       text_section ();
-      fputs ("\tIMPORT __main\n", f);
-      fputs ("\tDCD __main\n", f);
+      fputs ("\tIMPORT\t|__main|\n", f);
+      fputs ("\tDCD\t|__main|\n", f);
     }
 
   /* Now dump the remaining imports.  */
@@ -13106,6 +13341,8 @@ aof_globalize_label (FILE *stream, const
 static void
 aof_file_start (void)
 {
+  fprintf (asm_out_file, "%s Generated by gcc %s for ARM/%s\n",
+	   ASM_COMMENT_START, version_string, ARM_OS_NAME);
   fputs ("__r0\tRN\t0\n", asm_out_file);
   fputs ("__a1\tRN\t0\n", asm_out_file);
   fputs ("__a2\tRN\t1\n", asm_out_file);
@@ -13142,6 +13379,36 @@ aof_file_end (void)
   aof_dump_imports (asm_out_file);
   fputs ("\tEND\n", asm_out_file);
 }
+
+/* Switch to an arbitrary section NAME with attributes as specified
+   by FLAGS.  ALIGN specifies any known alignment requirements for
+   the section; 0 if the default should be used.
+
+   Differs from the default elf version only in the prefix character
+   used before the section type.  */
+
+static void
+arm_aof_asm_named_section (const char *name, unsigned int flags)
+{
+  char flagchars[10], *f = flagchars;
+
+  fprintf (asm_out_file, "\tAREA\t|C$$%s|", name);
+
+  if (flags & SECTION_DEBUG)
+    fprintf (asm_out_file, ", DEBUG");
+  if (!(flags & SECTION_WRITE))
+    fprintf (asm_out_file, ", READONLY");
+  if (flags & SECTION_CODE)
+    fprintf (asm_out_file, ", CODE");
+  else
+    fprintf (asm_out_file, ", DATA");
+  if (flags & SECTION_BSS)
+    fprintf (asm_out_file, ", NOINIT");
+  if (flags & SECTION_LINKONCE)
+    fprintf (asm_out_file, ", COMDEF, LINKONCE");
+
+  putc ('\n', asm_out_file);
+}
 #endif /* AOF_ASSEMBLER */
 
 #ifdef OBJECT_FORMAT_ELF
Index: config/arm/arm.c
===================================================================
RCS file: /usr/local/cvsroot/gccsdk/gcc/gcc/config/arm/arm.c,v
retrieving revision 1.28
diff -u -r1.28 arm.c
--- config/arm/arm.c	26 Nov 2004 17:02:27 -0000	1.28
+++ config/arm/arm.c	8 Dec 2004 17:21:12 -0000
@@ -586,6 +586,32 @@
 	abort ();
 
       insn_flags = sel->flags;
+
+#ifdef TARGET_TUNE_DEFAULT
+      /* If the user didn't specify tuning either, use the target's
+	 preferred flags.  */
+      if (tune_flags == 0)
+	{
+	  struct processors * tunesel;
+	  struct cpu_default * tunedef;
+
+	  for (tunedef = cpu_defaults; tunedef->name; tunedef++)
+	    if (tunedef->cpu == TARGET_TUNE_DEFAULT)
+	      break;
+
+	  if (tunedef->name == NULL)
+	    abort ();
+
+	  for (tunesel = all_cores; tunesel->name != NULL; tunesel++)
+	    if (streq (tunedef->name, tunesel->name))
+	      break;
+
+	  if (tunesel->name == NULL)
+	    abort ();
+
+	  tune_flags = tunesel->flags;
+	}
+#endif
       
       /* Now check to see if the user has specified some command line
 	 switch that require certain abilities from the cpu.  */
@@ -8057,7 +8083,7 @@
   fputs ("\"\n", stream);
 }
 
-/* Compute the register sabe mask for registers 0 through 12
+/* Compute the register save mask for registers 0 through 12
    inclusive.  This code is used by both arm_compute_save_reg_mask
    and arm_compute_initial_elimination_offset.  */
 static unsigned long
@@ -13343,31 +13369,6 @@
 {
   fprintf (asm_out_file, "%s Generated by gcc %s for ARM/%s\n",
 	   ASM_COMMENT_START, version_string, ARM_OS_NAME);
-  fputs ("__r0\tRN\t0\n", asm_out_file);
-  fputs ("__a1\tRN\t0\n", asm_out_file);
-  fputs ("__a2\tRN\t1\n", asm_out_file);
-  fputs ("__a3\tRN\t2\n", asm_out_file);
-  fputs ("__a4\tRN\t3\n", asm_out_file);
-  fputs ("__v1\tRN\t4\n", asm_out_file);
-  fputs ("__v2\tRN\t5\n", asm_out_file);
-  fputs ("__v3\tRN\t6\n", asm_out_file);
-  fputs ("__v4\tRN\t7\n", asm_out_file);
-  fputs ("__v5\tRN\t8\n", asm_out_file);
-  fputs ("__v6\tRN\t9\n", asm_out_file);
-  fputs ("__sl\tRN\t10\n", asm_out_file);
-  fputs ("__fp\tRN\t11\n", asm_out_file);
-  fputs ("__ip\tRN\t12\n", asm_out_file);
-  fputs ("__sp\tRN\t13\n", asm_out_file);
-  fputs ("__lr\tRN\t14\n", asm_out_file);
-  fputs ("__pc\tRN\t15\n", asm_out_file);
-  fputs ("__f0\tFN\t0\n", asm_out_file);
-  fputs ("__f1\tFN\t1\n", asm_out_file);
-  fputs ("__f2\tFN\t2\n", asm_out_file);
-  fputs ("__f3\tFN\t3\n", asm_out_file);
-  fputs ("__f4\tFN\t4\n", asm_out_file);
-  fputs ("__f5\tFN\t5\n", asm_out_file);
-  fputs ("__f6\tFN\t6\n", asm_out_file);
-  fputs ("__f7\tFN\t7\n", asm_out_file);
   text_section ();
 }
 
