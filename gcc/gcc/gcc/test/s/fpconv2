r0	RN	0
r1	RN	1
r2	RN	2
r3	RN	3
mant1	RN	0
xp1	RN	1

fractlo	RN	2
fracthi	RN	3
exponent	RN	12

lo	RN	2
hi	RN	3
ip	RN	12
sp	RN	13
r14	RN	14
lr	RN	14
pc	RN	15

	AREA	|C$$code|, CODE, READONLY

	EXPORT	fp_sfix_32bit
	; Convert single precision float to 32-bit int.
fp_sfix_32bit
	cmp	r0, #0
	moveqs	pc, r14

	mov	xp1, r0, lsr #23 ; Extract the exponent
	bic	mant1, r0, xp1, lsl #23 ; Clear exponent from mantissa
	orr	mant1, mant1, #1<<23 ; add implicit bit

	tst	xp1, #1<<8  ; Is sign bit set
	rsbne	mant1, mant1, #0 ; yes; negate mantissa

	bic	xp1, xp1, #1<<8 ; clear sign bit, leaving exponent

	; number is represented as 1.mantissa x 2^exponent-127
	subs	xp1, xp1, #127 ; remove bias (127) from exponent
	movmi	r0, #0 ; if exponent negative then not representable
	movmis	pc, r14 ; as an integer

	; the mantissa is 23 bits wide. assume we are representing the
	; number as mantissa x 2^23, then we may need to shift left
	; or right.
	rsbs	xp1, xp1, #23
	movpl	mant1, mant1, asr xp1

	rsbmi	xp1, xp1, #0 ; exponent was larger than 23
	movmi	mant1, mant1, asl xp1
	movs	pc, r14

	EXPORT	fp_sfix_64bit
	; Convert single precision float to 64-bit int
fp_sfix_64bit
	cmp	r0, #0
	moveq	r1, #0
	moveqs	pc, r14

	mov	xp1, r0, lsr #23 ; Extract the exponent
	bic	mant1, r0, xp1, lsl #23 ; Clear exponent from mantissa
	orr	mant1, mant1, #1<<23 ; add implicit bit

	tst	xp1, #1<<8  ; Is sign bit set
	rsbne	mant1, mant1, #0 ; yes; negate mantissa

	bic	xp1, xp1, #1<<8 ; clear sign bit, leaving exponent

	; number is represented as 1.mantissa x 2^exponent-127
	subs	xp1, xp1, #127 ; remove bias from exponent
	movmi	r0, #0 ; if exponent negative then not representable
	movmi	r1, #0
	movmis	pc, r14 ; as an integer

	; the mantissa is 23 bits wide. assume we are representing the
	; number as mantissa x 2^23, then we may need to shift left
	; or right.
	rsbs	xp1, xp1, #23
	movpl	mant1, mant1, asr xp1
	movpl	r1, #0
	movpls	pc, r14

	rsb	xp1, xp1, #0 ; exponent was larger than 23

	; perform 64-bit shift
        rsbs	ip, xp1, #32
	rsble	ip, ip, #0 ; shift >= 32 bits
	movle	r1, mant1, asl ip
	movle	r0, #0

	;movgt	hi, hi, lsl xp1 ; shift <= 31 bits
	movgt	hi, mant1, lsr ip
	;orrgt	hi, hi, mant1, lsr ip
	movgt	r0, mant1, asl xp1
	movgt	r1, hi
	movs	pc, r14


	EXPORT	fixdfdi
fixdfdi
	mov	ip, r0, lsr #30
	bl	fp_dfix_64bit
	movs	pc, lr

	EXPORT	fp_dfix_64bit
	; Convert double precision float to 64-bit int
fp_dfix_64bit
	cmp	r0, #0
	cmpeq	r1, #0
	moveqs	pc, r14

	; r0 = first word
	; r1 = second word

	mov	r3, r0, lsr #20 ; Extract the exponent
	bic	r2, r0, r3, lsl #20 ; clear exponent from fraction
	orr	r2, r2, #1<<20 ; add implicit bit

	tst	r3, #1<<11
	movne	ip, #1
	moveq	ip, #0

	bic	r0, r3, #1<<11 ; clear sign bit, leaving exponent

	; number is represented as 1.mantissa x 2^exponent-1023
	sub	r0, r0, #1024 ; remove bias from exponent
	adds	r0, r0, #1
	movmi	r0, #0 ; if exponent negative then not representable
	movmi	r1, #0 ; as an integer
	movmis	pc, lr

	; at this point: r0 = exponent
	; r1 = second word (bottom 32-bits of fraction)
	; r2 = first word (top 20-bits of fraction)

	rsbs	r0, r0, #52
	bmi	dfix_shift_left

	rsbs	r3, r0, #32  ; r3 = 32 - shift
	rsble	r3, r3, #0
	movle	r0, r2, asr r3 ; low = high >> -bm
	movle	r1, #0	 	; high = 0
	movgt	r1, r1, lsr r0  ; low >>= exponent
	orrgt	r1, r1, r2, lsl r3 ; low |= high << r3
	movgt	r2, r2, asr r0
	movgt	r0, r1
	movgt	r1, r2

	; Now adjust for sign bit.
	cmp	ip, #1
	movnes	pc, lr
	rsc	r1, r1, #0
	rsb	r0, r0, #0
	movs	pc, lr

dfix_shift_left
	rsb	r0, r0, #0 ; exponent was larger than 52

	; perform 64-bit shift
        rsbs	r3, r0, #32
	rsble	r3, r3, #0 ; shift >= 32 bits
	movle	r1, r0, asl r3
	movle	r0, #0

	movgt	r2, r2, lsl r0 ; shift <= 31 bits
	movgt	r0, r1, asl r0
	orrgt	r1, r2, r1, lsr r3

	; Now adjust for sign bit.
	cmp	ip, #1
	movnes	pc, lr
	rsbs	r1, r1, #0
	rsc	r0, r0, #0

	movs	pc, lr

