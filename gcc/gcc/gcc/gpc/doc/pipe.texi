@c Generated automatically from pipe.pas
@c DO NOT CHANGE THIS FILE MANUALLY!

@example
@{
Piping data from and to processes and process signaling

Copyright (C) 1998-2000 Free Software Foundation, Inc.

Author: Frank Heckenbach <frank@@pascal.gnu.de>

This file is part of GNU Pascal.

GNU Pascal is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU Pascal is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Pascal; see the file COPYING. If not, write to the
Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.

As a special exception, if you link this file with files compiled
with a GNU compiler to produce an executable, this does not cause
the resulting executable to be covered by the GNU General Public
License. This exception does not however invalidate any other
reasons why the executable file might be covered by the GNU General
Public License.
@}

@{$gnu-pascal,B-,I-@}
@{$if __GPC_RELEASE__ < 20000412@}
@{$error This unit requires GPC release 20000412 or newer.@}
@{$endif@}

@{ Keep this consistent with the one in pipec.c @}
@{$if defined(MSDOS) or defined(__MINGW32__)@}
@{$define NOFORK@}
@{$endif@}

unit Pipe;

interface

uses GPC;

(*$local W-*)type PPStrings = ^TPStrings;TPStrings (Count: Cardinal)
  = array [1 .. Count] of ^String; (*@@@@two unit bug with definition
  in gpc.pas in programs using these two units*) (*$endlocal*)

const
  PipeForking = @{$ifdef NOFORK@} False @{$else@} True @{$endif@};

type
  TProcedure = procedure;

  PWaitPIDResult = ^TWaitPIDResult;
  TWaitPIDResult = (PIDNothing, PIDExited, PIDSignaled, PIDStopped,
  PIDUnknown);

  PPipeProcess = ^TPipeProcess;
  TPipeProcess = record
    PID       : Integer;        @{ Process ID of process forked @}
    SignalPID : Integer;        @{ Process ID to send the signal to.
                                  Equals PID by default @}
    OpenPipes : Integer;        @{ Number of pipes to/from the
                                  process, for internal use @}
    Signal    : Integer;        @{ Send this signal (if not 0) to the
                                  process after all pipes have been
                                  closed after some time @}
    Seconds   : Integer;        @{ Wait so many seconds before
                                  sending the signal if the process
                                  has not terminated by itself @}
    Wait      : Boolean;        @{ Wait for the process, even longer
                                  than Seconds seconds, after
                                  sending the signal (if any) @}
    Result    : PWaitPIDResult; @{ Default nil. If a pointer to a
                                  variable is stored here, its
                                  destination will contain the
                                  information whether the process
                                  terminated by itself, or was
                                  terminated or stopped by a signal,
                                  when waiting after closing the
                                  pipes @}
    Status    : ^Integer;       @{ Default nil. If a pointer to a
                                  variable is stored here, its
                                  destination will contain the exit
                                  status if the process terminated
                                  by itself, or the number of the
                                  signal otherwise, when waiting
                                  after closing the pipes @}
  end;

const
  EFork  = 600; @{ cannot fork @samp{%s}' @}
  ESpawn = 601; @{ cannot spawn @samp{%s}' @}

var
  @{ Default values for TPipeProcess records created by Pipe @}
  DefaultPipeSignal  : Integer = 0;
  DefaultPipeSeconds : Integer = 0;
  DefaultPipeWait    : Boolean = True;

@{
  The procedure Pipe starts a process whose name is given by
  ProcessName, with the given parameters (can be null if no
  parameters) and environment, and create pipes from and/or to the
  process' standard input/output/error. ProcessName is searched for
  in the PATH with FSearchExecutable. Any of ToInputFile,
  FromOutputFile and FromStdErrFile can be null if the corresponding
  pipe is not wanted. FromOutputFile and FromStdErrFile may be
  identical, in which case standard output and standard error are
  redirected to the same pipe. The behaviour of other pairs of files
  being identical is undefined, and useless, anyway. The files are
  Assigned and Reset or Rewritten as appropriate. Errors are
  returned in IOResult. If Process is not null, a pointer to a
  record is stored there, from which the PID of the process created
  can be read, and by writing to which the action after all pipes
  have been closed can be changed. (The record is automatically
  Dispose'd of after all pipes have been closed.) If automatic
  waiting is turned off, the caller should get the PID from the
  record before it's Dispose'd of, and wait for the process sometime
  in order to avoid zombies. If no redirections are performed (i.e.,
  all 3 files are null), the caller should wait for the process with
  WaitPipeProcess. When an error occurs, Process is not assigned to,
  and the state of the files is undefined, so be sure to check
  IOResult before going on.

  ChildProc, if not nil, is called in the child process after
  forking and redirecting I/O, but before executing the new process.
  It can even be called instead of executing a new process
  (ProcessName can be empty then).

  The procedure even works under Dos, but, of course, in a limited
  sense: if ToInputFile is used, the process will not actually be
  started until ToInputFile is closed. Signal, Seconds and Wait of
  TPipeProcess are ignored, and PID and SignalPID do not contain a
  Process ID, but an internal value without any meaning to the
  caller. Result will always be PIDExited. So, Status is the only
  interesting field (but Result should also be checked). Since there
  is no forking under Dos, ChildProc, if not nil, is called in the
  main process before spawning the program. So, to be portable, it
  should not do any things that would influence the process after
  the return of the Pipe function.

  The only portable way to use "pipes" in both directions is to call
  @samp{Pipe}, write all the Input data to ToInputFile, close
  ToInputFile, and then read the Output and StdErr data from
  FromOutputFile and FromStdErrFile. However, since the capacity of
  pipes is limited, one should also check for Data from
  FromOutputFile and FromStdErrFile (using CanRead, IOSelect or
  IOSelectRead) while writing the Input data (under Dos, there
  simply won't be any data then, but checking for data doesn't do
  any harm). Please see pipedemo.pas for an example.
@}
(*@@@@IO critical*) procedure Pipe (var ToInputFile, FromOutputFile,
  FromStdErrFile : AnyFile; (*@@@@fjf265 const*) ProcessName : String;
  protected var Parameters : TPStrings; ProcessEnvironment :
  PCStrings; var Process : PPipeProcess; ChildProc : TProcedure);

@{
  Waits for a process created by Pipe as determined in the Process
  record. (Process is Dispose'd of afterwards.) Returns True if
  successful.
@}
function WaitPipeProcess (Process : PPipeProcess) : Boolean;

@end example
