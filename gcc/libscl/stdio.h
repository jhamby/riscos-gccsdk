/* stdio.h

   For use with the GNU compilers and the SharedCLibrary.
   Copyright (c) 1997, 1998, 1999 Nick Burrett.

   To use filename translation, define __UNAME.  */

#ifndef __STDIO_H
#define __STDIO_H

#ifndef __STDDEF_H
#include <stddef.h>
#endif

#if defined(__GNUC__)
/* va_list for the GCC compiler.  */
#define __need___va_list
#include <stdarg.h>

#elif defined(__LCC__)
/* va_list for the LCC compiler.  */
#ifndef _VA_LIST
#define _VA_LIST
typedef char *__va_list;
#endif

#else
/* Insert a definition of __va_list for your compiler here.
   Copy the definition of 'va_list' in <stddef.h> but prefix it
   with two underscores.  Then commend out the #error line below.  */
#error need definition of __va_list for your compiler
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define __LIB_VERSION 300

typedef struct __fpos_t_struct
{
  unsigned long __lo;
} fpos_t;

typedef struct __FILE_struct
{
  unsigned char *__ptr;
  int __icnt;
  int __ocnt;
  int __flag;
  unsigned char *__base;
  void *__file;
  long __pos;
  int __bufsiz;
  int __signature;
  int *internal;
} FILE;

#define _IOEOF 0x40
#define _IOERR 0x80
/* Full buffering.  */
#define _IOFBF 0x100
/* Line buffering.  */
#define _IOLBF 0x200
/* No buffering.  */
#define _IONBF 0x400
/* Default buffer size.  */
#define BUFSIZ (4096)
/* End of file character.  */
#define EOF (-1)

/* Maximum number of files that can be open at once.  */
#define FOPEN_MAX 8
/* Number of open files that is imposed by this library.  */
#define _SYS_OPEN 16

/* Maximum length of a filename.  */
#define FILENAME_MAX 80


/* Seek from beginning of file.  */
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
/* Seek from current position.  */
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif
/* Seek from end of file.  */
#ifndef SEEK_END
#define SEEK_END 2
#endif

/* How long an array of chars must be to be passed to tmpnam.  */
#define L_tmpnam 20
/* The maximum number of unique filenames generated by tmpnam.  */
#define TMP_MAX 1000000000

/* Standard streams.  */
extern FILE __iob[];

#define stdin (&__iob[0])
#define stdout (&__iob[1])
#define stderr (&__iob[2])

/* Delete file 'filename'.  */
extern int remove (const char *__filename);

#ifdef __UNAME
#define remove(f) (remove(__uname(f)))
#endif

/* Rename a file called 'oldname' to 'newname'. If rename fails
   it returns -1.  */
extern int rename (const char *__oldname, const char *__newname);

#ifdef __UNAME
#define rename(f, g) (rename(__uname(f), __uname(g)))
#endif

/* Create a temporary binary file for updade mode, as if calling
   fopen with mode "wb+".  The file is deleted automatically when
   it is closed or when the program terminates.  */
extern FILE *tmpfile (void);

/* Construct and return a file name that is a valid and does not
   name any existing file. If 'result' is null, the return value
   points to an internal static string. Otherwise, 'result' points
   to an array of at least L_tmpnam chars.  */
extern char *tmpnam (char *__result);

/* Cause 'stream' to be closed and the connection to the corresponding
   file to be broken.  All buffered output is written and buffered
   input is discarded. Returns 0 on success, EOF if an error was detected.  */
extern int fclose (FILE *__stream);

/* Cause any buffered output on 'stream' to be delivered to the file.
   If 'stream' is null, then fflush causes buffered output on all open
   output streams. Returns EOF if a write error occurs, zero otherwise.  */
extern int fflush (FILE *__stream);

/* Open a stream for I/O to the file 'filename' and return a pointer
   to the stream.  */
extern FILE *fopen (const char *__filename, const char *__opentype);

#ifdef __UNAME
#define fopen(f, t) (fopen(__uname(f), t))
#endif

/* Close the stream 'stream', ignoring any errors. Then 'filename'
   is opened with 'opentype' with the same stream object 'stream'.
   Returns null on failure.  Usually used to connect to standard
   streams e.g. stdin, stdout or stderr.  */
extern FILE *freopen (const char *__filename, const char *__opentype,
		      FILE *__stream);

#ifdef __UNAME
#define freopen(f, t, s) (freopen(__uname(f), t, s))
#endif


/* Set file buffering for 'stream'. If 'buf' is null, then
   file buffering is turned off, otherwise we use full file buffering.  */
extern void setbuf (FILE *__stream, char *__buf);

/* Specify that the stream 'stream' should have the buffering mode
   'mode', which can be either _IOFBF (full buffering), _IOLBF (line
   buffering) or _IONBF (unbuffered input/output).

   If 'buf' is null, then setvbuf allocates a buffer itself using
   malloc. This is freed when the stream is closed.

   Otherwise 'buf' is a character array of 'size' characters.  */
extern int setvbuf (FILE *__stream, char *__buf, int __mode,
		    size_t __size);

/* Print the optional arguments under control of the template
   string 'fmt' to the stream stdout. Returns the number of characters
   printed, or a negative value if there was an output error.  */
extern int printf (const char *__fmt, ...);

/* Similar to printf except the output is written to the stream
   'stream' instead of stdout.  */
extern int fprintf (FILE *__stream, const char *__fmt, ...);

/* Similar to printf except the output is stored in the array
   'string'. A null terminating character is also written.  */
extern int sprintf (char *__string, const char *__fmt, ...);

/* Read formatted input from the stream stdin under control
   of the template 'fmt'. Returns the number of successful
   assignments.  */
extern int scanf (const char *__fmt, ...);

/* Similar to scanf but reads from the stream 'stream'.  */
extern int fscanf (FILE *__stream, const char *__fmt, ...);

/* Similar to scanf but reads from the array 'string'.  */
extern int sscanf (const char *__string, const char *__fmt, ...);

/* Write formatted output to s from argument list arg.  limit is the
   maximum number of characters to produce.  */
extern int vsnprintf (char *__restrict __s, size_t __limit,
                      const char *__restrict __format,
                      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));

/* Write formatted output to s from argument list arg.  */
extern int vsprintf (char *__restrict __s,
                     const char *__restrict __format, __gnuc_va_list __arg);

/* Write formatted output to stream from arg list arg.  */
extern int vfprintf (FILE *__restrict __stream,
                     const char *__restrict __format, __gnuc_va_list __arg);

/* Write formatted output to stdio from arg list arg.  */
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

#ifndef __GNUC__
#pragma -v1
#endif

/* Write formatted output to s.  limit is the maximum number of characters
   to produce.  */
extern int snprintf (char *__restrict __s, size_t __limit,
                     const char *__restrict __format, ...)
     __attribute__ ((__format__ (__printf__, 3, 4)));

/* Write formatted output to s.  */
extern int sprintf (char *__restrict __s,
                    const char *__restrict __format, ...);

/* Write formatted output to stream.  */
extern int fprintf (FILE *__restrict __stream,
                    const char *__restrict __format, ...);

/* Write formatted output to stdout.  */
extern int printf (const char *__restrict __format, ...);

#ifndef __GNUC__
#pragma -v2
#endif

/* Read formatted input from s.  */
extern int sscanf (const char *__restrict __s,
                   const char *__restrict __format, ...);

/* Read formatted input from stream.  */
extern int fscanf (FILE *__restrict __stream,
                   const char *__restrict __format, ...);

/* Read formatted input from stdin.  */
extern int scanf (const char *__restrict __format, ...);

#ifndef __GNUC__
#pragma -v0
#endif

/* Read formatted input from stdin into argument list arg.  */
extern int vscanf (const char *__restrict __format, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__scanf__, 1, 0)));

/* Read formatted input from stream into argument list arg.  */
extern int vfscanf (FILE *__restrict __stream,
                    const char *__restrict __format, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__scanf__, 2, 0)));

/* Read formatted input from 's' into argument list arg.  */
extern int vsscanf (const char *__restrict __s,
                    const char *__restrict __format, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__scanf__, 2, 0)));


/* Read the next character as an unsigned char from the stream
   'stream' and return its value, converted to an int.  EOF
   is returned on read error/end-of-file.  */
extern int fgetc (FILE *__stream);
extern int __filbuf (FILE *__stream);

/* Similar to fgetc but implemented as a macro, so stream can be
   evaluated more than once.  */
extern int getc (FILE *__stream);
#define getc(p) \
 (--((p)->__icnt) >= 0 ? *((p)->__ptr)++ : __filbuf(p))

/* Equivalent to getc with a stream of stdin.  */
extern int getchar (void);
#define getchar() getc(stdin)

/* Read chars from the stream 'stream' up to and including a
   newline character and stores them in the string 's'. A null
   character is added to mark the end of the string.  The number
   of characters to read at most is 'count - 1'.  */
extern char *fgets (char *__s, int __count, FILE *__stream);

/* Read chars from the stream 'stdin' up to and including a
   new line. The newline character is discarded.  */
extern char *gets(char *__s);
extern int __flsbuf(int __c, FILE *__stream);

/* Convert the character 'c' to type unsigned char and writes it
   to stream 'stream'.  EOF is returned if an error occurs;
   otherwise the character 'c' is returned.  */
extern int putc (int __c, FILE *__stream);

#define putc(ch, p) \
 (--((p)->__ocnt) >= 0 ? (*((p)->__ptr)++ = (ch)) : __flsbuf(ch,p))

extern int fputc (int __c, FILE *__stream);

/* Equivalent to putc with stdout as the value of the stream argument.  */
extern int putchar (int __ch);
#define putchar(ch) putc(ch, stdout)


/* Write the string 's' top the stream 'stream'. The terminating null
   character is not written, and a newline character is not added, either.  */
extern int fputs(const char *__s, FILE *__stream);

/* Write the string 's' to stdout.  */
extern int puts (const char *__s);

/* Pushes back the character 'c' onto the input stream 'stream'.
   The next input from 'stream' will read 'c' before anything else.
   If 'c' is EOF, ungetc does nothing and just returns EOF.  */
extern int ungetc (int __c, FILE *__stream);

/* Read up to 'count' objects of size 'size' into the array 'data',
   from the stream 'stream'. Return the number of objects actually
   read.  */
extern size_t fread (void *__data, size_t __size, size_t __count,
		     FILE *stream);

/* Write up to 'count' objects of size 'size' from the array 'data',
   to the stream 'stream'. The return value is normally 'count' if the
   call succeeds.  */
extern size_t fwrite (const void *__data, size_t __size, size_t __count,
		      FILE *__stream);

/* Store the value of the file position indicator for the
   stream 'stream' in the fpos_t object pointed to by 'position'.
   fgetpos returns zero on success.  */
extern int fgetpos (FILE *__stream, fpos_t *__position);

/* Change the file position of the stream 'stream'. 'whence'
   must be one of the constants SEEK_SET, SEEK_CUR, SEEK_END,
   to indicate the meaning of the relative 'offset'.  */
extern int fseek (FILE *__stream, long int __offset, int __whence);

/* Set the file position indicator for the stream 'stream' to the
   position 'position', which must be set by a previous call to
   fgetpos.  */
extern int fsetpos (FILE *__stream, const fpos_t *__position);

/* Return the current file position of the stream 'stream'.
   If a failure occurs, -1 is returned.  */
extern long int ftell (FILE *__stream);

/* Positions the stream 'stream' at the beginning of the file.
   Equivalent to fseek (stream, 0, SEEK_SET).  */
extern void rewind (FILE *__stream);

/* Clears the end-of-file and error indicators for the stream
   'stream'.  */
extern void clearerr (FILE *__stream);

/* Return nonzero if the end-of-file indicator for stream 'stream'
   is set.  */
extern int feof (FILE *__stream);
#define feof(stream) ((stream)->__flag & _IOEOF)

/* Return nonzero if the error indicator for the stream 'stream'
   is set.  */
extern int ferror (FILE *__stream);
#define ferror(stream) ((stream)->__flag & _IOERR)

/* Print an error message to the stream 'stderr'.

   If 'message' is null, the error message corresponding to
   'errno' is printed.  */
extern void perror (const char *__message);

/* Extensions to the SharedCLibrary.  */

#ifdef __UNAME
extern char *__uname (char *name);
#endif

/* Return the system file descriptor for stream.  */
extern int fileno (FILE *__stream);
#define fileno(f) ((int)(f))

/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, const char *__modes);


#ifdef __cplusplus
}
#endif

#endif
