This is gmp.info, produced by makeinfo version 4.0 from gmp.texi.

INFO-DIR-SECTION GNU libraries
START-INFO-DIR-ENTRY
* gmp: (gmp).                   GNU Multiple Precision Arithmetic Library.
END-INFO-DIR-ENTRY

   This file documents GNU MP, a library for arbitrary-precision
arithmetic.

   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gmp.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

GNU MP
******

   This manual documents how to install and use the GNU multiple
precision arithmetic library, version 3.1.

* Menu:

* Copying::                    GMP Copying Conditions (LGPL).
* Introduction to GMP::        Brief introduction to GNU MP.
* Installing GMP::             How to configure and compile the GMP library.
* GMP Basics::                 What every GMP user should now.
* Reporting Bugs::             How to usefully report bugs.
* Integer Functions::          Functions for arithmetic on signed integers.
* Rational Number Functions::  Functions for arithmetic on rational numbers.
* Floating-point Functions::   Functions for arithmetic on floats.
* Low-level Functions::        Fast functions for natural numbers.
* Random Number Functions::    Functions for generating random numbers.
* BSD Compatible Functions::   All functions found in BSD MP.
* Custom Allocation::          How to customize the internal allocation.

* Contributors::	       Who brings your this library?
* References::                 Some useful papers and books to read.
* Concept Index::
* Function Index::


File: gmp.info,  Node: Copying,  Next: Introduction to GMP,  Prev: Top,  Up: Top

GNU MP Copying Conditions
*************************

   This library is "free"; this means that everyone is free to use it
and free to redistribute it on a free basis.  The library is not in the
public domain; it is copyrighted and there are restrictions on its
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of this
library that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the library, that you receive source code or else can
get it if you want it, that you can change this library or use pieces
of it in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the GNU MP library, you must give the recipients all the
rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the GNU MP library.  If it is
modified by someone else and passed on, we want their recipients to
know that what they have is not what we distributed, so that any
problems introduced by others will not reflect on our reputation.

   The precise conditions of the license for the GNU MP library are
found in the Library General Public License that accompany the source
code.


File: gmp.info,  Node: Introduction to GMP,  Next: Installing GMP,  Prev: Copying,  Up: Top

Introduction to GNU MP
**********************

   GNU MP is a portable library written in C for arbitrary precision
arithmetic on integers, rational numbers, and floating-point numbers.
It aims to provide the fastest possible arithmetic for all applications
that need higher precision than is directly supported by the basic C
types.

   Many applications use just a few hundred bits of precision; but some
applications may need thousands or even millions of bits.  GMP is
designed to give good performance for both, by choosing algorithms
based on the sizes of the operands, and by carefully keeping the
overhead at a minimum.

   The speed of GMP is achieved by using fullwords as the basic
arithmetic type, by using sophisticated algorithms, by including
carefully optimized assembly code for the most common inner loops for
many different CPUs, and by a general emphasis on speed (as opposed to
simplicity or elegance).

   There is carefully optimized assembly code for these CPUs: ARM, DEC
Alpha 21064, 21164, and 21264, AMD 29000, AMD K6 and Athlon, Hitachi
SuperH and SH-2, HPPA 1.0, 1.1 and 2.0, Intel Pentium, Pentium
Pro/Pentium II, generic x86, Intel i960, Motorola MC68000, MC68020,
MC88100, and MC88110, Motorola/IBM PowerPC 32 and 64, National NS32000,
IBM POWER, MIPS R3000, R4000, SPARCv7, SuperSPARC, generic SPARCv8,
UltraSPARC, DEC VAX, and Zilog Z8000.  Some optimizations also for
Clipper, IBM ROMP (RT), and Pyramid AP/XP.

   There is a mailing list for GMP users.  To join it, send a mail to
<gmp-request@swox.com> with the word `subscribe' in the message *body*
(not in the subject line).

   For up-to-date information on GMP, please see the GMP Home Pages at
`http://www.swox.com/gmp/'.

How to use this Manual
======================

   Everyone should read *Note GMP Basics::.  If you need to install the
library yourself, you need to read *Note Installing GMP::, too.

   The rest of the manual can be used for later reference, although it
is probably a good idea to glance through it.


File: gmp.info,  Node: Installing GMP,  Next: GMP Basics,  Prev: Introduction to GMP,  Up: Top

Installing GMP
**************

GMP has an autoconf/automake/libtool based configuration system.  On a
Unix-like system a basic build can be done with

     ./configure
     make

Some self-tests can be run with

     make check

And you can install (under `/usr/local' by default) with

     make install

If you experience problems, please report them to <bug-gmp@gnu.org>.
(*Note Reporting Bugs::, for information on what to include in useful
bug reports.)

* Menu:

* Build Options::
* ABI and ISA::
* Notes for Package Builds::
* Notes for Particular Systems::
* Known Build Problems::


File: gmp.info,  Node: Build Options,  Next: ABI and ISA,  Prev: Installing GMP,  Up: Installing GMP

Build Options
=============

All the usual autoconf configure options are available, run `./configure
--help' for a summary.

Non-Unix Systems
     `configure' needs various Unix-like tools installed.  On an MS-DOS
     system cygwin or djgpp should work.  It might be possible to build
     without the help of `configure', certainly all the code is there,
     but unfortunately you'll be on your own.

Object Directory
     To compile in a separate object directory, `cd' to that directory,
     and prefix the configure command with the path to the GMP source
     directory.  For example `../src/gmp/configure'.  Not all `make'
     programs have the necessary features (`VPATH') to support this.
     In particular, SunOS and Slowaris `make' have bugs that make them
     unable to build from a separate object directory.  Use GNU `make'
     instead.

`--disable-shared', `--disable-static'
     By default both shared and static libraries are built (where
     possible), but one or other can be disabled.  Shared libraries are
     very slightly slower, having a small cost on each function call,
     but result in smaller executables and permit code sharing between
     separate running processes.

`--target=CPU-VENDOR-OS'
     The build target can be specified in the usual way, for either
     native or cross compilation.

     If `--target' isn't given, `./configure' builds for the host
     system as determined by `./config.guess'.  On some systems this
     can't distinguish between different CPUs in a family, and you
     should check the guess.  Running `./config.guess' on the target
     system will also show the relevant `VENDOR-OS', if you don't
     already know what it should be.

     In general, if you want a library that runs as fast as possible,
     you should configure GMP for the exact CPU type your system uses.
     However, this may mean the binaries won't run on older members of
     the family, and might run slower on other members, older or newer.
     The best idea is always to build GMP for the exact machine type
     you intend to run it on.

     The following CPU targets have specific assembly code support.  See
     `configure.in' for which `mpn' subdirectories get used by each.

        * Alpha: `alpha', `alphaev5', `alphaev6'

        * Hitachi: `sh', `sh2'

        * HPPA: `hppa1.0', `hppa1.1', `hppa2.0', `hppa2.0w'

        * MIPS: `mips', `mips3',

        * Motorola: `m68000', `m68k', `m88k', `m88110'

        * POWER: `power1', `power2', `power2sc', `powerpc', `powerpc64'

        * SPARC: `sparc', `sparcv8', `microsparc', `supersparc',
          `sparcv9', `ultrasparc', `sparc64'

        * 80x86 family: `i386', `i486', `i586', `pentium', `pentiummmx',
          `pentiumpro', `pentium2', `pentium3', `k6', `k62', `k63',
          `athlon'

        * Other: `a29k', `arm', `clipper', `i960', `ns32k', `pyramid',
          `vax', `z8k'

     CPUs not listed use generic C code.  If some of the assembly code
     causes problems, the generic C code can be selected with CPU
     `none'.

`CC', `CFLAGS'
     The C compiler used is chosen from among some likely candidates,
     with GCC normally preferred if it's present.  The usual
     `CC=whatever' can be passed to `./configure' to choose something
     different.

     For some configurations specific compiler flags are set based on
     the target CPU and compiler, for others `CFLAGS="-whatever"' can
     be used to set the best flags.

     If `CC' is set then `CFLAGS' must also be set.  This applies even
     if `CC' is merely one of the choices GMP would make itself.  This
     may change in a future release.

`--disable-alloca'
     By default, GMP allocates temporary workspace using `alloca' if
     that function is available, or `malloc' if not.  If you're working
     with large numbers and `alloca' overflows the available stack
     space, you can build with `--disable-alloca' to use `malloc'
     instead.  `malloc' will probably be slightly slower than `alloca'.

     When not using `alloca', it's actually the allocation function
     selected with `mp_set_memory_functions' that's used, this being
     `malloc' by default.  *Note Custom Allocation::.

     Depending on your system, the only indication of stack overflow
     might be a segmentation violation.  It might be possible to
     increase available stack space with `limit', `ulimit' or
     `setrlimit', or under DJGPP with `stubedit' or `_stklen'.

`--enable-fft'
     By default multiplications are done using Karatsuba and 3-way
     Toom-Cook algorithms, but a Fermat FFT can be enabled, for use on
     large to very large operands.  Currently the FFT is recommended
     only for knowledgeable users who check the algorithm thresholds
     for their CPU.

`--enable-mpbsd'
     The Berkeley MP compatibility library (`libmp.a') and header file
     (`mp.h') are built and installed only if `--enable-mpbsd' is used.
     *Note BSD Compatible Functions::.

`MPN_PATH'
     Various assembler versions of mpn subroutines are provided, and,
     for a given CPU target, a search is made though a path to choose a
     version of each.  For example `sparcv8' has path `"sparc32/v8
     sparc32 generic"', which means it looks first for v8 code, falls
     back on plain sparc32, and finally falls back on generic C.
     Knowledgeable users with special requirements can specify a path
     with `MPN_PATH="dir list"'.  This will normally be unnecessary
     because all sensible paths should be available under one or other
     CPU target.

Demonstration Programs
     The `demos' subdirectory has some sample programs using GMP.  These
     aren't built or installed, but there's a `Makefile' with rules for
     them.  For instance, `make pexpr' and then `./pexpr 68^975+10'.

Documentation
     The document you're now reading is `gmp.texi'.  The usual automake
     targets are available to make `gmp.ps' and/or `gmp.dvi'.  Some
     supplementary notes can be found in the `doc' subdirectory.


File: gmp.info,  Node: ABI and ISA,  Next: Notes for Package Builds,  Prev: Build Options,  Up: Installing GMP

ABI and ISA
===========

   ABI (Application Binary Interface) refers to the calling conventions
between functions, meaning what registers are used and what sizes the
various C data types are.  ISA (Instruction Set Architecture) refers to
the instructions and registers a CPU has available.

   Some 64-bit ISA CPUs have both a 64-bit ABI and a 32-bit ABI
defined, the latter for compatibility with older CPUs in the family.
GMP chooses the best ABI available for a given target system, and this
generally gives significantly greater speed.

   The burden is on application programs and cooperating libraries to
ensure they match the ABI chosen by GMP.  Fortunately this presents a
difficulty only on a few systems, and if you have one of them then the
performance gains are enough to make it worth the trouble.

   Some of what's described in this section may change in future
releases of GMP.

HPPA 2.0
     CPU target `hppa2.0' uses the hppa2.0n 32-bit ABI, but either a
     32-bit or 64-bit limb.

     A 64-bit limb is available on HP-UX 10 or up when using `c89'.  No
     `gcc' support is planned for 64-bit operations in this ABI.
     Applications must be compiled with the same options as GMP, which
     means

          c89  +DA2.0 +e -D_LONG_LONG_LIMB

     A 32-bit limb is used in other cases, and no special compiler
     options are needed.

     CPU target `hppa2.0w' uses the hppa2.0w 64-bit ABI, which is
     available on HP-UX 11 or up when using `c89'.  `gcc' support for
     this is in progress.  Applications must be compiled for the same
     ABI, which means

          c89  +DD64

MIPS 3 and 4 under IRIX 6
     Targets `mips*-*-irix6*' use the n32 ABI and a 64-bit limb.
     Applications must be compiled for the same ABI, which means either

          gcc  -mabi=n32
          cc   -n32

PowerPC 64
     CPU target `powerpc64' uses either the 32-bit ABI or the AIX
     64-bit ABI.  The latter is used on targets `powerpc64-*-aix*' and
     applications must be compiled using either

          gcc  -maix64
          xlc  -q64

     On other systems the 32-bit ABI is used, but with 64-bit limbs
     provided by `long long' in `gcc'.  Applications must be compiled
     using

          gcc  -D_LONG_LONG_LIMB

Sparc V9
     On a sparc v9 CPU, either the v8plus 32-bit ABI or v9 64-bit ABI
     is used.  Targets `ultrasparc*-*-solaris2.[7-9]',
     `sparcv9-*-solaris2.[7-9]' and `sparc64-*-linux*' use the v9 ABI,
     if the compiler supports it.  Other targets use the v8plus ABI
     (but with as much of the v9 ISA as possible in the circumstances).
     Note that Solaris prior to 2.7 doesn't save all registers
     properly, and hence uses the v8plus ABI.

     For the v8plus ABI, applications can be compiled with either

          gcc  -mv8plus
          cc   -xarch=v8plus

     For the v9 ABI, applications must be compiled with either

          gcc  -m64 -mptr64 -Wa,-xarch=v9 -mcpu=v9
          cc   -xarch=v9

     Don't be confused by the names of these options, they're called
     `arch' but they effectively control the ABI.


File: gmp.info,  Node: Notes for Package Builds,  Next: Notes for Particular Systems,  Prev: ABI and ISA,  Up: Installing GMP

Notes for Package Builds
========================

   GMP should present no great difficulties for packaging in a binary
distribution.

   Libtool is used to build the library and `-version-info' is set
appropriately, having started from `3:0:0' in GMP 3.0.  The GMP 3 series
will be upwardly binary compatible in each release, but may be adding
additional function interfaces.  On systems where libtool versioning is
not fully checked by the loader, an auxiliary mechanism may be needed
to express that a dynamic linked application depends on a new enough
minor version of GMP.

   When building a package for a CPU family, care should be taken to use
`--target' to choose the least common denominator among the CPUs which
might use the package.  For example this might necessitate `i386' for
x86s, or plain `sparc' (meaning V7) for SPARCs.

   Users who care about speed will want GMP built for their exact CPU
type, to make use of the available optimizations.  Providing a way to
suitably rebuild a package may be useful.  This could be as simple as
making it possible for a user to omit `--target' in a build so
`./config.guess' will detect the CPU.  But a way to manually specify a
`--target' will be wanted for systems where `./config.guess' is inexact.


File: gmp.info,  Node: Notes for Particular Systems,  Next: Known Build Problems,  Prev: Notes for Package Builds,  Up: Installing GMP

Notes for Particular Systems
============================

AIX 4.3
     Targets `*-*-aix4.[3-9]*' have shared libraries disabled since
     they seem to fail on AIX 4.3.

OpenBSD 2.6
     `m4' in this release of OpenBSD has a bug in `eval' that makes it
     unsuitable for `.asm' file processing.  `./configure' will detect
     the problem and either abort or choose another m4 in the `PATH'.
     The bug is fixed in OpenBSD 2.7, so either upgrade or use GNU m4.

Sparc V8
     Using CPU target `sparcv8' or `supersparc' on relevant systems will
     give a significant performance increase over the V7 code.

SunOS 4
     `/usr/bin/m4' lacks various features needed to process `.asm'
     files, and instead `./configure' will automatically use
     `/usr/5bin/m4', which we believe is always available (if not then
     use GNU m4).

x86 Pentium and PentiumPro
     The Intel Pentium P5 code is good for its intended P5, but quite
     slow when run on Intel P6 class chips (PPro, P-II, P-III).  `i386'
     is a better choice if you're making binaries that must run on both.

x86 MMX and old GAS
     Old versions of GAS don't support MMX instructions, in particular
     version 1.92.3 that comes with FreeBSD 2.2.8 doesn't (and
     unfortunately there's no newer assembler for that system).

     If the target CPU has MMX code but the assembler doesn't support
     it, a warning is given and non-MMX code is used instead.  This
     will be an inferior build, since the MMX code that's present is
     there because it's faster than the corresponding plain integer
     code.

x86 GCC 2.95.2 `-march=pentiumpro'
     GCC 2.95.2 miscompiles `mpz/powm.c' when `-march=pentiumpro' is
     used, so that option is omitted from the `CFLAGS' chosen for
     relevant CPUs.  The problem is believed to be fixed in GCC 2.96.


File: gmp.info,  Node: Known Build Problems,  Prev: Notes for Particular Systems,  Up: Installing GMP

Known Build Problems
====================

   You might find more up-to-date information at
`http://www.swox.com/gmp/'.

Generic C on a 64-bit system
     When making a generic C build using `--target=none' on a 64-bit
     system (meaning where `unsigned long' is 64 bits),
     `BITS_PER_MP_LIMB', `BITS_PER_LONGINT' and `BYTES_PER_MP_LIMB' in
     `mpn/generic/gmp-mparam.h' need to be changed to 64 and 8.  This
     will hopefully be automated in a future version of GMP.

NeXT prior to 3.3
     The system compiler on old versions of NeXT was a massacred and
     old GCC, even if it called itself `cc'.  This compiler cannot be
     used to build GMP, you need to get a real GCC, and install that
     before you compile GMP.  (NeXT may have fixed this in release 3.3
     of their system.)

POWER and PowerPC
     Bugs in GCC 2.7.2 (and 2.6.3) mean it can't be used to compile GMP
     on POWER or PowerPC.  If you want to use GCC for these machines,
     get GCC 2.7.2.1 (or later).

Sequent Symmetry
     Use the GNU assembler instead of the system assembler, since the
     latter has serious bugs.

Stripped Libraries
     GNU binutils `strip' should not be used on the static libraries
     `libgmp.a' and `libmp.a', neither directly nor via `make
     install-strip'.  It can be used on the shared libraries
     `libgmp.so' and `libmp.so' though.

     Currently (binutils 2.10.0), `strip' extracts archives into a
     single directory, but GMP contains multiple object files of the
     same name (eg. three versions of `init.o'), and they overwrite
     each other, leaving only the one that happens to be last.

     If stripped static libraries are wanted, the suggested workaround
     is to build normally, strip the separate object files, and do
     another `make all' to rebuild.  Alternately `CFLAGS' with `-g'
     omitted can always be used if it's just debugging which is
     unwanted.

SunOS 4 Native Tools
     The setting for `GSYM_PREFIX' in `config.m4' may be incorrectly
     determined when using the native `grep', leading at link-time to
     undefined symbols like `___gmpn_add_n'.  To fix this, after running
     `./configure', change the relevant line in `config.m4' to
     `define(<GSYM_PREFIX>, <_>)'.

     The `ranlib' command will need to be run manually when building a
     static library with the native `ar'.  After `make', run `ranlib
     .libs/libgmp.a', and when using `--enable-mpbsd' run `ranlib
     .libs/libmp.a' too.

VAX running Ultrix
     You need to build and install the GNU assembler before you compile
     GMP.  The VAX assembly in GMP uses an instruction (`jsobgtr') that
     cannot be assembled by the Ultrix assembler.


File: gmp.info,  Node: GMP Basics,  Next: Reporting Bugs,  Prev: Installing GMP,  Up: Top

GMP Basics
**********

   All declarations needed to use GMP are collected in the include file
`gmp.h'.  It is designed to work with both C and C++ compilers.

   *Using functions, macros, data types, etc. not documented in this
manual is strongly discouraged.  If you do so your application is
guaranteed to be incompatible with future versions of GMP.*

* Menu:

* Nomenclature and Types::      	Which data types are there?
* Function Classes::            	How the functions are organized.
* GMP Variable Conventions::     	Some rules and hints about variables.
* GMP and Reentrancy::           	What about reentrancy?
* Useful Macros and Constants::  	Convenient helpers.
* Compatibility with older versions::	Compatibility issues.
* Getting the Latest Version of GMP::  	How to get the software.


File: gmp.info,  Node: Nomenclature and Types,  Next: Function Classes,  Prev: GMP Basics,  Up: GMP Basics

Nomenclature and Types
======================

In this manual, "integer" usually means a multiple precision integer, as
defined by the GMP library.  The C data type for such integers is
`mpz_t'.  Here are some examples of how to declare such integers:

     mpz_t sum;
     
     struct foo { mpz_t x, y; };
     
     mpz_t vec[20];

"Rational number" means a multiple precision fraction.  The C data type
for these fractions is `mpq_t'.  For example:

     mpq_t quotient;

"Floating point number" or "Float" for short, is an arbitrary precision
mantissa with a limited precision exponent.  The C data type for such
objects is `mpf_t'.

A "limb" means the part of a multi-precision number that fits in a
single word.  (We chose this word because a limb of the human body is
analogous to a digit, only larger, and containing several digits.)
Normally a limb contains 32 or 64 bits.  The C data type for a limb is
`mp_limb_t'.


File: gmp.info,  Node: Function Classes,  Next: GMP Variable Conventions,  Prev: Nomenclature and Types,  Up: GMP Basics

Function Classes
================

   There are six classes of functions in the GMP library:

  1. Functions for signed integer arithmetic, with names beginning with
     `mpz_'.  The associated type is `mpz_t'.  There are about 100
     functions in this class.

  2. Functions for rational number arithmetic, with names beginning with
     `mpq_'.  The associated type is `mpq_t'.  There are about 20
     functions in this class, but the functions in the previous class
     can be used for performing arithmetic on the numerator and
     denominator separately.

  3. Functions for floating-point arithmetic, with names beginning with
     `mpf_'.  The associated type is `mpf_t'.  There are about 50
     functions is this class.

  4. Functions compatible with Berkeley GMP, such as `itom', `madd', and
     `mult'.  The associated type is `MINT'.

  5. Fast low-level functions that operate on natural numbers.  These
     are used by the functions in the preceding groups, and you can
     also call them directly from very time-critical user programs.
     These functions' names begin with `mpn_'.  There are about 30
     (hard-to-use) functions in this class.

     The associated type is array of `mp_limb_t'.

  6. Miscellaneous functions.  Functions for setting up custom
     allocation and functions for generating random numbers.


File: gmp.info,  Node: GMP Variable Conventions,  Next: GMP and Reentrancy,  Prev: Function Classes,  Up: GMP Basics

GMP Variable Conventions
========================

   As a general rule, all GMP functions expect output arguments before
input arguments.  This notation is based on an analogy with the
assignment operator.  (The BSD MP compatibility functions disobey this
rule, having the output argument(s) last.)

   GMP lets you use the same variable for both input and output in one
call.  For example, the main function for integer multiplication,
`mpz_mul', can be used to square `x' and put the result back in `x' with

     mpz_mul (x, x, x);

   Before you can assign to a GMP variable, you need to initialize it
by calling one of the special initialization functions.  When you're
done with a variable, you need to clear it out, using one of the
functions for that purpose.  Which function to use depends on the type
of variable.  See the chapters on integer functions, rational number
functions, and floating-point functions for details.

   A variable should only be initialized once, or at least cleared out
between each initialization.  After a variable has been initialized, it
may be assigned to any number of times.

   For efficiency reasons, avoid initializing and clearing out a GMP
variable in a loop.  Instead, initialize it before entering the loop,
and clear it out after the loop has exited.

   GMP variables are small, containing only a couple of sizes, and
pointers to allocated data.  Once you have initialized a GMP variable,
you don't need to worry about space allocation.  All functions in GMP
automatically allocate additional space when a variable does not
already have enough.  They do not, however, reduce the space when a
smaller value is stored.  Most of the time this policy is best, since
it avoids frequent re-allocation.

   When a variable of type `mpz_t' is used as a function parameter, it's
effectively a call-by-reference, meaning anything the function does to
it will be be done to the original in the caller.  When a function is
going to return an `mpz_t' result, it should provide a separate
parameter or parameters that it sets, like the GMP library functions
do.  A `return' of an `mpz_t' doesn't return the object, only a pointer
to it, and this is almost certainly not what you want.  All this
applies to `mpq_t' and `mpf_t' too.

   Here's an example function accepting an `mpz_t' parameter, doing a
certain calculation, and returning a result.

     void
     myfunction (mpz_t result, mpz_t param, unsigned long n)
     {
       unsigned long  i;
     
       mpz_mul_ui (result, param, n);
       for (i = 1; i < n; i++)
         mpz_add_ui (result, result, i*7);
     }
     
     int
     main (void)
     {
       mpz_t  r, n;
       mpz_init (r);
       mpz_init_set_str (n, "123456", 0);
     
       myfunction (r, n, 20L);
       mpz_out_str (stdout, 10, r); printf ("\n");
     
       return 0;
     }

   This example will work if `result' and `param' are the same
variable, just like the library functions.  But sometimes this is
tricky to arrange, and an application might not want to bother for its
own subroutines.

   `mpz_t' is actually implemented as a one-element array of a certain
structure type.  This is why using it to declare a variable gives an
object with the fields GMP needs, but then using it as a parameter
passes a pointer to the object.  Note that the actual contents of an
`mpz_t' are for internal use only and you should not access them
directly if you want your code to be compatible with future GMP
releases.


File: gmp.info,  Node: GMP and Reentrancy,  Next: Useful Macros and Constants,  Prev: GMP Variable Conventions,  Up: GMP Basics

GMP and Reentrancy
==================

   The GMP code is reentrant and thread-safe, with some exceptions:

   * The function `mpf_set_default_prec' saves the selected precision in
     a global variable.

   * The function `mp_set_memory_functions' uses several global
     variables for storing the selected memory allocation functions.

   * If the memory allocation functions set by a call to
     `mp_set_memory_functions' (or `malloc' and friends by default) are
     not reentrant, GMP will not be reentrant either.

   * The old random number functions (`mpz_random', etc) use a random
     number generator from the C library, usually `mrand48' or
     `random'.  These routines are not reentrant, since they rely on
     global state.  (However the newer random number functions that
     accept a `gmp_randstate_t' parameter are reentrant.)


File: gmp.info,  Node: Useful Macros and Constants,  Next: Compatibility with older versions,  Prev: GMP and Reentrancy,  Up: GMP Basics

Useful Macros and Constants
===========================

 - Global Constant: const int mp_bits_per_limb
     The number of bits per limb.

 - Macro: __GNU_MP_VERSION
 - Macro: __GNU_MP_VERSION_MINOR
 - Macro: __GNU_MP_VERSION_PATCHLEVEL
     The major and minor GMP version, and patch level, respectively, as
     integers.  For GMP i.j, these numbers will be i, j, and 0,
     respectively.  For GMP i.j.k, these numbers will be i, j, and k,
     respectively.


File: gmp.info,  Node: Compatibility with older versions,  Next: Getting the Latest Version of GMP,  Prev: Useful Macros and Constants,  Up: GMP Basics

Compatibility with older versions
=================================

   This version of GMP is upwardly binary compatible with versions 3.0
and 3.0.1, and upwardly compatible at the source level with versions
2.0, 2.0.1, and 2.0.2, with the following exceptions.

   * `mpn_gcd' had its source arguments swapped as of GMP 3.0 for
     consistency with other `mpn' functions.

   * `mpf_get_prec' counted precision slightly differently in GMP 3.0
     and 3.0.1, but in 3.1 has reverted to the 2.0.x style.


   There are a number of compatibility issues between GMP 1 and GMP 2
that of course also apply when porting applications from GMP 1 to GMP
3.  Please see the GMP 2 manual for details.


File: gmp.info,  Node: Getting the Latest Version of GMP,  Prev: Compatibility with older versions,  Up: GMP Basics

Getting the Latest Version of GMP
=================================

   The latest version of the GMP library is available at
`ftp://ftp.gnu.org/pub/gnu/gmp'.  Many sites around the world mirror
`ftp.gnu.org'; please use a mirror site near you, see
`http://www.gnu.org/order/ftp.html'.


File: gmp.info,  Node: Reporting Bugs,  Next: Integer Functions,  Prev: GMP Basics,  Up: Top

Reporting Bugs
**************

   If you think you have found a bug in the GMP library, please
investigate it and report it.  We have made this library available to
you, and it is not too much to ask you to report the bugs you find.
Before you report a bug, you may want to check
`http://www.swox.com/gmp/' for patches for this release.

   Please include the following in any report,

   * The GMP version number, and if pre-packaged or patched then say so.

   * A test program that makes it possible for us to reproduce the bug.
     Include instructions on how to run the program.

   * A description of what is wrong.  If the results are incorrect, in
     what way.  If you get a crash, say so.

   * If you get a crash, include a stack backtrace from the debugger if
     it's informative (`where' in `gdb', or `$C' in `adb').

   * *Please do not send core dumps, executables or `strace's.*

   * The configuration options you used when building GMP, if any.

   * The name of the compiler and its version.  For `gcc', get the
     version with `gcc -v', otherwise perhaps `what `which cc`', or
     similar.

   * The output from running `uname -a'.

   * The output from running `./config.guess'.

   * If the bug is related to `configure', then the contents of
     `config.log'.

   * If the bug is related to an `asm' file not assembling, then the
     contents of `config.m4'.

   It is not uncommon that an observed problem is actually due to a bug
in the compiler; the GMP code tends to explore interesting corners in
compilers.

   If your bug report is good, we will do our best to help you get a
corrected version of the library; if the bug report is poor, we won't
do anything about it (except maybe ask you to send a better report).

   Send your report to: <bug-gmp@gnu.org>.

   If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please send a note
to the same address.


File: gmp.info,  Node: Integer Functions,  Next: Rational Number Functions,  Prev: Reporting Bugs,  Up: Top

Integer Functions
*****************

   This chapter describes the GMP functions for performing integer
arithmetic.  These functions start with the prefix `mpz_'.

   GMP integers are stored in objects of type `mpz_t'.

* Menu:

* Initializing Integers::
* Assigning Integers::
* Simultaneous Integer Init & Assign::
* Converting Integers::
* Integer Arithmetic::
* Integer Division::
* Integer Exponentiation::
* Integer Roots::
* Number Theoretic Functions::
* Integer Comparisons::
* Integer Logic and Bit Fiddling::
* I/O of Integers::
* Integer Random Numbers::
* Miscellaneous Integer Functions::


File: gmp.info,  Node: Initializing Integers,  Next: Assigning Integers,  Prev: Integer Functions,  Up: Integer Functions

Initialization Functions
========================

   The functions for integer arithmetic assume that all integer objects
are initialized.  You do that by calling the function `mpz_init'.

 - Function: void mpz_init (mpz_t INTEGER)
     Initialize INTEGER with limb space and set the initial numeric
     value to 0.  Each variable should normally only be initialized
     once, or at least cleared out (using `mpz_clear') between each
     initialization.

   Here is an example of using `mpz_init':

     {
       mpz_t integ;
       mpz_init (integ);
       ...
       mpz_add (integ, ...);
       ...
       mpz_sub (integ, ...);
     
       /* Unless the program is about to exit, do ... */
       mpz_clear (integ);
     }

As you can see, you can store new values any number of times, once an
object is initialized.

 - Function: void mpz_clear (mpz_t INTEGER)
     Free the limb space occupied by INTEGER.  Make sure to call this
     function for all `mpz_t' variables when you are done with them.

 - Function: void * _mpz_realloc (mpz_t INTEGER, mp_size_t NEW_ALLOC)
     Change the limb space allocation to NEW_ALLOC limbs.  This
     function is not normally called from user code, but it can be used
     to give memory back to the heap, or to increase the space of a
     variable to avoid repeated automatic re-allocation.

 - Function: void mpz_array_init (mpz_t INTEGER_ARRAY[], size_t
          ARRAY_SIZE, mp_size_t FIXED_NUM_BITS)
     Allocate *fixed* limb space for all ARRAY_SIZE integers in
     INTEGER_ARRAY.  The fixed allocation for each integer in the array
     is enough to store FIXED_NUM_BITS.  If the fixed space will be
     insufficient for storing the result of a subsequent calculation,
     the result is unpredictable.

     This function is useful for decreasing the working set for some
     algorithms that use large integer arrays.

     There is no way to de-allocate the storage allocated by this
     function.  Don't call `mpz_clear'!


File: gmp.info,  Node: Assigning Integers,  Next: Simultaneous Integer Init & Assign,  Prev: Initializing Integers,  Up: Integer Functions

Assignment Functions
====================

   These functions assign new values to already initialized integers
(*note Initializing Integers::).

 - Function: void mpz_set (mpz_t ROP, mpz_t OP)
 - Function: void mpz_set_ui (mpz_t ROP, unsigned long int OP)
 - Function: void mpz_set_si (mpz_t ROP, signed long int OP)
 - Function: void mpz_set_d (mpz_t ROP, double OP)
 - Function: void mpz_set_q (mpz_t ROP, mpq_t OP)
 - Function: void mpz_set_f (mpz_t ROP, mpf_t OP)
     Set the value of ROP from OP.

 - Function: int mpz_set_str (mpz_t ROP, char *STR, int BASE)
     Set the value of ROP from STR, a '\0'-terminated C string in base
     BASE.  White space is allowed in the string, and is simply
     ignored.  The base may vary from 2 to 36.  If BASE is 0, the
     actual base is determined from the leading characters: if the
     first two characters are `0x' or `0X', hexadecimal is assumed,
     otherwise if the first character is `0', octal is assumed,
     otherwise decimal is assumed.

     This function returns 0 if the entire string up to the '\0' is a
     valid number in base BASE.  Otherwise it returns -1.

     [It turns out that it is not entirely true that this function
     ignores white-space.  It does ignore it between digits, but not
     after a minus sign or within or after "0x".  We are considering
     changing the definition of this function, making it fail when
     there is any white-space in the input, since that makes a lot of
     sense.  Please tell us your opinion about this change.  Do you
     really want it to accept "3 14" as meaning 314 as it does now?]

 - Function: void mpz_swap (mpz_t ROP1, mpz_t ROP2)
     Swap the values ROP1 and ROP2 efficiently.


File: gmp.info,  Node: Simultaneous Integer Init & Assign,  Next: Converting Integers,  Prev: Assigning Integers,  Up: Integer Functions

Combined Initialization and Assignment Functions
================================================

   For convenience, GMP provides a parallel series of
initialize-and-set functions which initialize the output and then store
the value there.  These functions' names have the form `mpz_init_set...'

   Here is an example of using one:

     {
       mpz_t pie;
       mpz_init_set_str (pie, "3141592653589793238462643383279502884", 10);
       ...
       mpz_sub (pie, ...);
       ...
       mpz_clear (pie);
     }

Once the integer has been initialized by any of the `mpz_init_set...'
functions, it can be used as the source or destination operand for the
ordinary integer functions.  Don't use an initialize-and-set function
on a variable already initialized!

 - Function: void mpz_init_set (mpz_t ROP, mpz_t OP)
 - Function: void mpz_init_set_ui (mpz_t ROP, unsigned long int OP)
 - Function: void mpz_init_set_si (mpz_t ROP, signed long int OP)
 - Function: void mpz_init_set_d (mpz_t ROP, double OP)
     Initialize ROP with limb space and set the initial numeric value
     from OP.

 - Function: int mpz_init_set_str (mpz_t ROP, char *STR, int BASE)
     Initialize ROP and set its value like `mpz_set_str' (see its
     documentation above for details).

     If the string is a correct base BASE number, the function returns
     0; if an error occurs it returns -1.  ROP is initialized even if
     an error occurs.  (I.e., you have to call `mpz_clear' for it.)


File: gmp.info,  Node: Converting Integers,  Next: Integer Arithmetic,  Prev: Simultaneous Integer Init & Assign,  Up: Integer Functions

Conversion Functions
====================

   This section describes functions for converting GMP integers to
standard C types.  Functions for converting _to_ GMP integers are
described in *Note Assigning Integers:: and *Note I/O of Integers::.

 - Function: mp_limb_t mpz_getlimbn (mpz_t OP, mp_size_t N)
     Return limb #N from OP.  This function allows for very efficient
     decomposition of a number in its limbs.

     The function `mpz_size' can be used to determine the useful range
     for N.

 - Function: unsigned long int mpz_get_ui (mpz_t OP)
     Return the least significant part from OP.  This function combined
     with
     `mpz_tdiv_q_2exp(..., OP, CHAR_BIT*sizeof(unsigned long int))' can
     be used to decompose an integer into unsigned longs.

 - Function: signed long int mpz_get_si (mpz_t OP)
     If OP fits into a `signed long int' return the value of OP.
     Otherwise return the least significant part of OP, with the same
     sign as OP.

     If OP is too large to fit in a `signed long int', the returned
     result is probably not very useful.  To find out if the value will
     fit, use the function `mpz_fits_slong_p'.

 - Function: double mpz_get_d (mpz_t OP)
     Convert OP to a double.

 - Function: char * mpz_get_str (char *STR, int BASE, mpz_t OP)
     Convert OP to a string of digits in base BASE.  The base may vary
     from 2 to 36.

     If STR is `NULL', space for the result string is allocated using
     the default allocation function.

     If STR is not `NULL', it should point to a block of storage enough
     large for the result.  To find out the right amount of space to
     provide for STR, use `mpz_sizeinbase (OP, BASE) + 2'.  The two
     extra bytes are for a possible minus sign, and for the terminating
     null character.

     A pointer to the result string is returned.  This pointer will
     will either equal STR, or if that is `NULL', will point to the
     allocated storage.


File: gmp.info,  Node: Integer Arithmetic,  Next: Integer Division,  Prev: Converting Integers,  Up: Integer Functions

Arithmetic Functions
====================

 - Function: void mpz_add (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 - Function: void mpz_add_ui (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 + OP2.

 - Function: void mpz_sub (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 - Function: void mpz_sub_ui (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 - OP2.

 - Function: void mpz_mul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 - Function: void mpz_mul_si (mpz_t ROP, mpz_t OP1, long int OP2)
 - Function: void mpz_mul_ui (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 times OP2.

 - Function: void mpz_addmul_ui (mpz_t ROP, mpz_t OP1, unsigned long
          int OP2)
     Add OP1 times OP2 to ROP.

 - Function: void mpz_mul_2exp (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 times 2 raised to OP2.  This operation can also be
     defined as a left shift, OP2 steps.

 - Function: void mpz_neg (mpz_t ROP, mpz_t OP)
     Set ROP to -OP.

 - Function: void mpz_abs (mpz_t ROP, mpz_t OP)
     Set ROP to the absolute value of OP.


File: gmp.info,  Node: Integer Division,  Next: Integer Exponentiation,  Prev: Integer Arithmetic,  Up: Integer Functions

Division Functions
==================

   Division is undefined if the divisor is zero, and passing a zero
divisor to the divide or modulo functions, as well passing a zero mod
argument to the `mpz_powm' and `mpz_powm_ui' functions, will make these
functions intentionally divide by zero.  This lets the user handle
arithmetic exceptions in these functions in the same manner as other
arithmetic exceptions.

   There are three main groups of division functions:
   * Functions that truncate the quotient towards 0.  The names of
     these functions start with `mpz_tdiv'.  The `t' in the name is
     short for `truncate'.

   * Functions that round the quotient towards -infinity).  The names
     of these routines start with `mpz_fdiv'.  The `f' in the name is
     short for `floor'.

   * Functions that round the quotient towards +infinity.  The names of
     these routines start with `mpz_cdiv'.  The `c' in the name is
     short for `ceil'.

   For each rounding mode, there are a couple of variants.  Here `q'
means that the quotient is computed, while `r' means that the remainder
is computed.  Functions that compute both the quotient and remainder
have `qr' in the name.

 - Function: void mpz_tdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_tdiv_q_ui (mpz_t Q, mpz_t N,
          unsigned long int D)
     Set Q to [N/D], truncated towards 0.

     The function `mpz_tdiv_q_ui' returns the absolute value of the true
     remainder.

 - Function: void mpz_tdiv_r (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_tdiv_r_ui (mpz_t R, mpz_t N,
          unsigned long int D)
     Set R to (N - [N/D] * D), where the quotient is truncated towards
     0.  Unless R becomes zero, it will get the same sign as N.

     The function `mpz_tdiv_r_ui' returns the absolute value of the
     remainder.

 - Function: void mpz_tdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_tdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t
          N, unsigned long int D)
     Set Q to [N/D], truncated towards 0.  Set R to (N - [N/D] * D).
     Unless R becomes zero, it will get the same sign as N.  If Q and R
     are the same variable, the results are undefined.

     The function `mpz_tdiv_qr_ui' returns the absolute value of the
     remainder.

 - Function: unsigned long int mpz_tdiv_ui (mpz_t N, unsigned long int
          D)
     Like `mpz_tdiv_r_ui', but the remainder is not stored anywhere; its
     absolute value is just returned.

 - Function: void mpz_fdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_fdiv_q_ui (mpz_t Q, mpz_t N,
          unsigned long int D)
     Set Q to N/D, rounded towards -infinity.

     The function `mpz_fdiv_q_ui' returns the remainder.

 - Function: void mpz_fdiv_r (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_fdiv_r_ui (mpz_t R, mpz_t N,
          unsigned long int D)
     Set R to (N - N/D * D), where the quotient is rounded towards
     -infinity.  Unless R becomes zero, it will get the same sign as D.

     The function `mpz_fdiv_r_ui' returns the remainder.

 - Function: void mpz_fdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_fdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t
          N, unsigned long int D)
     Set Q to N/D, rounded towards -infinity.  Set R to (N - N/D * D).
     Unless R becomes zero, it will get the same sign as D.  If Q and R
     are the same variable, the results are undefined.

     The function `mpz_fdiv_qr_ui' returns the remainder.

 - Function: unsigned long int mpz_fdiv_ui (mpz_t N, unsigned long int
          D)
     Like `mpz_fdiv_r_ui', but the remainder is not stored anywhere; it
     is just returned.

 - Function: void mpz_cdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_cdiv_q_ui (mpz_t Q, mpz_t N,
          unsigned long int D)
     Set Q to N/D, rounded towards +infinity.

     The function `mpz_cdiv_q_ui' returns the negated remainder.

 - Function: void mpz_cdiv_r (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_cdiv_r_ui (mpz_t R, mpz_t N,
          unsigned long int D)
     Set R to (N - N/D * D), where the quotient is rounded towards
     +infinity.  Unless R becomes zero, it will get the opposite sign
     as D.

     The function `mpz_cdiv_r_ui' returns the negated remainder.

 - Function: void mpz_cdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_cdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t
          N, unsigned long int D)
     Set Q to N/D, rounded towards +infinity.  Set R to (N - N/D * D).
     Unless R becomes zero, it will get the opposite sign as D.  If Q
     and R are the same variable, the results are undefined.

     The function `mpz_cdiv_qr_ui' returns the negated remainder.

 - Function: unsigned long int mpz_cdiv_ui (mpz_t N, unsigned long int
          D)
     Like `mpz_tdiv_r_ui', but the remainder is not stored anywhere; its
     negated value is just returned.

 - Function: void mpz_mod (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_mod_ui (mpz_t R, mpz_t N, unsigned
          long int D)
     Set R to N `mod' D.  The sign of the divisor is ignored; the
     result is always non-negative.

     The function `mpz_mod_ui' returns the remainder.

 - Function: void mpz_divexact (mpz_t Q, mpz_t N, mpz_t D)
     Set Q to N/D.  This function produces correct results only when it
     is known in advance that D divides N.

     Since mpz_divexact is much faster than any of the other routines
     that produce the quotient (*note References:: Jebelean), it is the
     best choice for instances in which exact division is known to
     occur, such as reducing a rational to lowest terms.

 - Function: void mpz_tdiv_q_2exp (mpz_t Q, mpz_t N, unsigned long int
          D)
     Set Q to N divided by 2 raised to D.  The quotient is truncated
     towards 0.

 - Function: void mpz_tdiv_r_2exp (mpz_t R, mpz_t N, unsigned long int
          D)
     Divide N by (2 raised to D), rounding the quotient towards 0, and
     put the remainder in R.  Unless it is zero, R will have the same
     sign as N.

 - Function: void mpz_fdiv_q_2exp (mpz_t Q, mpz_t N, unsigned long int
          D)
     Set Q to N divided by 2 raised to D, rounded towards -infinity.
     This operation can also be defined as arithmetic right shift D bit
     positions.

 - Function: void mpz_fdiv_r_2exp (mpz_t R, mpz_t N, unsigned long int
          D)
     Divide N by (2 raised to D), rounding the quotient towards
     -infinity, and put the remainder in R.  The sign of R will always
     be positive.  This operation can also be defined as masking of the
     D least significant bits.

