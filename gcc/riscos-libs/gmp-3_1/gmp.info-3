This is gmp.info, produced by makeinfo version 4.0 from gmp.texi.

INFO-DIR-SECTION GNU libraries
START-INFO-DIR-ENTRY
* gmp: (gmp).                   GNU Multiple Precision Arithmetic Library.
END-INFO-DIR-ENTRY

   This file documents GNU MP, a library for arbitrary-precision
arithmetic.

   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gmp.info,  Node: Low-level Functions,  Next: Random Number Functions,  Prev: Floating-point Functions,  Up: Top

Low-level Functions
*******************

   This chapter describes low-level GMP functions, used to implement
the high-level GMP functions, but also intended for time-critical user
code.

   These functions start with the prefix `mpn_'.

   The `mpn' functions are designed to be as fast as possible, *not* to
provide a coherent calling interface.  The different functions have
somewhat similar interfaces, but there are variations that make them
hard to use.  These functions do as little as possible apart from the
real multiple precision computation, so that no time is spent on things
that not all callers need.

   A source operand is specified by a pointer to the least significant
limb and a limb count.  A destination operand is specified by just a
pointer.  It is the responsibility of the caller to ensure that the
destination has enough space for storing the result.

   With this way of specifying operands, it is possible to perform
computations on subranges of an argument, and store the result into a
subrange of a destination.

   A common requirement for all functions is that each source area
needs at least one limb.  No size argument may be zero.  Unless
otherwise stated, in-place operations are allowed where source and
destination are the same, but not where they only partly overlap.

   The `mpn' functions are the base for the implementation of the
`mpz_', `mpf_', and `mpq_' functions.

   This example adds the number beginning at S1P and the number
beginning at S2P and writes the sum at DESTP.  All areas have SIZE
limbs.

     cy = mpn_add_n (destp, s1p, s2p, size)

In the notation used here, a source operand is identified by the
pointer to the least significant limb, and the limb count in braces.
For example, {s1p, s1size}.

 - Function: mp_limb_t mpn_add_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t SIZE)
     Add {S1P, SIZE} and {S2P, SIZE}, and write the SIZE least
     significant limbs of the result to RP.  Return carry, either 0 or
     1.

     This is the lowest-level function for addition.  It is the
     preferred function for addition, since it is written in assembly
     for most targets.  For addition of a variable to itself (i.e., S1P
     equals S2P, use `mpn_lshift' with a count of 1 for optimal speed.

 - Function: mp_limb_t mpn_add_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t SIZE, mp_limb_t S2LIMB)
     Add {S1P, SIZE} and S2LIMB, and write the SIZE least significant
     limbs of the result to RP.  Return carry, either 0 or 1.

 - Function: mp_limb_t mpn_add (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE)
     Add {S1P, S1SIZE} and {S2P, S2SIZE}, and write the S1SIZE least
     significant limbs of the result to RP.  Return carry, either 0 or
     1.

     This function requires that S1SIZE is greater than or equal to
     S2SIZE.

 - Function: mp_limb_t mpn_sub_n (mp_limb_t *RP, const mp_limb_t *S1P,
          const mp_limb_t *S2P, mp_size_t SIZE)
     Subtract {S2P, S2SIZE} from {S1P, SIZE}, and write the SIZE least
     significant limbs of the result to RP.  Return borrow, either 0 or
     1.

     This is the lowest-level function for subtraction.  It is the
     preferred function for subtraction, since it is written in
     assembly for most targets.

 - Function: mp_limb_t mpn_sub_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t SIZE, mp_limb_t S2LIMB)
     Subtract S2LIMB from {S1P, SIZE}, and write the SIZE least
     significant limbs of the result to RP.  Return borrow, either 0 or
     1.

 - Function: mp_limb_t mpn_sub (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE)
     Subtract {S2P, S2SIZE} from {S1P, S1SIZE}, and write the S1SIZE
     least significant limbs of the result to RP.  Return borrow,
     either 0 or 1.

     This function requires that S1SIZE is greater than or equal to
     S2SIZE.

 - Function: void mpn_mul_n (mp_limb_t *RP, const mp_limb_t *S1P, const
          mp_limb_t *S2P, mp_size_t SIZE)
     Multiply {S1P, SIZE} and {S2P, SIZE}, and write the *entire*
     result to RP.

     The destination has to have space for 2*SIZE limbs, even if the
     significant result might be one limb smaller.

 - Function: mp_limb_t mpn_mul_1 (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t SIZE, mp_limb_t S2LIMB)
     Multiply {S1P, SIZE} and S2LIMB, and write the SIZE least
     significant limbs of the product to RP.  Return the most
     significant limb of the product.

     This is a low-level function that is a building block for general
     multiplication as well as other operations in GMP.  It is written
     in assembly for most targets.

     Don't call this function if S2LIMB is a power of 2; use
     `mpn_lshift' with a count equal to the logarithm of S2LIMB
     instead, for optimal speed.

 - Function: mp_limb_t mpn_addmul_1 (mp_limb_t *RP, const mp_limb_t
          *S1P, mp_size_t SIZE, mp_limb_t S2LIMB)
     Multiply {S1P, SIZE} and S2LIMB, and add the SIZE least
     significant limbs of the product to {RP, SIZE} and write the
     result to RP.  Return the most significant limb of the product,
     plus carry-out from the addition.

     This is a low-level function that is a building block for general
     multiplication as well as other operations in GMP.  It is written
     in assembly for most targets.

 - Function: mp_limb_t mpn_submul_1 (mp_limb_t *RP, const mp_limb_t
          *S1P, mp_size_t SIZE, mp_limb_t S2LIMB)
     Multiply {S1P, SIZE} and S2LIMB, and subtract the SIZE least
     significant limbs of the product from {RP, SIZE} and write the
     result to RP.  Return the most significant limb of the product,
     minus borrow-out from the subtraction.

     This is a low-level function that is a building block for general
     multiplication and division as well as other operations in GMP.
     It is written in assembly for most targets.

 - Function: mp_limb_t mpn_mul (mp_limb_t *RP, const mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE)
     Multiply {S1P, S1SIZE} and {S2P, S2SIZE}, and write the result to
     RP.  Return the most significant limb of the result.

     The destination has to have space for S1SIZE + S2SIZE limbs, even
     if the result might be one limb smaller.

     This function requires that S1SIZE is greater than or equal to
     S2SIZE.  The destination must be distinct from either input
     operands.

 - Function: mp_limb_t mpn_tdiv_qr (mp_limb_t *QP, mp_limb_t *RP,
          mp_size_t QXN, const mp_limb_t *NP, mp_size_t NN, const
          mp_limb_t *DP, mp_size_t DN)
     Divide {NP, NN} by {DP, DN}.  Write the quotient at QP and the
     remainder at RP.

     The quotient written at QP will be NN - DN + 1 limbs.  The
     remainder written at RP will be DN limbs.

     It is required that NN is greater than or equal to DN.  The QXN
     operand must be zero.

     The quotient is rounded towards 0.

     No overlap between arguments is permitted.

 - Function: mp_limb_t mpn_divrem (mp_limb_t *R1P, mp_size_t XSIZE,
          mp_limb_t *RS2P, mp_size_t RS2SIZE, const mp_limb_t *S3P,
          mp_size_t S3SIZE)
     [This function is obsolete.  Please call `mpn_tdiv_qr' instead for
     best performance.]

     Divide {RS2P, RS2SIZE} by {S3P, S3SIZE}, and write the quotient at
     R1P, with the exception of the most significant limb, which is
     returned.  The remainder replaces the dividend at RS2P; it will be
     S3SIZE limbs long (i.e., as many limbs as the divisor).

     In addition to an integer quotient, XSIZE fraction limbs are
     developed, and stored after the integral limbs.  For most usages,
     XSIZE will be zero.

     It is required that RS2SIZE is greater than or equal to S3SIZE.
     It is required that the most significant bit of the divisor is set.

     If the quotient is not needed, pass RS2P + S3SIZE as R1P.  Aside
     from that special case, no overlap between arguments is permitted.

     Return the most significant limb of the quotient, either 0 or 1.

     The area at R1P needs to be RS2SIZE - S3SIZE + XSIZE limbs large.

 - Function: mp_limb_t mpn_divrem_1 (mp_limb_t *R1P, mp_size_t XSIZE,
          mp_limb_t *S2P, mp_size_t S2SIZE, mp_limb_t S3LIMB)
 - Macro: mp_limb_t mpn_divmod_1 (mp_limb_t *R1P, mp_limb_t *S2P,
          mp_size_t S2SIZE, mp_limb_t S3LIMB)
     Divide {S2P, S2SIZE} by S3LIMB, and write the quotient at R1P.
     Return the remainder.

     The integer quotient is written to {R1P+XSIZE, S2SIZE} and in
     addition XSIZE fraction limbs are developed and written to {R1P,
     XSIZE}.  Either or both S2SIZE and XSIZE can be zero.  For most
     usages, XSIZE will be zero.

     `mpn_divmod_1' exists for upward source compatibility and is
     simply a macro calling `mpn_divrem_1' with an XSIZE of 0.

     The areas at R1P and S2P have to be identical or completely
     separate, not partially overlapping.

 - Function: mp_limb_t mpn_divmod (mp_limb_t *R1P, mp_limb_t *RS2P,
          mp_size_t RS2SIZE, const mp_limb_t *S3P, mp_size_t S3SIZE)
     *This interface is obsolete.  It will disappear from future
     releases.  Use `mpn_divrem' in its stead.*

 - Macro: mp_limb_t mpn_divexact_by3 (mp_limb_t *RP, mp_limb_t *SP,
          mp_size_t SIZE)
 - Function: mp_limb_t mpn_divexact_by3c (mp_limb_t *RP, mp_limb_t *SP,
          mp_size_t SIZE, mp_limb_t CARRY)
     Divide {SP, SIZE} by 3, expecting it to divide exactly, and
     writing the result to {RP, SIZE}.  If 3 divides exactly, the
     return value is zero and the result is the quotient.  If not, the
     return value is non-zero and the result won't be anything useful.

     `mpn_divexact_by3c' takes an initial carry parameter, which can be
     the return value from a previous call, so a large calculation can
     be done piece by piece.  `mpn_divexact_by3' is simply a macro
     calling `mpn_divexact_by3c' with a 0 carry parameter.

     These routines use a multiply-by-inverse and will be faster than
     `mpn_divrem_1' on CPUs with fast multiplication but slow division.

     The source a, result q, size n, initial carry i, and return value
     c satisfy c*b^n + a-i = 3*q, where b is the size of a limb (2^32
     or 2^64).  c is always 0, 1 or 2, and the initial carry must also
     be 0, 1 or 2 (these are both borrows really).  When c=0, clearly
     q=(a-i)/3.  When c!=0, the remainder (a-i) mod 3 is given by 3-c,
     because b == 1 mod 3.

 - Function: mp_limb_t mpn_mod_1 (mp_limb_t *S1P, mp_size_t S1SIZE,
          mp_limb_t S2LIMB)
     Divide {S1P, S1SIZE} by S2LIMB, and return the remainder.  S1SIZE
     can be zero.

 - Function: mp_limb_t mpn_preinv_mod_1 (mp_limb_t *S1P, mp_size_t
          S1SIZE, mp_limb_t S2LIMB, mp_limb_t S3LIMB)
     *This interface is obsolete.  It will disappear from future
     releases.  Use `mpn_mod_1' in its stead.*

 - Function: mp_limb_t mpn_bdivmod (mp_limb_t *RP, mp_limb_t *S1P,
          mp_size_t S1SIZE, const mp_limb_t *S2P, mp_size_t S2SIZE,
          unsigned long int D)
     The function puts the low [D/BITS_PER_MP_LIMB] limbs of Q = {S1P,
     S1SIZE}/{S2P, S2SIZE} mod 2^D at RP, and returns the high D mod
     BITS_PER_MP_LIMB bits of Q.

     {S1P, S1SIZE} - Q * {S2P, S2SIZE} mod 2^(S1SIZE*BITS_PER_MP_LIMB)
     is placed at S1P.  Since the low [D/BITS_PER_MP_LIMB] limbs of
     this difference are zero, it is possible to overwrite the low
     limbs at S1P with this difference, provided RP <= S1P.

     This function requires that S1SIZE * BITS_PER_MP_LIMB >= D, and
     that {S2P, S2SIZE} is odd.

     *This interface is preliminary.  It might change incompatibly in
     future revisions.*

 - Function: mp_limb_t mpn_lshift (mp_limb_t *RP, const mp_limb_t
          *SRC_PTR, mp_size_t SRC_SIZE, unsigned long int COUNT)
     Shift {SRC_PTR, SRC_SIZE} COUNT bits to the left, and write the
     SRC_SIZE least significant limbs of the result to RP.  COUNT might
     be in the range 1 to n - 1, on an n-bit machine. The bits shifted
     out to the left are returned.

     Overlapping of the destination space and the source space is
     allowed in this function, provided RP >= SRC_PTR.

     This function is written in assembly for most targets.

 - Function: mp_limp_t mpn_rshift (mp_limb_t *RP, const mp_limb_t
          *SRC_PTR, mp_size_t SRC_SIZE, unsigned long int COUNT)
     Shift {SRC_PTR, SRC_SIZE} COUNT bits to the right, and write the
     SRC_SIZE most significant limbs of the result to RP.  COUNT might
     be in the range 1 to n - 1, on an n-bit machine.  The bits shifted
     out to the right are returned.

     Overlapping of the destination space and the source space is
     allowed in this function, provided RP <= SRC_PTR.

     This function is written in assembly for most targets.

 - Function: int mpn_cmp (const mp_limb_t *S1P, const mp_limb_t *S2P,
          mp_size_t SIZE)
     Compare {S1P, SIZE} and {S2P, SIZE} and return a positive value if
     s1 > src2, 0 of they are equal, and a negative value if s1 < src2.

 - Function: mp_size_t mpn_gcd (mp_limb_t *RP, mp_limb_t *S1P,
          mp_size_t S1SIZE, mp_limb_t *S2P, mp_size_t S2SIZE)
     Puts at RP the greatest common divisor of {S1P, S1SIZE} and {S2P,
     S2SIZE}; both source operands are destroyed by the operation.  The
     size in limbs of the greatest common divisor is returned.

     {S1P, S1SIZE} must have at least as many bits as {S2P, S2SIZE},
     and {S2P, S2SIZE} must be odd.

 - Function: mp_limb_t mpn_gcd_1 (const mp_limb_t *S1P, mp_size_t
          S1SIZE, mp_limb_t S2LIMB)
     Return the greatest common divisor of {S1P, S1SIZE} and S2LIMB,
     where S2LIMB (as well as S1SIZE) must be different from 0.

 - Function: mp_size_t mpn_gcdext (mp_limb_t *R1P, mp_limb_t *R2P,
          mp_size_t *R2SIZE, mp_limb_t *S1P, mp_size_t S1SIZE,
          mp_limb_t *S2P, mp_size_t S2SIZE)
     Compute the greatest common divisor of {S1P, S1SIZE} and {S2P,
     S2SIZE}.  Store the gcd at R1P and return its size in limbs.
     Write the first cofactor at R2P and store its size in *R2SIZE.  If
     the cofactor is negative, *R2SIZE is negative and R2P is the
     absolute value of the cofactor.

     {S1P, S1SIZE} must be greater than or equal to {S2P, S2SIZE}.
     Neither operand may equal 0.  Both source operands are destroyed,
     plus one limb past the end of each, ie. {S1P, S1SIZE+1} and {S2P,
     S2SIZE+1}.

 - Function: mp_size_t mpn_sqrtrem (mp_limb_t *R1P, mp_limb_t *R2P,
          const mp_limb_t *SP, mp_size_t SIZE)
     Compute the square root of {SP, SIZE} and put the result at R1P.
     Write the remainder at R2P, unless R2P is `NULL'.

     Return the size of the remainder, whether R2P was `NULL' or
     non-`NULL'.  Iff the operand was a perfect square, the return
     value will be 0.

     The areas at R1P and SP have to be distinct.  The areas at R2P and
     SP have to be identical or completely separate, not partially
     overlapping.

     The area at R1P needs to have space for ceil(SIZE/2) limbs.  The
     area at R2P needs to be SIZE limbs large.

 - Function: mp_size_t mpn_get_str (unsigned char *STR, int BASE,
          mp_limb_t *S1P, mp_size_t S1SIZE)
     Convert {S1P, S1SIZE} to a raw unsigned char array in base BASE.
     The string is not in ASCII; to convert it to printable format, add
     the ASCII codes for `0' or `A', depending on the base and range.
     There may be leading zeros in the string.

     The area at S1P is clobbered.

     Return the number of characters in STR.

     The area at STR has to have space for the largest possible number
     represented by a S1SIZE long limb array, plus one extra character.

 - Function: mp_size_t mpn_set_str (mp_limb_t *R1P, const char *STR,
          size_t STRSIZE, int BASE)
     Convert the raw unsigned char array at STR of length STRSIZE to a
     limb array {S1P, S1SIZE}.  The base of STR is BASE.

     Return the number of limbs stored in R1P.

 - Function: unsigned long int mpn_scan0 (const mp_limb_t *S1P,
          unsigned long int BIT)
     Scan S1P from bit position BIT for the next clear bit.

     It is required that there be a clear bit within the area at S1P at
     or beyond bit position BIT, so that the function has something to
     return.

 - Function: unsigned long int mpn_scan1 (const mp_limb_t *S1P,
          unsigned long int BIT)
     Scan S1P from bit position BIT for the next set bit.

     It is required that there be a set bit within the area at S1P at or
     beyond bit position BIT, so that the function has something to
     return.

 - Function: void mpn_random (mp_limb_t *R1P, mp_size_t R1SIZE)
 - Function: void mpn_random2 (mp_limb_t *R1P, mp_size_t R1SIZE)
     Generate a random number of length R1SIZE and store it at R1P.
     The most significant limb is always non-zero.  `mpn_random'
     generates uniformly distributed limb data, `mpn_random2' generates
     long strings of zeros and ones in the binary representation.

     `mpn_random2' is intended for testing the correctness of the `mpn'
     routines.

 - Function: unsigned long int mpn_popcount (const mp_limb_t *S1P,
          unsigned long int SIZE)
     Count the number of set bits in {S1P, SIZE}.

 - Function: unsigned long int mpn_hamdist (const mp_limb_t *S1P, const
          mp_limb_t *S2P, unsigned long int SIZE)
     Compute the hamming distance between {S1P, SIZE} and {S2P, SIZE}.

 - Function: int mpn_perfect_square_p (const mp_limb_t *S1P, mp_size_t
          SIZE)
     Return non-zero iff {S1P, SIZE} is a perfect square.


File: gmp.info,  Node: Random Number Functions,  Next: BSD Compatible Functions,  Prev: Low-level Functions,  Up: Top

Random Number Functions
***********************

   There are two groups of random number functions in GNU MP; older
functions that call C library random number generators, rely on a global
state, and aren't very random; and newer functions that don't have these
problems.  The newer functions are self-contained, they accept a random
state parameter that supplants global state, and generate good random
numbers.

   The random state parameter is of the type `gmp_randstate_t'.  It
must be initialized by a call to one of the `gmp_randinit' functions
(*Note Random State Initialization::).  The initial seed is set using
one of the `gmp_randseed' functions (*Note Random State
Initialization::).

   The size of the seed determines the number of different sequences of
random numbers that is possible to generate.  The "quality" of the seed
is the randomness of a given seed compared to the previous seed used
and affects the randomness of separate number sequences.

   The algorithm for assigning seed is critical if the generated random
numbers are to be used for important applications, such as generating
cryptographic keys.

   The traditional method is to use the current system time for
seeding.  One has to be careful when using the current time though.  If
the application seeds the random functions very often, say several
times per second, and the resolution of the system clock is
comparatively low, like one second, the same sequence of numbers will
be generated until the system clock ticks.  Furthermore, the current
system time is quite easy to guess, so a system depending on any
unpredictability of the random number sequence should absolutely not
use that as its only source for a seed value.

   On some systems there is a special device, often called
`/dev/random', which provides a source of somewhat random numbers more
usable as seed.

   The functions actually generating random functions are documented
under "Miscellaneous Functions" in their respective function class:
*Note Miscellaneous Integer Functions::, *Note Miscellaneous Float
Functions::.

* Menu:

* Random State Initialization::  How to initialize a random state.


File: gmp.info,  Node: Random State Initialization,  Prev: Random Number Functions,  Up: Random Number Functions

Random State Initialization
===========================

   See *Note Random Number Functions:: for a discussion on how to
choose the initial seed value passed to these functions.

 - Function: void gmp_randinit (gmp_randstate_t STATE, gmp_randalg_t
          ALG, ...)
     Initialize random state variable STATE.

     ALG denotes what algorithm to use for random number generation.
     Use one of
        - GMP_RAND_ALG_LC -- Linear congruential.

          A fast generator defined by X = (aX + c) mod m.

          A third argument SIZE of type unsigned long int is required.
          SIZE is the size of the largest good quality random number to
          be generated, expressed in number of bits.  If the random
          generation functions are asked for a bigger random number
          than indicated by this parameter, two or more numbers of SIZE
          bits will be generated and concatenated, resulting in a "bad"
          random number.  This can be used to generate big random
          numbers relatively cheap if the quality of randomness isn't
          of great importance.

          a, c, and m are picked from a table where the modulus (m) is
          a power of 2 and the multiplier is congruent to 5 (mod 8).
          The choice is based on the SIZE parameter.  The maximum SIZE
          supported by this algorithm is 128.  If you need bigger
          random numbers, use your own scheme and call one of the other
          `gmp_randinit' functions.


     If ALG is 0 or GMP_RAND_ALG_DEFAULT, the default algorithm is
     used.  The default algorithm is typically a fast algorithm like
     the linear congruential and requires a third SIZE argument (see
     GMP_RAND_ALG_LC).

     When you're done with a STATE variable, call `gmp_randclear' to
     deallocate any memory allocated by this function.

     `gmp_randinit' may set the following bits in GMP_ERRNO:
        * GMP_ERROR_UNSUPPORTED_ARGUMENT -- ALG is unsupported

        * GMP_ERROR_INVALID_ARGUMENT -- SIZE is too big

 - Function: void gmp_randinit_lc_2exp (gmp_randstate_t STATE, mpz_t A,
     unsigned long int C, unsigned long int M2EXP)

     Initialize random state variable STATE with given linear
     congruential scheme.

     Parameters A, C, and M2EXP are the multiplier, adder, and modulus
     for the linear congruential scheme to use, respectively.  The
     modulus is expressed as a power of 2, so that M = 2^M2EXP.

     The least significant bits of a random number generated by the
     linear congruential algorithm where the modulus is a power of two
     are not very random.  Therefore, the lower half of a random number
     generated by an LC scheme initialized with this function is
     discarded.  Thus, the size of a random number is M2EXP / 2
     (rounded upwards) bits when this function has been used for
     initializing the random state.

     When you're done with a STATE variable, call `gmp_randclear' to
     deallocate any memory allocated by this function.

 - Function: void gmp_randseed (gmp_randstate_t STATE, mpz_t SEED)
 - Function: void gmp_randseed_ui (gmp_randstate_t STATE, unsigned long
          int SEED)
     Set the initial seed value.

     Parameter SEED is the initial random seed.  The function
     `gmp_randseed_ui' takes the SEED as an unsigned long int rather
     than as an mpz_t.

 - Function: void gmp_randclear (gmp_randstate_t STATE)
     Free all memory occupied by STATE.  Make sure to call this
     function for all `gmp_randstate_t' variables when you are done with
     them.


File: gmp.info,  Node: BSD Compatible Functions,  Next: Custom Allocation,  Prev: Random Number Functions,  Up: Top

Berkeley MP Compatible Functions
********************************

   These functions are intended to be fully compatible with the
Berkeley MP library which is available on many BSD derived U*ix
systems.  The `--enable-mpbsd' option must be used when building GNU MP
to make these available (*note Installing GMP::).

   The original Berkeley MP library has a usage restriction: you cannot
use the same variable as both source and destination in a single
function call.  The compatible functions in GNU MP do not share this
restriction--inputs and outputs may overlap.

   It is not recommended that new programs are written using these
functions.  Apart from the incomplete set of functions, the interface
for initializing `MINT' objects is more error prone, and the `pow'
function collides with `pow' in `libm.a'.

   Include the header `mp.h' to get the definition of the necessary
types and functions.  If you are on a BSD derived system, make sure to
include GNU `mp.h' if you are going to link the GNU `libmp.a' to your
program.  This means that you probably need to give the -I<dir> option
to the compiler, where <dir> is the directory where you have GNU `mp.h'.

 - Function: MINT * itom (signed short int INITIAL_VALUE)
     Allocate an integer consisting of a `MINT' object and dynamic limb
     space.  Initialize the integer to INITIAL_VALUE.  Return a pointer
     to the `MINT' object.

 - Function: MINT * xtom (char *INITIAL_VALUE)
     Allocate an integer consisting of a `MINT' object and dynamic limb
     space.  Initialize the integer from INITIAL_VALUE, a hexadecimal,
     '\0'-terminate C string.  Return a pointer to the `MINT' object.

 - Function: void move (MINT *SRC, MINT *DEST)
     Set DEST to SRC by copying.  Both variables must be previously
     initialized.

 - Function: void madd (MINT *SRC_1, MINT *SRC_2, MINT *DESTINATION)
     Add SRC_1 and SRC_2 and put the sum in DESTINATION.

 - Function: void msub (MINT *SRC_1, MINT *SRC_2, MINT *DESTINATION)
     Subtract SRC_2 from SRC_1 and put the difference in DESTINATION.

 - Function: void mult (MINT *SRC_1, MINT *SRC_2, MINT *DESTINATION)
     Multiply SRC_1 and SRC_2 and put the product in DESTINATION.

 - Function: void mdiv (MINT *DIVIDEND, MINT *DIVISOR, MINT *QUOTIENT,
          MINT *REMAINDER)
 - Function: void sdiv (MINT *DIVIDEND, signed short int DIVISOR, MINT
          *QUOTIENT, signed short int *REMAINDER)
     Set QUOTIENT to DIVIDEND/DIVISOR, and REMAINDER to DIVIDEND mod
     DIVISOR.  The quotient is rounded towards zero; the remainder has
     the same sign as the dividend unless it is zero.

     Some implementations of these functions work differently--or not
     at all--for negative arguments.

 - Function: void msqrt (MINT *OPERAND, MINT *ROOT, MINT *REMAINDER)
     Set ROOT to the truncated integer part of the square root of
     OPERAND.  Set REMAINDER to OPERAND-ROOT*ROOT, (i.e., zero if
     OPERAND is a perfect square).

     If ROOT and REMAINDER are the same variable, the results are
     undefined.

 - Function: void pow (MINT *BASE, MINT *EXP, MINT *MOD, MINT *DEST)
     Set DEST to (BASE raised to EXP) modulo MOD.

 - Function: void rpow (MINT *BASE, signed short int EXP, MINT *DEST)
     Set DEST to BASE raised to EXP.

 - Function: void gcd (MINT *OPERAND1, MINT *OPERAND2, MINT *RES)
     Set RES to the greatest common divisor of OPERAND1 and OPERAND2.

 - Function: int mcmp (MINT *OPERAND1, MINT *OPERAND2)
     Compare OPERAND1 and OPERAND2.  Return a positive value if
     OPERAND1 > OPERAND2, zero if OPERAND1 = OPERAND2, and a negative
     value if OPERAND1 < OPERAND2.

 - Function: void min (MINT *DEST)
     Input a decimal string from `stdin', and put the read integer in
     DEST.  SPC and TAB are allowed in the number string, and are
     ignored.

 - Function: void mout (MINT *SRC)
     Output SRC to `stdout', as a decimal string.  Also output a
     newline.

 - Function: char * mtox (MINT *OPERAND)
     Convert OPERAND to a hexadecimal string, and return a pointer to
     the string.  The returned string is allocated using the default
     memory allocation function, `malloc' by default.

 - Function: void mfree (MINT *OPERAND)
     De-allocate, the space used by OPERAND.  *This function should
     only be passed a value returned by `itom' or `xtom'.*


File: gmp.info,  Node: Custom Allocation,  Next: Contributors,  Prev: BSD Compatible Functions,  Up: Top

Custom Allocation
*****************

   By default, GMP uses `malloc', `realloc' and `free' for memory
allocation.  If `malloc' or `realloc' fails, GMP prints a message to
the standard error output and terminates execution.

   Some applications might want to allocate memory in other ways, or
might not want a fatal error when there is no more memory available.
To accomplish this, you can specify alternative memory allocation
functions.

   This can be done in the Berkeley compatibility library as well as
the main GMP library.

 - Function: void mp_set_memory_functions (
          void *(*ALLOC_FUNC_PTR) (size_t),
          void *(*REALLOC_FUNC_PTR) (void *, size_t, size_t),
          void (*FREE_FUNC_PTR) (void *, size_t))
     Replace the current allocation functions from the arguments.  If
     an argument is `NULL', the corresponding default function is
     retained.

     *Be sure to call this function only when there are no active GMP
     objects allocated using the previous memory functions!  Usually,
     that means that you have to call this function before any other
     GMP function.*

   The functions you supply should fit the following declarations:

 - Function: void * allocate_function (size_t ALLOC_SIZE)
     This function should return a pointer to newly allocated space
     with at least ALLOC_SIZE storage units.

 - Function: void * reallocate_function (void *PTR, size_t OLD_SIZE,
          size_t NEW_SIZE)
     This function should return a pointer to newly allocated space of
     at least NEW_SIZE storage units, after copying at least the first
     OLD_SIZE storage units from PTR.  It should also de-allocate the
     space at PTR.

     You can assume that the space at PTR was formerly returned from
     `allocate_function' or `reallocate_function', for a request for
     OLD_SIZE storage units.

 - Function: void deallocate_function (void *PTR, size_t SIZE)
     De-allocate the space pointed to by PTR.

     You can assume that the space at PTR was formerly returned from
     `allocate_function' or `reallocate_function', for a request for
     SIZE storage units.

   (A "storage unit" is the unit in which the `sizeof' operator returns
the size of an object, normally an 8 bit byte.)


File: gmp.info,  Node: Contributors,  Next: References,  Prev: Custom Allocation,  Up: Top

Contributors
************

   Torbjorn Granlund wrote the original GMP library and is still
developing and maintaining it.  Several other individuals and
organizations have contributed to GMP in various ways.  Here is a list
in chronological order:

   Gunnar Sjoedin and Hans Riesel helped with mathematical problems in
early versions of the library.

   Richard Stallman contributed to the interface design and revised the
first version of this manual.

   Brian Beuning and Doug Lea helped with testing of early versions of
the library and made creative suggestions.

   John Amanatides of York University in Canada contributed the function
`mpz_probab_prime_p'.

   Paul Zimmermann of Inria sparked the development of GMP 2, with his
comparisons between bignum packages.

   Ken Weber (Kent State University, Universidade Federal do Rio Grande
do Sul) contributed `mpz_gcd', `mpz_divexact', `mpn_gcd', and
`mpn_bdivmod', partially supported by CNPq (Brazil) grant 301314194-2.

   Per Bothner of Cygnus Support helped to set up GMP to use Cygnus'
configure.  He has also made valuable suggestions and tested numerous
intermediary releases.

   Joachim Hollman was involved in the design of the `mpf' interface,
and in the `mpz' design revisions for version 2.

   Bennet Yee contributed the functions `mpz_jacobi' and `mpz_legendre'.

   Andreas Schwab contributed the files `mpn/m68k/lshift.S' and
`mpn/m68k/rshift.S'.

   The development of floating point functions of GNU MP 2, were
supported in part by the ESPRIT-BRA (Basic Research Activities) 6846
project POSSO (POlynomial System SOlving).

   GNU MP 2 was finished and released by SWOX AB (formerly known as TMG
Datakonsult), Swedenborgsgatan 23, SE-118 27 STOCKHOLM, SWEDEN, in
cooperation with the IDA Center for Computing Sciences, USA.

   Robert Harley of Inria, France and David Seal of ARM, England,
suggested clever improvements for population count.

   Robert Harley also wrote highly optimized Karatsuba and 3-way Toom
multiplication functions for GMP 3.  He also contributed the ARM
assembly code.

   Torsten Ekedahl of the Mathematical department of Stockholm
University provided significant inspiration during several phases of
the GMP development.  His mathematical expertise helped improve several
algorithms.

   Paul Zimmermann wrote the Burnikel-Ziegler division code, the REDC
code, the REDC-based mpz_powm code, and the FFT multiply code.  The
ECMNET project Paul is organizing has been a driving force behind many
of the optimization of GMP 3.

   Linus Nordberg wrote the new configure system based on autoconf and
implemented the new random functions.

   Kent Boortz made the Macintosh port.

   Kevin Ryde wrote a lot of very high quality x86 code, optimized for
most CPU variants.  He also made countless other valuable contributions.

   Steve Root helped write the optimized alpha 21264 assembly code.

   GNU MP 3.1 was finished and released by Torbjorn Granlund and Kevin
Ryde.  Torbjorn's work was partially funded by the IDA Center for
Computing Sciences, USA.

   (This list is chronological, not ordered after significance.  If you
have contributed to GMP but are not listed above, please tell
<tege@swox.com> about the omission!)


File: gmp.info,  Node: References,  Next: Concept Index,  Prev: Contributors,  Up: Top

References
**********

   * Donald E. Knuth, "The Art of Computer Programming", vol 2,
     "Seminumerical Algorithms", 3rd edition, Addison-Wesley, 1988.

   * John D. Lipson, "Elements of Algebra and Algebraic Computing", The
     Benjamin Cummings Publishing Company Inc, 1981.

   * Richard M. Stallman, "Using and Porting GCC", Free Software
     Foundation, 1999, available online
     `http://www.gnu.org/software/gcc/onlinedocs/', and in the GCC
     package `ftp://ftp.gnu.org/pub/gnu/gcc/'.

   * Peter L. Montgomery, "Modular Multiplication Without Trial
     Division", in Mathematics of Computation, volume 44, number 170,
     April 1985.

   * Torbjorn Granlund and Peter L. Montgomery, "Division by Invariant
     Integers using Multiplication", in Proceedings of the SIGPLAN
     PLDI'94 Conference, June 1994.  Available online,
     `ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz' (and .psl.gz too).

   * Tudor Jebelean, "An algorithm for exact division", Journal of
     Symbolic Computation, v. 15, 1993, pp. 169-180.  Research report
     version available online
     `ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz'

   * Kenneth Weber, "The accelerated integer GCD algorithm", ACM
     Transactions on Mathematical Software, v. 21 (March), 1995, pp.
     111-122.

   * Christoph Burnikel and Joachim Ziegler, "Fast Recursive Division",
     Max-Planck-Institut fuer Informatik Research Report
     MPI-I-98-1-022,
     `http://www.mpi-sb.mpg.de/~ziegler/TechRep.ps.gz'.

   * Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone,
     "Handbook of Applied Cryptography",
     `http://cacr.math.uwaterloo.ca/hac/'.

   * Henri Cohen, "A Course in Computational Algebraic Number Theory",
     Graduate Texts in Mathematics number 138, Springer-Verlag, 1993.
     Errata available online
     `http://www.math.u-bordeaux.fr/~cohen'


File: gmp.info,  Node: Concept Index,  Next: Function Index,  Prev: References,  Up: Top

Concept Index
*************

* Menu:

* ABI:                                   ABI and ISA.
* About this manual:                     Introduction to GMP.
* alloca:                                Build Options.
* Allocation of memory:                  Custom Allocation.
* Anonymous FTP of latest version:       Getting the Latest Version of GMP.
* Arithmetic functions <1>:              Float Arithmetic.
* Arithmetic functions <2>:              Rational Arithmetic.
* Arithmetic functions:                  Integer Arithmetic.
* Assignment functions <1>:              Assigning Floats.
* Assignment functions:                  Assigning Integers.
* Basics:                                GMP Basics.
* Berkeley MP compatible functions:      BSD Compatible Functions.
* Binomial coefficient functions:        Number Theoretic Functions.
* Bit manipulation functions:            Integer Logic and Bit Fiddling.
* Bit shift left:                        Integer Arithmetic.
* Bit shift right:                       Integer Division.
* Bits per limb:                         Useful Macros and Constants.
* BSD MP compatible functions:           BSD Compatible Functions.
* Bug reporting:                         Reporting Bugs.
* Build notes for binary packaging:      Notes for Package Builds.
* Build notes for particular systems:    Notes for Particular Systems.
* Build options:                         Build Options.
* Build problems known:                  Known Build Problems.
* Comparison functions <1>:              Integer Comparisons.
* Comparison functions <2>:              Comparing Rationals.
* Comparison functions:                  Float Comparison.
* Compatibility with older versions:     Compatibility with older versions.
* Conditions for copying GNU MP:         Copying.
* Configuring GMP:                       Installing GMP.
* Constants:                             Useful Macros and Constants.
* Contributors:                          Contributors.
* Conventions for variables:             GMP Variable Conventions.
* Conversion functions <1>:              Converting Integers.
* Conversion functions:                  Converting Floats.
* Copying conditions:                    Copying.
* CPUs supported:                        Introduction to GMP.
* Custom allocation:                     Custom Allocation.
* Demonstration programs:                Build Options.
* Division functions <1>:                Integer Division.
* Division functions <2>:                Rational Arithmetic.
* Division functions:                    Float Arithmetic.
* Exact division functions:              Integer Division.
* Example programs:                      Build Options.
* Exponentiation functions <1>:          Float Arithmetic.
* Exponentiation functions:              Integer Exponentiation.
* Extended GCD:                          Number Theoretic Functions.
* Factorial functions:                   Number Theoretic Functions.
* Fibonacci sequence functions:          Number Theoretic Functions.
* Float arithmetic functions:            Float Arithmetic.
* Float assignment functions:            Assigning Floats.
* Float comparison functions:            Float Comparison.
* Float conversion functions:            Converting Floats.
* Float functions:                       Floating-point Functions.
* Float init and assign functions:       Simultaneous Float Init & Assign.
* Float initialization functions:        Initializing Floats.
* Float input and output functions:      I/O of Floats.
* Float miscellaneous functions:         Miscellaneous Float Functions.
* Floating-point functions:              Floating-point Functions.
* Floating-point number:                 Nomenclature and Types.
* FTP of latest version:                 Getting the Latest Version of GMP.
* Function classes:                      Function Classes.
* GMP version number:                    Useful Macros and Constants.
* gmp.h:                                 GMP Basics.
* Greatest common divisor functions:     Number Theoretic Functions.
* Home page:                             Introduction to GMP.
* I/O functions <1>:                     I/O of Rationals.
* I/O functions <2>:                     I/O of Integers.
* I/O functions:                         I/O of Floats.
* Initialization and assignment functions <1>: Initializing Rationals.
* Initialization and assignment functions <2>: Simultaneous Float Init & Assign.
* Initialization and assignment functions: Simultaneous Integer Init & Assign.
* Initialization functions <1>:          Initializing Integers.
* Initialization functions:              Initializing Floats.
* Input functions <1>:                   I/O of Floats.
* Input functions <2>:                   I/O of Rationals.
* Input functions:                       I/O of Integers.
* Installing GMP:                        Installing GMP.
* Integer:                               Nomenclature and Types.
* Integer arithmetic functions:          Integer Arithmetic.
* Integer assignment functions:          Assigning Integers.
* Integer bit manipulation functions:    Integer Logic and Bit Fiddling.
* Integer comparison functions:          Integer Comparisons.
* Integer conversion functions:          Converting Integers.
* Integer division functions:            Integer Division.
* Integer exponentiation functions:      Integer Exponentiation.
* Integer functions:                     Integer Functions.
* Integer init and assign:               Simultaneous Integer Init & Assign.
* Integer initialization functions:      Initializing Integers.
* Integer input and output functions:    I/O of Integers.
* Integer miscellaneous functions:       Miscellaneous Integer Functions.
* Integer random number functions:       Integer Random Numbers.
* Integer root functions:                Integer Roots.
* Introduction:                          Introduction to GMP.
* ISA:                                   ABI and ISA.
* Jabobi symbol functions:               Number Theoretic Functions.
* Kronecker symbol functions:            Number Theoretic Functions.
* Latest version of GMP:                 Getting the Latest Version of GMP.
* Least common multiple functions:       Number Theoretic Functions.
* Libtool versioning:                    Notes for Package Builds.
* Limb:                                  Nomenclature and Types.
* Limb size:                             Useful Macros and Constants.
* Logical functions:                     Integer Logic and Bit Fiddling.
* Low-level functions:                   Low-level Functions.
* Mailing list:                          Introduction to GMP.
* Memory allocation:                     Custom Allocation.
* Miscellaneous float functions:         Miscellaneous Float Functions.
* Miscellaneous integer functions:       Miscellaneous Integer Functions.
* Miscellaneous rational functions:      Miscellaneous Rational Functions.
* Modular inverse functions:             Number Theoretic Functions.
* mp.h:                                  BSD Compatible Functions.
* Multi-threading:                       GMP and Reentrancy.
* Nomenclature:                          Nomenclature and Types.
* Number theoretic functions:            Number Theoretic Functions.
* Numerator and denominator:             Applying Integer Functions.
* Output functions <1>:                  I/O of Floats.
* Output functions <2>:                  I/O of Integers.
* Output functions:                      I/O of Rationals.
* Packaged builds:                       Notes for Package Builds.
* Parameter conventions:                 GMP Variable Conventions.
* Precision of floats:                   Floating-point Functions.
* Prime testing functions:               Number Theoretic Functions.
* Random number functions <1>:           Integer Random Numbers.
* Random number functions:               Random Number Functions.
* Random number state:                   Random State Initialization.
* Rational arithmetic functions:         Rational Arithmetic.
* Rational comparison functions:         Comparing Rationals.
* Rational init and assign:              Initializing Rationals.
* Rational input and output functions:   I/O of Rationals.
* Rational miscellaneous functions:      Miscellaneous Rational Functions.
* Rational number:                       Nomenclature and Types.
* Rational number functions:             Rational Number Functions.
* Rational numerator and denominator:    Applying Integer Functions.
* Reentrancy:                            GMP and Reentrancy.
* References:                            References.
* Reporting bugs:                        Reporting Bugs.
* Root extraction functions <1>:         Float Arithmetic.
* Root extraction functions:             Integer Roots.
* Stack overflow segfaults:              Build Options.
* Stripped libraries:                    Known Build Problems.
* Thread safety:                         GMP and Reentrancy.
* Types:                                 Nomenclature and Types.
* Upward compatibility:                  Compatibility with older versions.
* Useful macros and constants:           Useful Macros and Constants.
* User-defined precision:                Floating-point Functions.
* Variable conventions:                  GMP Variable Conventions.
* Version number:                        Useful Macros and Constants.
* Web page:                              Introduction to GMP.

