Index: Aoffiles.c
===================================================================
RCS file: /usr/cvsroot/drlink/Aoffiles.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -p -r1.1.1.1 -r1.2
*** Aoffiles.c	1998/03/25 15:16:42	1.1.1.1
--- Aoffiles.c	1998/03/25 17:12:10	1.2
*************** static unsigned int addto_strt(char *nam
*** 144,152 ****
  static void reloc_aofarlist(arealist *ap) {
    arealist *firstarea;
    newhead *hp;
!   unsigned int areabase;
    firstarea = NIL;
    while (ap!=NIL) {
      if (ap->arbase!=firstarea) {	/* Area name differs from last one */
        firstarea = ap->arbase;
        newareacount+=1;
--- 144,153 ----
  static void reloc_aofarlist(arealist *ap) {
    arealist *firstarea;
    newhead *hp;
! 
    firstarea = NIL;
    while (ap!=NIL) {
+     unsigned int areabase;
      if (ap->arbase!=firstarea) {	/* Area name differs from last one */
        firstarea = ap->arbase;
        newareacount+=1;
*************** static void reloc_aofarlist(arealist *ap
*** 163,175 ****
          headlast->headflink = hp;
        }
        headlast = hp;
      }
-     ap->arplace = areabase;
-     if (ap==entryarea) {	/* Note new entry area if necessary */
-       newentryarea = newareacount;
-       entryoffset+=areabase;
-     }
-     areabase+=ap->arobjsize;
      ap = ap->arflink;
    }
  }
--- 164,177 ----
          headlast->headflink = hp;
        }
        headlast = hp;
+ 
+       ap->arplace = areabase;
+       if (ap==entryarea) {	/* Note new entry area if necessary */
+ 	newentryarea = newareacount;
+ 	entryoffset+=areabase;
+       }
+       areabase+=ap->arobjsize;
      }
      ap = ap->arflink;
    }
  }
*************** static void build_symt(void) {
*** 311,317 ****
            oldsp->symtvalue = oldsp->symtarea.symdefptr->symtarea.areaptr->arobjsize;
            oldsp->symtarea.symdefptr = NIL;
          }
!         if ((attr & SYM_SCOPE)==SYM_LOCAL || (attr & SYM_DEFN)==0 && oldsp->symtarea.symdefptr!=NIL) {
  /* Entry not needed */
            *indexlookup[n-1] = ALLFS;
          }
--- 313,319 ----
            oldsp->symtvalue = oldsp->symtarea.symdefptr->symtarea.areaptr->arobjsize;
            oldsp->symtarea.symdefptr = NIL;
          }
!         if ((attr & SYM_SCOPE)==SYM_LOCAL || ((attr & SYM_DEFN)==0 && oldsp->symtarea.symdefptr!=NIL)) {
  /* Entry not needed */
            *indexlookup[n-1] = ALLFS;
          }
Index: Areas.c
===================================================================
RCS file: /usr/cvsroot/drlink/Areas.c,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -c -p -r1.1.1.1 -r1.4
*** Areas.c	1998/03/25 15:16:42	1.1.1.1
--- Areas.c	1998/04/03 21:01:29	1.4
***************
*** 20,27 ****
--- 20,31 ----
  
  #ifdef TARGET_RISCOS
  #include <kernel.h>
+ #ifdef TARGET_UNIXLIB
+ #include <sys/swis.h>
+ #else
  #include <swis.h>
  #endif
+ #endif
  
  /* Variables referenced from other files */
  
*************** static arealist *add_newarea(filelist *f
*** 504,510 ****
        insert_area(&rwcodelist, &rwcodelast, ap);
      }
    }
!   else if ((atattr & ATT_COMMON)!=0 || (atattr & ATT_COMDEF)!=0 && (atattr & ATT_NOINIT)!=0) {	/* Common block ref */
      if (imagetype!=AOF) {	/* Do not want symbol created when linking partially-linked AOF file */
        ap->arsymbol = make_symbol(ap->arname, SYM_COMMON);
        sp = ap->arsymbol->symtptr;	/* Fill in 'area' field of cb's SYMT entry */
--- 508,514 ----
        insert_area(&rwcodelist, &rwcodelast, ap);
      }
    }
!   else if ((atattr & ATT_COMMON)!=0 || ((atattr & ATT_COMDEF)!=0 && (atattr & ATT_NOINIT)!=0)) {	/* Common block ref */
      if (imagetype!=AOF) {	/* Do not want symbol created when linking partially-linked AOF file */
        ap->arsymbol = make_symbol(ap->arname, SYM_COMMON);
        sp = ap->arsymbol->symtptr;	/* Fill in 'area' field of cb's SYMT entry */
*************** bool scan_head(filelist *fp) {
*** 774,793 ****
          }
        }
      }
!     if (ap!=NIL) {
!       aep->arlast.arlptr = ap;
!       add_srchlist(ap);
!       if (firstarea==NIL) firstarea = ap;
!     }
!     if (areaco==entryareanum) {
!       if (entryarea!=NIL) {
!         error("Error: Program has multiple entry points");
!       }
!       else {
!         if ((atattr & ATT_CODE)==0) {
!           error("Warning: Entry point for program in '%s' is in a data area, not code", fp->chfilename);
!         }
!         entryarea = ap;
        }
      }
      aep++;
--- 778,799 ----
          }
        }
      }
!     if (ok) {
!       if (ap!=NIL) {
! 	aep->arlast.arlptr = ap;
! 	add_srchlist(ap);
! 	if (firstarea==NIL) firstarea = ap;
!       }
!       if (areaco==entryareanum) {
! 	if (entryarea!=NIL) {
! 	  error("Error: Program has multiple entry points");
! 	}
! 	else {
! 	  if ((atattr & ATT_CODE)==0) {
! 	    error("Warning: Entry point for program in '%s' is in a data area, not code", fp->chfilename);
! 	  }
! 	  entryarea = ap;
! 	}
        }
      }
      aep++;
*************** static void fixup_adr(unsigned int *relp
*** 1279,1286 ****
          shift-=1;
        }
      }
!     inst = *relstart & ADSB_MASK | (negative ? INST_SUB : INST_ADD);
!     *relstart = inst | ((shift & SHIFT_MASK)<<SHIFT_SHIFT)+(addr & BYTE_MASK);
      addr = addr & ~BYTE_MASK;
      relstart++;
    } while (relstart!=relplace);
--- 1285,1292 ----
          shift-=1;
        }
      }
!     inst = (*relstart & ADSB_MASK) | (negative ? INST_SUB : INST_ADD);
!     *relstart = (inst | ((shift & SHIFT_MASK)<<SHIFT_SHIFT)) + (addr & BYTE_MASK);
      addr = addr & ~BYTE_MASK;
      relstart++;
    } while (relstart!=relplace);
*************** static void fixup_additive(unsigned int 
*** 1311,1317 ****
        }
      }
      else {	/* Half word  relocation */
!       data = (*(COERCE(relplace, char*))+*(COERCE(relplace, char*)+1)<<8)+relvalue;
        if (data>HALFHIGH) {
          flag_badreloc(relplace);
        }
--- 1317,1323 ----
        }
      }
      else {	/* Half word  relocation */
!       data = *(COERCE(relplace, char*))+(*(COERCE(relplace, char*)+1)<<8)+relvalue;
        if (data>HALFHIGH) {
          flag_badreloc(relplace);
        }
*************** static void fixup_additive(unsigned int 
*** 1335,1348 ****
          flag_badreloc(relplace);
        }
        else {
!         *relplace = inst & LDST_MASK | (addr<0 ? -addr : addr | IN_POSOFF);
        }
      }
      else if ((inst & INSTMASK)==IN_DATAPRO) {		/* Data processing instruction */
        fixup_adr(relplace, (reltype & REL_IIMASK)>>REL_IISHIFT, relvalue);
      }
      else {	/* Branch instruction. Will this happen? */
!       *relplace = inst & BR_MASK | (((extend24(inst)<<2)+relvalue)>>2) & BROFF_MASK;
      }
    }
  }
--- 1341,1354 ----
          flag_badreloc(relplace);
        }
        else {
!         *relplace = (inst & LDST_MASK) | (addr<0 ? -addr : addr | IN_POSOFF);
        }
      }
      else if ((inst & INSTMASK)==IN_DATAPRO) {		/* Data processing instruction */
        fixup_adr(relplace, (reltype & REL_IIMASK)>>REL_IISHIFT, relvalue);
      }
      else {	/* Branch instruction. Will this happen? */
!       *relplace = (inst & BR_MASK) | ((((extend24(inst)<<2)+relvalue)>>2) & BROFF_MASK);
      }
    }
  }
*************** static bool fixup_pcrelative(unsigned in
*** 1365,1371 ****
      else {
        addr = addr+relvalue-current_area->arplace;
      }
!     *relplace = inst & BR_MASK | ((addr>>2) & BROFF_MASK);
    }
    else if ((inst & INSTMASK)==IN_LDRSTR) {	/* LDR/STR */
      addr = inst & IN_OFFMASK;
--- 1371,1377 ----
      else {
        addr = addr+relvalue-current_area->arplace;
      }
!     *relplace = (inst & BR_MASK) | ((addr>>2) & BROFF_MASK);
    }
    else if ((inst & INSTMASK)==IN_LDRSTR) {	/* LDR/STR */
      addr = inst & IN_OFFMASK;
*************** static bool fixup_pcrelative(unsigned in
*** 1375,1381 ****
        flag_badreloc(relplace);
      }
      else {
!       *relplace = inst & LDST_MASK | (addr<0 ? -addr : addr | IN_POSOFF);
      }
    }
    else {		/* Assume data processing instruction (ADD or SUB) */
--- 1381,1387 ----
        flag_badreloc(relplace);
      }
      else {
!       *relplace = (inst & LDST_MASK) | (addr<0 ? -addr : addr | IN_POSOFF);
      }
    }
    else {		/* Assume data processing instruction (ADD or SUB) */
*************** void check_entryarea(void) {
*** 1549,1556 ****
      entryoffset = 0;
      error("Warning: Program has no entry point. Default of first executable instruction assumed");
    }
!   noheader = imagetype==RMOD || imagetype==BIN &&
!    (entryarea==rocodelist || rodatalist==NIL && rwcodelist==entryarea) && entryoffset==0 || opt_codebase;
  }
  
  /*
--- 1555,1566 ----
      entryoffset = 0;
      error("Warning: Program has no entry point. Default of first executable instruction assumed");
    }
!   noheader = imagetype==RMOD
!              || (imagetype==BIN && entryarea==rocodelist)
! 	     || (rodatalist==NIL
! 		 && rwcodelist==entryarea
! 		 && entryoffset==0)
!              || opt_codebase;
  }
  
  /*
*************** static void alter_area_offset(relocation
*** 1682,1695 ****
          flag_badreloc(relplace);
        }
        else {
!         *relplace = inst & LDST_MASK | (addr<0 ? -addr : addr | IN_POSOFF);
        }
      }
      else if ((inst & INSTMASK)==IN_DATAPRO) {		/* Data processing instruction */
        fixup_adr(relplace, (reltype & REL_IIMASK)>>REL_IISHIFT, -current_area->arplace);
      }
      else {
!       *relplace = (inst & BR_MASK) | (((extend24(inst)<<2)-current_area->arplace)>>2) & BROFF_MASK;
      }
    }
    else {	/* Data */
--- 1692,1705 ----
          flag_badreloc(relplace);
        }
        else {
!         *relplace = (inst & LDST_MASK) | (addr<0 ? -addr : (addr | IN_POSOFF));
        }
      }
      else if ((inst & INSTMASK)==IN_DATAPRO) {		/* Data processing instruction */
        fixup_adr(relplace, (reltype & REL_IIMASK)>>REL_IISHIFT, -current_area->arplace);
      }
      else {
!       *relplace = (inst & BR_MASK) | ((((extend24(inst)<<2)-current_area->arplace)>>2) & BROFF_MASK);
      }
    }
    else {	/* Data */
*************** static bool alter_type1_offset(relocatio
*** 1727,1733 ****
    }
    addr = sp->symtvalue+(extend24(*relplace)<<2);
    addr = addr-offset-current_area->arplace-PCMODIFIER;
!   *relplace = *relplace & BR_MASK | (addr>>2) & BROFF_MASK;
    return TRUE;
  }
  
--- 1737,1743 ----
    }
    addr = sp->symtvalue+(extend24(*relplace)<<2);
    addr = addr-offset-current_area->arplace-PCMODIFIER;
!   *relplace = (*relplace & BR_MASK) | ((addr>>2) & BROFF_MASK);
    return TRUE;
  }
  
*************** static bool alter_type2_offset(relocatio
*** 1784,1797 ****
        flag_badreloc(relplace);
      }
      else {
!       *relplace = inst & LDST_MASK | (addr<0 ? -addr : addr | IN_POSOFF);
      }
    }
    else if ((inst & INSTMASK)==IN_DATAPRO) {		/* Data processing instruction */
      fixup_adr(relplace, (typesym & REL_IIMASK)>>REL_IISHIFT, relvalue-current_area->arplace);
    }
    else {
!     *relplace = inst & BR_MASK | (((extend24(inst)<<2)+relvalue-current_area->arplace)>>2) & BROFF_MASK;
    }
    return TRUE;
  }
--- 1794,1807 ----
        flag_badreloc(relplace);
      }
      else {
!       *relplace = (inst & LDST_MASK) | (addr<0 ? -addr : addr | IN_POSOFF);
      }
    }
    else if ((inst & INSTMASK)==IN_DATAPRO) {		/* Data processing instruction */
      fixup_adr(relplace, (typesym & REL_IIMASK)>>REL_IISHIFT, relvalue-current_area->arplace);
    }
    else {
!     *relplace = (inst & BR_MASK) | ((((extend24(inst)<<2)+relvalue-current_area->arplace)>>2) & BROFF_MASK);
    }
    return TRUE;
  }
*************** static relaction decode_reloc(relocation
*** 1828,1834 ****
      sid = get_type2_index(typesym);
      typesym = get_type2_type(typesym);
    }
!   if ((typesym & REL_SYM)!=0 || istype1 && (typesym & REL_PC)!=0) {	/* Symbol relocation */
      sp = symtbase+sid;
      if ((sp->symtattr & SYM_DEFN)==0) {	/* External reference */
        sp = sp->symtarea.symdefptr;
--- 1838,1844 ----
      sid = get_type2_index(typesym);
      typesym = get_type2_type(typesym);
    }
!   if ((typesym & REL_SYM)!=0 || (istype1 && (typesym & REL_PC)!=0)) {	/* Symbol relocation */
      sp = symtbase+sid;
      if ((sp->symtattr & SYM_DEFN)==0) {	/* External reference */
        sp = sp->symtarea.symdefptr;
*************** static void alter_reloc(relocation *rp, 
*** 1912,1918 ****
      sid = get_type2_index(flags);
      flags = get_type2_type(flags);
    }
!   if ((flags & REL_SYM)!=0 || istype1 && (flags & REL_PC)!=0) {	/* Got a symbol reference */
      sp = symtbase+sid;
      if ((sp->symtattr & SYM_DEFN)==0) {
        sp = sp->symtarea.symdefptr;
--- 1922,1928 ----
      sid = get_type2_index(flags);
      flags = get_type2_type(flags);
    }
!   if ((flags & REL_SYM)!=0 || (istype1 && (flags & REL_PC)!=0)) {	/* Got a symbol reference */
      sp = symtbase+sid;
      if ((sp->symtattr & SYM_DEFN)==0) {
        sp = sp->symtarea.symdefptr;
Index: Drlhdr.h
===================================================================
RCS file: /usr/cvsroot/drlink/Drlhdr.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -p -r1.1.1.1 -r1.2
*** Drlhdr.h	1998/03/25 15:16:43	1.1.1.1
--- Drlhdr.h	1998/03/25 15:48:04	1.2
***************
*** 12,18 ****
--- 12,23 ----
  
  /* First, say which environment the program is being compiled to run under */
  
+ #if defined(__linux__) || defined(__netbsd__)
+ #define TARGET_UNIX
+ #else
  #define TARGET_RISCOS
+ #endif
+ 
  #define IGNORE_CASE
  
  #ifdef TARGET_RISCOS
Index: Drlmain.c
===================================================================
RCS file: /usr/cvsroot/drlink/Drlmain.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -p -r1.1.1.1 -r1.2
*** Drlmain.c	1998/03/25 15:16:42	1.1.1.1
--- Drlmain.c	1998/03/25 17:12:11	1.2
*************** static bool scan_cmdline(void);
*** 76,81 ****
--- 76,83 ----
  int main(int argc, char *argv[]) {
    time_t startime;
    int elapsed;
+ 
+   errors = 0;
    if (startup()) {
      startime = clock();
      copy_cmdline(argc, argv);
*************** int main(int argc, char *argv[]) {
*** 94,101 ****
        printf("Drlink: Link failed with %d error%s\n", errors, (errors==1 ? "" : "s"));
      }
      release_heap();
-     return (errors==0 ? EXIT_OK : EXIT_ERROR);
    }
  }
  
  static void print_help(void) {
--- 96,103 ----
        printf("Drlink: Link failed with %d error%s\n", errors, (errors==1 ? "" : "s"));
      }
      release_heap();
    }
+   return (errors==0 ? EXIT_OK : EXIT_ERROR);
  }
  
  static void print_help(void) {
*************** static char *get_text(void) {
*** 182,188 ****
    do {
      if (option) *cp = tolower(*cp);
      cp++;
!   } while (cp!=cvptrend && (terminator=='"' && *cp!='"' || terminator==' ' & *cp>' '));
    if (terminator=='"' && cp==cvptrend) {	/* " missing */
      error("Error: Unmatched '\"' found");
      cvptr = cp;
--- 184,190 ----
    do {
      if (option) *cp = tolower(*cp);
      cp++;
!   } while (cp!=cvptrend && ((terminator=='"' && *cp!='"') || (terminator==' ' && *cp>' ')));
    if (terminator=='"' && cp==cvptrend) {	/* " missing */
      error("Error: Unmatched '\"' found");
      cvptr = cp;
*************** static bool extract_name(char *np) {
*** 236,242 ****
      fnstart = NIL;
      return TRUE;
    }
!   while (ch!=NULLCHAR & ch!=',' & ch!=' ') {
      np++;
      ch = *np;
    }
--- 238,244 ----
      fnstart = NIL;
      return TRUE;
    }
!   while (ch!=NULLCHAR && ch!=',' && ch!=' ') {
      np++;
      ch = *np;
    }
*************** static bool get_number(char *p, unsigned
*** 316,321 ****
--- 318,324 ----
    bool ok;
    size = 0;
    radix = 10;
+   ch = *p;
    if (ch=='&') {
      radix = 16;
    }
*************** static bool get_number(char *p, unsigned
*** 334,340 ****
      else {
        digit = ch-'0';
      }
!     if (digit<0 || radix==10 && digit>9 || radix==16 && digit>15) {
        ok = FALSE;
      }
      else {
--- 337,343 ----
      else {
        digit = ch-'0';
      }
!     if (digit<0 || (radix==10 && digit>9) || (radix==16 && digit>15)) {
        ok = FALSE;
      }
      else {
Index: Makefile
===================================================================
RCS file: /usr/cvsroot/drlink/Makefile,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -p -r1.1.1.1 -r1.2
*** Makefile	1998/03/25 15:16:43	1.1.1.1
--- Makefile	1998/03/25 17:12:11	1.2
***************
*** 1,4 ****
! CFLAGS=-O2
  CC=gcc
  
  OBJS = Aoffiles.o Areas.o C++names.o Debug.o Drlmain.o \
--- 1,4 ----
! CFLAGS=-O2 -Wall
  CC=gcc
  
  OBJS = Aoffiles.o Areas.o C++names.o Debug.o Drlmain.o \
Index: Stdcode.c
===================================================================
RCS file: /usr/cvsroot/drlink/Stdcode.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -p -r1.1.1.1 -r1.2
*** Stdcode.c	1998/03/25 15:16:43	1.1.1.1
--- Stdcode.c	1998/03/25 17:12:11	1.2
*************** unsigned int relocode [] = {
*** 151,156 ****
--- 151,158 ----
  void get_hdrcode(segtype hdrtype, unsigned int **hdrstart, unsigned int *hdrsize) {
    unsigned int *p, *cp;
    unsigned int size;
+   p = cp = 0; /* Stop gcc warnings */
+   size = 0;
    switch (hdrtype) {
    case HDR_BIN:		/* Binary image */
      cp = &bincode[0];
Index: Symbols.c
===================================================================
RCS file: /usr/cvsroot/drlink/Symbols.c,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -c -p -r1.1.1.1 -r1.2
*** Symbols.c	1998/03/25 15:16:43	1.1.1.1
--- Symbols.c	1998/03/25 17:12:11	1.2
*************** static void check_symedit(symtentry *sym
*** 176,183 ****
    ep = current_symedit;
    while (ep!=NIL && ep->edtfnhash==fnhashval) {
      if (ep->edtsyhash==syhashval &&
!      (!opt_case && strcmp(ep->edtold, symname)==0
!       || opt_case && stricmp(ep->edtold, symname)==0)) {	/* Found symbol */
        symedit_count-=1;
        ep->edtdone = TRUE;
        switch (ep->edtoper) {
--- 176,183 ----
    ep = current_symedit;
    while (ep!=NIL && ep->edtfnhash==fnhashval) {
      if (ep->edtsyhash==syhashval &&
!      ((!opt_case && strcmp(ep->edtold, symname)==0)
!       || (opt_case && stricmp(ep->edtold, symname)==0))) {	/* Found symbol */
        symedit_count-=1;
        ep->edtdone = TRUE;
        switch (ep->edtoper) {
*************** static void check_refedit(symtentry *sym
*** 229,236 ****
    ep = current_refedit;
    while (ep!=NIL && ep->edtfnhash==fnhashval) {
      if (ep->edtsyhash==syhashval &&
!      (!opt_case && strcmp(ep->edtold, symname)==0
!      || opt_case && stricmp(ep->edtold, symname)==0)) {	/* Found symbol */
        refedit_count-=1;
        ep->edtdone = TRUE;
        current_file->edited = TRUE;
--- 229,236 ----
    ep = current_refedit;
    while (ep!=NIL && ep->edtfnhash==fnhashval) {
      if (ep->edtsyhash==syhashval &&
!      ((!opt_case && strcmp(ep->edtold, symname)==0)
!      || (opt_case && stricmp(ep->edtold, symname)==0))) {	/* Found symbol */
        refedit_count-=1;
        ep->edtdone = TRUE;
        current_file->edited = TRUE;
*************** static bool add_symbol(symtentry *symtp)
*** 324,330 ****
      p->symflink = *table;
      *table = p;
    }
!   else if ((p->symtptr->symtattr & SYM_STRONG)==attr & SYM_STRONG) {	/* Duplicate symbol */
      if (p->symtptr->symtarea.areaptr!=symtp->symtarea.areaptr) {	/* Not common def either */
        if (link_state==LIB_SEARCH) {
          error("Error: '%s' in '%s(%s)' duplicates a symbol already read",
--- 324,330 ----
      p->symflink = *table;
      *table = p;
    }
!   else if ((p->symtptr->symtattr & SYM_STRONG)==(attr & SYM_STRONG)) {	/* Duplicate symbol */
      if (p->symtptr->symtarea.areaptr!=symtp->symtarea.areaptr) {	/* Not common def either */
        if (link_state==LIB_SEARCH) {
          error("Error: '%s' in '%s(%s)' duplicates a symbol already read",
*************** static void build_symblist(void) {
*** 1141,1147 ****
      count = fp->symtcount;
      for (n = 1; n<=count; n++) {
        if ((sp->symtattr & (SYM_ABSVAL|SYM_DEFN))==SYM_DEFN && strcmp(sp->symtname, "__codeseg")!=0) {
!         if ((sp->symtattr & SYM_ABSVAL)!=0 || sp->symtarea.areaptr!=NIL && sp->symtarea.areaptr->arefcount!=0) {
            *sip = sp;
            sip++;
            symbcount+=1;
--- 1141,1147 ----
      count = fp->symtcount;
      for (n = 1; n<=count; n++) {
        if ((sp->symtattr & (SYM_ABSVAL|SYM_DEFN))==SYM_DEFN && strcmp(sp->symtname, "__codeseg")!=0) {
!         if ((sp->symtattr & SYM_ABSVAL)!=0 || (sp->symtarea.areaptr!=NIL && sp->symtarea.areaptr->arefcount!=0)) {
            *sip = sp;
            sip++;
            symbcount+=1;
