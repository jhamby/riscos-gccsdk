Drlink
======
The purpose of these notes is not to give a line-by-line
explanation of how the program works but to describe it in general
terms, filling in some background details and providing some
information on the main data structures. They are somewhat random
in nature, going into perhaps too much detail in some places and
skimming over important areas in others. The idea is to provide a
foundation for understanding the program, a few pointers as to
where to look first.

The first thing that should be said is that these notes and the
source code assume a detailed knowledge of the layout of chunk
files and of AOF.


Files
=====
The source code is made up of the following files:

C.Aofiles
C.Areas
C.C++names
C.Debug
C.Drlmain
C.files
C.Heap
C.Libraries
C.Linkdebug
C.Linkedit
C.Linkfiles
C.Messages
C.Stdcode
C.Symbols

H.Areahdr
H.Chunkhdr
H.Debugprocs
H.Drlhdr
H.Edithdr
H.Filehdr
H.Procdefs
H.Symbolhdr

Briefly, the purpose of each file is as follows:

C.Aofiles
Functions concerned with creating partially-linked AOF Files.

C.Areas
Functions that deal with areas in the AOF file, relocations
and the creation of the image file.

C.C++names
In theory, the C++ name demangling code goes here.

C.Debug
This file contains the functions used to create low level
debugging tables.

C.Drlmain
'main' and functions that deal with the command line go here.

C.Files
Everything to do with file I/O is in here.

C.Heap
Functions concerned with memory management are found here.

C.Libraries
Functions to do with libraries are in here.

C.Linkdebug
This file contains some debugging functions.

C.Linkedit
This file contains functions associated with editting AOF files.
 
C.Linkfiles
Functions to drive the link are found here.

C.Messages
This file is concerned with outputting error messages.

C.Stdcode
The various headers appended or prepended to the image file
are kept here.

C.Symbols
Functions concerned with dealing with symbols and resolving
references are found here.

The brief descriptions might make it look as if the various parts
of the linker are fairly well split up, but it is not as good as
it could be, for example, some functions dealing with relocating
code can be found in 'Symbols'. The code is not modular. A vague
nod in this direction was made in a few places but it was not
applied consistently or with any real thought. There is a large
number of interactions between the files, and they all refer to
each other's structures and sometimes modify them.

The main files are 'Areas' 'Files' and 'Symbols'. The vast bulk of
the code can be found in these. 'Drlmain' starts things going and
'Linkfiles' controls the link. The rest handle specific areas of
the processing, for example, 'Debug' creates the low level
debugging tables.

The source is fairly heavily commented but it does not give an
overall picture of how the linker works.

At the start of the files, the variables are divided into two
sections: those referenced outside the file and those private to
the file. Private variables are always declared as 'static'.
Functions that are only used within a source file are declared
'static' as well.


Controlling Compilation
=======================
In the file 'Drlhdr.h' there are two '#define's that control
what is and is not compiled, 'TARGET_RISCOS' and 'IGNORE_CASE'.

TARGET_RISCOS
This says whether RISCOS-specific features are included or not.
Basically it affects the I/O side of the program rather than the
way it works. It controls:

1) The use of RISCOS wildcards in filenames.
2) Whether filenames of the form 'xxx.o' are rearranged to 'o.xxx'.
3) Which characters are assumed to be wildcard characters in filenames.
4) Setting filetypes.
5) How detailed error messages are when an I/O error occurs.
6) Whether options '-throwback' and '-debimage' are available.

There are one or two other minor points. Anywhere where the
program uses a SWI rather than a standard C function is controlled
by this.

If 'TARGET_RISCOS' is left undefined, the linker will run quite
happily under RISCOS but the filetype of the image file will be
left as 'data'.

IGNORE_CASE
This simply controls whether the program ignores the case of
filenames or not. If it is #define'd, then case is ignored.

When compiling the program under RISCOS, specify:

#define TARGET_RISCOS
#define IGNORE_CASE
 
When compiling under RiscBSD or Linux, leave both of them out.
No changes are needed to the source code apart from including or
removing these '#define's to allow the linker to compile and run
under RISCOS, RiscBSD and Linux.


Main Structures
===============

There are three main structures used in the linker:

Symbol tables
Area lists
File list

Symbol Tables
The linker builds a number of different symbol tables when it is
reading AOF files and library members. The main one is the global
symbol table which contains references to all symbols defined as
'globally visible' in the AOF files. There  is a second table for
common blocks, and each AOF file has its own private table for
local symbols.

Each symbol table is just a hash table of pointers to linked lists
of 'symbol' entries.

Structure 'symbol' defines an entry in the symbol table. This is a
small structure that really contains nothing more than the
symbol's hash value and a pointer to the symbol's entry in the
OBJ_SYMT chunk of the AOF file in which it is defined. The
OBJ_SYMT entry can really be considered as the symbol's proper
symbol table entry.

The structure that mirrors OBJ_SYMT entries is called 'symtentry'.
One field in this, 'symtarea', is worth mentioning. If the SYMT
entry is for a symbol definition, then this points at the arealist
entry of the area in which the symbol is defined. If a symbol
reference, then this field contains either 'nil' or a pointer to
the OBJ_SYMT entry of the definition of the symbol to which this
is a reference.

struct 'symtentry' illustrates another point: the linker makes use
of some AOF structures for its own purposes.

Struct 'symbol' is in fact used for two purposes:
i) To define a symbol
ii) To point at a symbol reference.

The first use has already been covered.

OBJ_SYMT entries also cover external symbol references. Struct
'symbol' entries do the same. In this instance, they are not
stored in the symbol table but are used to set up a linked list of
external references in the AOF file. The list is associate with
the AOF file and used when resolving symbol references.

Strong Symbols
To be more precise, struct symbol actually contains two pointers to
entries in the OBJ_SYMT, corresponding to possible 'strong' and
'non strong' versions of a symbol. In most cases, there will be
only one definition, the 'non strong' one. The field 'symtptr'
points at that and the other field is set to 'nil'. When a
strong definition is found, the pointer to the strong symbol is
stored in 'symtptr' and the other field points at the non-strong
version. In other words, the version of the symbol that is used in
the vast majority of cases is pointed at by 'symtptr'. The
other field is only used when dealing with a reference to the the
symbol in the AOF file in which the strong symbol is defined.


Area List
The structure for this is 'arealist'. An arealist entry is created
for each area defined in the OBJ_HEAD chunk of an AOF file. It is
also possible for entries to be created if a symbol in the
OBJ_SYMT has the 'common reference' bit set. Each entry is added
to one of six area lists, which correspond to the types of areas
found:

Read only code
Read/write code
Read only data
Read/write data
Zero-initialised data
Debugging tables

Details of common blocks are stored in the 'zero-initialiased
data' list (they normally have the 'no data present in OBJ_AREA
chunk' attribute bit set to indicate this anyway.)

The fields in struct arealist are relatively straight forwards,
including such details of the area's attributes, a pointer to
the body of the area in the OBJ_AREA chunk, a pointer to the
area's relocations, its address in the image file and so
forth. Two fields that might be worth describing further are
'arbase' and 'arlast'. 'arbase' points back at the first area
with the same name as the current area. This makes it easy to
determine areas with the same name. The other one is more 
tricky. In the first entry for an area of a given name, it
points at the last entry with the same name. It is only used
when creating the area list to speed up scanning the area
lists. In a large 'C' program, which might contain dozens
of areas called 'C$$Code', this speeds up processing
enormously.

The structure used to define the layout of an entry in the AOF
file's OBJ_HEAD chunk, struct 'areaentry', also has a field called
'arlast', but in this instance it is an union. This field is
defined as containing zero by AOF, so it is used by the linker to
provide a link from an OBJ_HEAD entry to the corresponding
'arealist' entry. This is needed in cases where an area is
identified by its position in the OBJ_HEAD chunk in, for example,
a relocation, to provide the link to the required arealist entry.


File List
Each AOF file read or library member used from a library
has an entry in the file list. The structure for for this
is struct 'filelist'. It describes a single AOF file,
specifying its name, where the file is in memory, the
addresses in memory of the various chunks and so forth.
It also contains the file's local symbol table and a pointer
to the list of unresolved symbol references.

The two structures, 'filelist' and 'arealist' are the ones
used to process the AOF files. They are two central pillars
upon which the rest of the linker is build.


Other Structures
================
There are many other structures used in the linker but the
ones listed above are the most important. Other ones of
interest are:

Area table
This is a table set up when reading an AOF file to speed up
searching for the area in which a symbol is defined. The table is
created when the file's OBJ_HEAD chunk is read and discarded when
the processing of that file ends. The layout is defined by struct
'areasrchlist'.

Library list
This is a linked list detailing the libraries to be searched and
the order in which they are processed. The format is defined in
structure 'libheader'.

Load list
This contains a list of name of members loaded from libraries and
the libraries from which they came. It is defined by struct
'loadlist'.

Link list
This is a list of the names of AOF files to be included in the
link, defined by struct 'linkfiles'.

Debug table list
This is a list of files specified on '-keepdebug' where the
debugging tables in a file are to be kept. The layout is given
by struct 'debugfiles'.

Link edit command list
Entries in this are defined by struct editcmd. It gives
details of one link edit command.


Linking a Program
=================
Linking a program can be broken down into the following steps:

1) Read the object files
2) Resolve symbol references
3) Calculate area and symbol addresses
4) Carry out relocations
5) Write image file

The file list is the main structure used to deal with the file
during the first two steps. Both the file and area list are used
for the third and area list is used for the rest of the link.


1) Read the Object Files
------------------------
The linker starts by trying to read all of the AOF files and
libraries listed on the command line into memory. It builds up the
file and area lists from each AOF file as well as the local and
global symbol tables. The common block symbol table is also set up
at this point.The processing is fairly straightforwards:

a) The files on the command line are read one at a time.
b) The chunk file header and the OBJ_HEAD and OBJ_SYMT chunks
are processed to create entries in the area lists for the
entries in the OBJ_HEAD and in the symbol tables for the OBJ_SYMT.
The chunks are checked thoroughly to ensure that they are legal.
The checking is not exhaustive, but the intention is not to let
anything through that might case the linker to fail. Unsupported
area and symbol attributes have to be flagged as errors as it is
not safe to ignore them and 'hope for the best'. Libraries are 
not touched except to note their existance and to add them to the
library list. 

Notes:
a) Any 'link edit' commands are dealt with when the AOF files
are read.

b) Common blocks require quite a lot of extra work. They can be
introduced either as areas in the OBJ_HEAD chunk of an AOF file
or via symbols in the file's OBJ_SYMT that have the 'common
reference' bit set. Common blocks in the OBJ_HEAD can be
either definitions or references. It is also possible to have
DATA areas with the 'common definition' bit set which are not
really common blocks at all. (The common attribute is being
used to indicate that the area contains data where only one
copy of it should be included in the image file if the same
area is present in other AOF files.)

c) 'Old Style' Libraries: these are different to normal ALF
libraries in that every single member has to be loaded from
that library. They are treated as just a collection of AOF
files found in one single file.

d) Strong symbols add a nasty complication here. If a file
contains a strong symbol definition, there might not be an
external reference for the non-strong version of it. In this case,
any references to the symbol in the relocations in the file will
point at the strong definition. It is necessary to check for these
and to create dummy external references so that the symbol
resolution code will pull in the non-strong version. There is a
second part of this in the relocation code: see note a) in that
section.

e) In order to use memory more efficiently, if an AOF file contains
debugging tables but option '-debug' has not been used, that
is, the executable image is not to contain debugging tables,
the memory occupied by the tables in the AOF file is returned
to the heap.

g) Some effort was expended here trying to make the code run
fast, especially when it came to updating the area lists. When
linking large programs, the time taken does become significant.
Comments in the source code explain the tricks used.

g) The code uses a number of global variables to define such
things as the start and end addresses in memory of the OBJ_SYMT
chunk of the file being read, to point at the filelist entry for
the file, to point at the chunk file header, to give the number of
chunks in the file and so forth. Watch out for these.


2) Resolve Symbol References
----------------------------
Once the AOF files have been safely tucked away in memory, the
next step is to resolve symbol references between the files.

This part of the link can be broken into three parts:

a) Resolve symbol references between the AOF files.
b) Search libraries to find references that are still unresolved.
c) Resolve invented symbols and strong symbol references.

The link does not continue beyond this point unless all symbol
references can be satisfied.

The file list view of the program is used here. Three or more
passes are made of it, one during step a), possibly several during
step b) and one during step c). The code scans through the
complete file list each time (or as many times as necessary)
before moving on to the next step.

Efforts to resolve symbol references continue either until all
references have been resolved or all possible sources for locating
symbols have been exhausted.

The list of unresolved entries that hangs off the file list entry
for a file is the most important structure here.

a) Resolve symbol references between the AOF files.
The code goes through the unresolved symbol list and attempts to
find a match in one of the symbol tables. It searches the AOF
file's local symbol table first, then the global table and lastly
the common block table. If a match is found, field 'symdefptr' of
the external reference's OBJ_SYMT entry is updated to point at the
OBJ_SYMT entry of the matching symbol and the 'unresolved symbol'
entry is removed from the AOF file's unresolved symbol list.

b) Search Libraries
Libraries are searched one at a time attempting to resolve all of
the symbol references in all of the files on the file list using
that library before moving on to the next library.

The OFL_SYMT chunk of each library is searched for the symbols. A
symbol table is built from this when a library is referenced for
the first time to speed up the search process. If option 'rescan'
has been specified, this is kept in memory otherwise it is
discarded when the search of the library has been completed.

When a symbol is found, the library member that contains that
symbol is loaded into memory. In the case where libraries are
resident in memory (the normal case) this is just a matter of
setting up pointers to that member, otherwise the library member
has to be read from disk. The library member is basically treated
like any other AOF file after this, that is, the symbol tables and
file and area lists are updated according to what the member
contains and a list of external references built. The member is
added to the end of the file list. One extra step is carried out:
an attempt is made to resolve the unresolved external references
in that library member from the various symbol tables at the time
the member is loaded, that is, the processing in step 2a) is
carried out for the member. The reason for this is to bring the
file to the same state of processing as the other files in the
file list. 

One important point to note is that before searching a library
for a symbol, a check of the global symbol table is made to see if
that symbol is now available as a result of loading one of the
other library members.

c) Resolve Linker-defined Symbols
At this stage, there might still be references to two types of
symbol:

i)  Invented symbols such as 'wibble$$Base'.
ii) References to strong symbols that were deferred until the
    right type of symbol was found.

Notes:
a) Strong symbols complicate matters. Whenever a symbol is found,
it is necessary to check:

i) Is the reference is in the same AOF file as the definition?
ii) Is the definition is a strong symbol?

If the answer to both of these is 'yes' the symbol is not the
one to use here. Any other combination is okay and means that
the symbol definition is the one to use. The test is carried
out by checking if the definition is located in the OBJ_SYMT
of the file being processed. As each AOF file is dealt with,
a pair of pointers are set to the limits of that file's OBJ_SYMT
and addresses checked against that.

b) Libraries contain OFL_SYMT chunks and AOF files OBJ_SYMT
chunks. There is a variable in the program, 'symtbase', that
sometimes points at an OFL_SYMT and at other at OBJ_SYMTs.
Be careful with it.

3) Calculate Area and Symbol Addresses
--------------------------------------
This is probably the most straight forwards part of the link.
It is carried out in two steps:

a) Calculate the starting addresses of each area in the image file.
b) Calculate the addresses of all the symbols.

Step a) is a case of going through each of the area lists and
simply adding the size of the area to the base address of the area
to get the address of the next area. The values of linker-defined
symbols such as 'Image$$RO$$Base' are also calculated at this
stage.

Step b) goes through the OBJ_SYMT chunk of each file in the file
list and adds the address of the base of the area containing the
symbol to the offset of the symbol in that area.

Notes:
a) The 'nounused' processing is carried out before working out the
area addresses, if that option is specified.

b) The type of header code needed, for example, the AIF image
header, is decided at this point. AIF images and binary images
where the first instruction is not the entry point have headers;
relocatable modules do not. Relocatable AIF images and modules
have relocation code appended to them as well.

c) Modules are slightly curious in that the lowest address in
the image file is actually 0x8000. There is no reason for this
value not to be chosen, but as addresses within modules are
relocated when it is loaded, it is curious. On the other hand,
the area and symbol maps produced by the linker show addresses
that start from zero.

4) Carry Out Relocations
------------------------
This is the most complex part of the linker as there is a large
number of possibilities to consider. The code goes through each
each area list, dealing with the relocations for each area.

Two types of relocation are defined in AOF, known as type-1 and
type-2. Type-1 relocations are relatively straightforwards to deal
with, but type-2s can be pretty hairy due to the many different
types of relocation and the combinations possible.

Notes:
a) Strong symbols make life difficult here again. If a relocation
refers to a symbol and that symbol is a strong symbol, then it is
the wrong symbol and the non-strong version has to be found
instead. This requires a search of the global symbol table. The
reason for this is that, as the relocation is a reference to a
strong symbol definition which must be in the OBJ_SYMT of the file
in which the relocation is found, by definition, it is the wrong
version of the symbol to use. It is therefore necessary to go and
look for it. The symbol resolution code will have brought in the
non-strong version as the functions that read in the AOF files
will have detected the strong symbol definition and created an
external reference to ensure that the non-strong symbol will
be searched for.

b) The linker interprets the 'relocate unbounded instruction
sequence' type of relocation in a different way to the way in
which it is defined. Instruction sequences are defined as strings
of ADD and SUB instructions where 'Rd' and 'Rn' of the second and
subsequent instructions equal 'Rd' of the first, possibly followed
by a 'LDR'- or 'STR'-type instruction when 'Rn' is the same as
'Rd' and the offset is a constant, for example,

	ADD	R5,R11,#100
	ADD	R5,R5,#200
	LDRB	R0,[R5,#0]

is considered an instruction sequence under these rules. The
linker only considers strings of ADDs and SUBs as it is possible
that relocations could go wrong because of the way in which 
objasm' and the C compiler use this type of relocation for
everything in the code. This means that programs linked with
the Acorn liner and this one might behave differently.
  
c) The algorithm for packing a constant into an ARM instruction is
simple, and probably bears no resemblence to the one used in the
ARM linker. It is probably not worth making it any more complex.
 
d) Based area relocations work with Drlink but release 5.06 of
the Acorn linker has some serious problems in this area. If there
are muliple areas with the same name, it relocates references in
the second and subsequent areas incorrectly. Programs linked with
this linker and then with the Acorn linker will work with one and
fail with the other!

e) The relocation code for partially-linked AOF files is included
here. These functions are as complicated as they get in the linker
and they are very heavily commented. Don't touch this code.


5) Write Image File
-------------------
Assuming that everything has worked so far, the image file is
written to disk. Once that has been completed successfully, the
symbol and area maps are produced, if the options for these have
been specified.

There is nothing complicated here: the code works through the area
lists and writes the contents of the areas to disk.

Notes:
a) In order to speed up writing the file to disk, it is copied to
a 64K byte buffer. Only when that buffer is full (or an area more
than 64K bytes long is encountered) is anything written to disk.
This makes a big difference to the performance under RISCOS.
 
b) Under RISCOS, the linker creates a file of the size of the
image before writing to it. The idea was to speed up writing the
image file, as the time spent reading from and writing to disk is
the slowest part of the link process. Whether this actually has
any effect has never been measured.

c) Modules and relocatable AIF images have to be followed by a
table of offsets within the image file that will have to be
relocated when the file is loaded, so once the areas in the
area list have been dealt with, there is still a little more
to be done with these types of image file.

d) The area map and symbol code were deliberately left until last
so that if anything in this code breaks, the image file will have
been created successfully.


Heap Management
===============
The linker carries out its own heap management. It acquires
storage in blocks using 'malloc' and allocates memory from those.
The reason for this is that memory tends to be released from the
middle of the areas allocated, which 'free' cannot not handle. An
example: when reading in AOF files, the linker acquires the memory
to hold an entire file in one request. The OBJ_AREA chunk of the
files might contain debugging areas. IF the option '-debug' has
not been specified, these areas are not required and so the linker
will free the memory occupied by the debugging areas. This will be
in the middle of the block of memory allocated to hold the file,
so simply returning it to the heap using 'free' will not work. The
memory is returned to the heap the linker looks after. It is only
at the end of the run that the linker returns all the blocks
allocated via malloc to the heap.

When running under RISCOS, the size of the Wimpslot is
automatically adjusted by the Shared C Library if the memory
required exceeds the original size of the Wimpslot. This works
both when the linker is running on its own or as a subtask of,
say, amu.


Partially Linked AOF Files
==========================
The notes above describe the normal link process when an
executable image is to be created. It is more-or-less exactly the
same when dealing with relocatable modules and relocatable AIF
images, but there are substancial differences when creating a
partially-linked AOF image. They can be summarised as:

a) When resolving symbols, it is not an error if the symbol
   cannot be found.
b) Some relocations can be dealt with but not all of them.
c) The creation of the output file is completely different.

b) is the worst part of the entire linker in terms of complexity.
There are three possibilities:

i) A relocation can be dealt with entirely.
ii) A relocation can be dealt with, but a further relocation will have
to be generated in the new AOF file as well.
iii) The relocation cannot be resolved at all and has to be
carried over into the new AOF file.

In cases ii) and iii), it is likely that the form of the
relocation will have to be changed too, that is, it is not just a
simple case of copying it to the new file. It is also possible
that the item to be relocated will have to be modified (if subject
to a type-2 relocation) even if the relocation itself can be
carried across without modification.

Creating the AOF file is fairly involved. The following steps have
to be carried out:

i) Areas with the same name have to be coalesced into single areas.
ii) A new OBJ_SYMT chunk has to be created from the OBJ_SYMTs of
the AOF files used in the link. This has to exclude any local symbols.
(References to these would have been dealt with, plus it is likely
that there would be multiple instances of each symbol.)
iii) The relocations for each area have to be reworked.
Relocations that have been dealt with have to be removed and
references to symbols and areas, which are defined in terms of
their positions in the OBJ_SYMT and OBJ_HEAD chunks of the AOF
files, have to be modified to point at their new positions in the
new OBJ_HEAD and OBJ_SYMT chunks.
iv) A new OBJ_HEAD chunk has to be set up.
v) A new OBJ_STRT chunk has to be created from the OBJ_STRT chunks
of the original files.
vi) Now the file can be written to disk.

One small problem with the linker is that the AOF file created
might contain a mixture of type-1 and type-2 relocations,
especially if one of the original AOF files contained type-1
relocations. The AOF version of the files is therefore set to 2.
This might cause problems if one of the AOF files included in it
uses features specific to AOF version 3. It would be possible to
change the code so that it creates only type-2 relocations and the
AOF version set to 3, but the relocation code is complicated
enough as it is and so this is not regarded as being that
important.

Partially-linked AOF files are a lot of work, and the feature is
probably never used.


Possible Improvements to the Linker
===================================
Only two spring to mind:

a) There are still some unsupported AOF 3 area and symbol
attributes. One that is on the 'to do' list is the 'code datum'
symbol attribute (someone has asked for this), but the AOF
documentation does not say what effect it has. Nothing else
should be added unless there is a requirement for it.

b) The 'nounused' algorithm is crude (it was copied from a working
program). A more elegant solution would be to construct a graph of
the areas and to determine which ones can be reached from the area
containing the program's entry point. Anything else could then be
deleted. Again, this is a minor point. The existing code works
well enough.


Program Style
=============
Program style is always a contentious issue, but the following
notes describe the rules used to write the program.

a) The code was converted to C and therefore does not use all of
the facilities of the language. 

b) Whilst constants are set up using #define, there is only one
macro in the whole program. There are places where macros could
be used, but leaving them out was entirely deliberate as I do
not like them because it is too easy to make a program
incomprehensible.

c) Structures and enums are always typedef'ed.

d) Variables and functions that are local to one source file
are always declared 'static'. 

e) Expressions like '*p++-*q++' were avoided. '++' and '--' are
only used to increment and decrement pointers. 'x+=<value>'
is used for numeric variables.

f) Braces were used in many places where they were not needed. The
rules for braces were:

i)  If an 'if' has an 'else' part, both sides have braces even
    if there is only one statement following the 'if' and 'else'.

ii) If an 'if' or 'while' is followed by a single statement and
    it will not make the line too long, put everything on the
    same line, for example, 'while (p!=NIL && *p<>'x') p++;'

g) The null pointer is always represented by 'NIL'.

h) Logical values are represented by 'TRUE' and 'FALSE'.

i) Explicit tests against 0 are used in 'if' statements where
they are not needed. This was both an artifact of the code
conversion and a deliberate policy.

j) A quick perusal of the code would reveal that there is a lot of
fiddling around with bits in data structures, for example, area
attributes. These could probably be replaced with bitfields.


Assumptions Made
================
Sizeof(char) = 1 byte.

Sizeof(int) and sizeof(unsigned int) = 4 bytes.

There are a number of places where specific values have to be
added to a pointer, for example, the offsets of the chunks within
an AOF file when it is in memory. In such cases, the code casts
the pointer to a 'char *' for the pointer arithmetic. This, of
course, relies on a 'char' being one byte in size.

There is only one place where the size of a pointer and an integer
are assumed to be the same, in a function that has to word-align
an address. This assumption is not made anywhere else.

'ftell' and 'fseek' are assumed to return and work with offsets in
bytes.
