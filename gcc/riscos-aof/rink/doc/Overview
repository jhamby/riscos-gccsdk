
Overview of rink
rink documentation, (c) Ben Summers 1995


This document is organised as 'informal' questions and answers. Please read
this before any of the other files which contain more formal usage
instructions. You might find it helpful to browse the glossary file now.

See index for details of what each file contains.


What is rink?
~~~~~~~~~~~~~
rink is a run time linker.


Er, right. So what is run time linking?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When you link a program with link, link takes all your object files (stored
in your o directory) and makes them into one file along with any library
modules it needs.

After it has done this, it 'links' all the function calls together so that
when you call a function, it actually calls it. You see, in the object
files, the compiler doesn't create proper branch instructions because it
doesn't actually know where the functions it's called are, so it creates
relocations.

link goes along and relocates everything according to these relocations.
After it's assembled all the objects into one file it knows where everything
is so it can replace the function calls the compiler generated with real
ones.

This is all very well and good, but it means you can't load more of this
object code in and run it because it won't have it's relocations relocated.

This is where rink comes in. It can load more code in, and then link that to
functions within your program. This is run time linking - instead of
creating all the links at link time just after compliation, some of the
links are linked at run time when you actually run the program.


OK, I think I've got that now. So, what would I use it for?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Quite a lot of programs perform several distinct functions which are
controlled in a similar way.

For example, imagine a program which converts between different file
formats. It'll have a few routines to provide a user interface, and then
more to convert between different file formats.

For example, you might have routines in each convertor to

    * Initialise it

    * Get some info on what it can convert

    * Identify files

    * Set up some options

    * Perform a conversion

Each convertor does a very different thing, but they all have the same set
of functions to control them, and the calling code doesn't need to know the
details of what they're doing.

Now, if you put all these convertors into your main program, you then can't
extend your program to do more conversions with recompiling it, and when you
load your program you have to load all the convertors, whether or not you
want to use them. This means your program is larger. And perhaps more
importantly, other people can't extend your program to do more conversions
without access to your code...

You might think it would be a good idea to store the convertors on disc
seperately, and load them when you actually want to use them. And then maybe
throw them away when you've finished with them to save memory.

This is exactly the sort of thing run time linking is useful for.

Other possible uses are

    * Extensible applications, where all the tools are seperate to the
      application kernel.

    * Removing the necessity for code to be loaded all the time
      (although overlays can often be a better thing to use).

    * Writing programs which other people can extend easily.

... but this isn't a definative list. Once you understand what rink does,
you'll probably be able to think of lots of other things you can do with it.

If you are familiar with C++, here's another way to think about it. If you
have a base class which represents an interface to an entity, then if other
objects can be represented as derived classes from this base class, then they
are very much suitiable for being stored as rink segments.


That sounds useful, but surely there are some things I can't use it for.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If all the bits of code you want to load in have sepecific functions which
the parent program must know about, you should think about other ways of
achieving this, perhaps using overlays or splitting your code up into
seperate programs.

However, you could still use rink so you get complete control of the loading
and unloading of segments. rink just provides a method of loading code and
calling functions - what you do with them is up to you.

The main thing rink cannot do is share one instance of code between
applications to provide something like a shared library. This is because the
code is linked to the application and there can only be one instance of the
associated data.

However, you could use something like a module to load in your code and
provide your own API to call shared code, but you must not use static data,
instead passing in a data block on each call.


What about modules?
~~~~~~~~~~~~~~~~~~~
Yes, you can use rink in modules. Just remember to use the module code option
on your segments as well as the main module code.


How does rink work?
~~~~~~~~~~~~~~~~~~~
The actual rink program prepares object files for run time linking. First,
it uses link to combine all the object files you give it into one AOF file,
and perform internal relocations (relocations which link to data and
functions within the object code). rink then works out what links need to be
performed at run time, and writes a compact file describing the links and a
code file. These two files allow the code to be loaded and linked into the
parent program.

Instead of referencing functions by name, it references them by index into a
list of functions. This list is the pointer block map. Reference by index
means that the overhead of this table is minimal. The table for all the
symbols in the shared C library is just over 1K long. The links are thrown
away after loading the code.

A typical rink segment is stored in a directory containing a code and a link
file, and any other resources necessary. However, the program is free to
store them anyway it chooses.

The parent program has the rink run time system linked into it. This loads
the segments, and provides access to function pointers within it.


Won't it be more difficult to write code that's loaded it at run time?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
No, not really. You compile your code to be run time linked with exactly the
same compiler options as the main code and include header files in exactly
the same way. You call functions just as you would in ordinary code.

The difference only comes when you come to link the code. Instead of using
link, you use rink, and provide a file (the header description file) telling
rink what to do with it. This file gives details on, amoung other things,
the functions to place in the header. These functions are the functions you
can call from the parent program. You can usually use the same header
description file for every segment.

As well as a standard set of functions, you can also include named
functions so you can be as flexible as you need.

You can access both code and data in the parent program as long as their
names are included in the pointer block.


Well then, won't it be more difficult to call it?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This is slightly different, but still quite easy to do. You are provided
with functions to load a rink segment, and a function to find a pointer to a
function within the segment. All you do is just treat that pointer as a
normal C function pointer.

Have a look at the demonstration program, which shows just how easy it is to
use.


Doesn't run time linking have a bit of a performance hit?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Function calls from the segment to the parent have no performance hit, as
once they are loaded they are functionally identical to code linked in at
compile time. If you cache the pointers to functions in the segments, then
the performance hit for a parent to segment is just the same as calling a
function through a pointer in normal code.


Do I have to use a specific language to be able to use rink?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
No. rink only requires APCS compilance to function, so any language compiler
which produces APCS compilant AOF files can be used, including assembler.

The rink run time system requires memory allocation and free functions and
optionally a error translation function. These are by default bound to
malloc(), free() and an internal routine respectively, but you can bind them
to other functions using command line options to rinkptr.

With C++, you will have to use mangled names in the header description or
use C style functions for the interface.

You do not need to use the shared C library. You could use something like
UnixLib - just scan the relevant stubs or library file when creating the
pointer block file.


What conditions are there on distributing code which uses rink?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
There are no restricitions on distributing rink segments as these only
contain your code. However, the parent program requires the rink run time
system. There are a few restrictions on what you can do with this, depending
on the status of your program. See the ReadMe file for more details on this.


Why do you always spell it with a lower case 'r'?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Because that's its name. It's what it's executable is called, and looks
nicer when written. Humour me, and always spell it like that too.  :-)


Well that's quite cool, but I have another question...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
If you look in the !ReadMe file, it'll tell you how to contact me. I'll do
my best to answer you quickly and get you going, but obviously I can make no
promises.

Have fun.


