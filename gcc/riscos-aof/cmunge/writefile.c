/*
 * Copyright (C) 1999-2003 Robin Watts/Justin Fletcher
 */

#include <stdio.h>
#include <string.h>

#include "gfile.h"
#include "error.h"
#include "options.h"
#include "apcscli.h"

#include "copyright.h"

#include "VersionNum" /* CVS maintained version file */

/* Define this if you want the module header reducing if it would be 0s */
/* #define OPTIMISE_HEADERS */

/* Define this if you want to include a redundant fast service entry when
   no fast service entries have been defined, a la cmhg */
#define CMHG_REDUNDANT_FAST_SERVICE

/* Define this if you want to follow CMHG's positioning of the resource filename */
#define CMHG_RESOURCE_FILE_ORDERING

#ifdef OPTIMISE_HEADERS
/* Note: We can't optimse the headers if we're compiling as 32bit */
#define IF_OPTIMISED_HEADER(cond) if (cond && CODE26)
#else
#define IF_OPTIMISED_HEADER(cond) if (1)
#endif

/* Special ways we relocate ourselves to point at our special data */
#define ADD_Lib_Reloc \
"\t; This is equivalent of 'ADD r10, r10, #0' + |_Lib$Reloc$Off$DP|\n\
\tDCD\t|_Lib$Reloc$Off$DP| + &E28AA000\n"
#define ADD_Lib_Reloc_VC \
"\t; This is equivalent of 'ADDVC r10, r10, #0' + |_Lib$Reloc$Off$DP|\n\
\tDCD\t|_Lib$Reloc$Off$DP| + &728AA000\n"
#define SUB_Lib_Reloc \
"\t; This is equivalent of 'SUB r10, r10, #0' + |_Lib$Reloc$Off$DP|\n\
\tDCD\t|_Lib$Reloc$Off$DP| + &E24AA000\n"
#define SUB_Lib_Reloc_VC \
"\t; This is equivalent of 'SUBVC r10, r10, #0' + |_Lib$Reloc$Off$DP|\n\
\tDCD\t|_Lib$Reloc$Off$DP| + &724AA000\n"
#define SUB_Lib_Reloc_S \
"\t; This is equivalent of 'SUBS r10, r10, #0' + |_Lib$Reloc$Off$DP|\n\
\tDCD\t|_Lib$Reloc$Off$DP| + &E25AA000\n"

static FILE *file;

static int finalise_imported = 0;

static void outstring(const char *s,int terminate, char newline, int translate_underscore) {

  int inquote=0;
  int chars=0;

  while (*s || terminate)
  {
      char c=*s;
      if (!chars)
        fprintf(file, "\t= ");
      if (translate_underscore && c=='_')
        c = ' ';
      if ((c>31) && (c<127) && (c!='"') && (c!='\\' || s[1]!='\"')) {
        if (!inquote) {
          chars+=fprintf(file,chars?",\"":"\"");
          inquote=1;
        }
        fputc(c,file);
        chars++;
      } else {
        if (c=='\\')
          s++;
        if (inquote) {
          chars+=fprintf(file,"\"");
          inquote=0;
        }
        chars+=fprintf(file,"%s%u",chars?",":"",(int)(*s=='\n'?newline:(*s & 0xFF)));
      }
      if (*s)
        s++;
      else
        terminate=0;
      if ((chars>60)||!(*s||terminate))
      {
        if (inquote)
          fputc('"',file);
        fputc('\n',file);
        inquote=0;
        chars=0;
      }
  }
}

static void asm_header(void) {

  fprintf(file, "; Generated by CMunge " Module_FullVersionAndDate "\n");
  fprintf(file, "; CMunge " Copyright_CMunge "\n\n");
  if (opt.base) {
    fprintf(file, "\tIMPORT\t|Image$$RO$$Base|\n");
    fprintf(file, "\tEXPORT\tImage__RO_Base\n");
    fprintf(file, "\tAREA\tCode_Description, DATA, REL\n");
    fprintf(file, "Image__RO_Base\n");
    fprintf(file, "\tDCD\t|Image$$RO$$Base|\n\n");
  }
  if (opt.toolchain == tc_gcc ||
      opt.toolchain == tc_lcc)
  {
    fprintf(file, "\
        GBLL    UsingAS\n\
UsingAS SETL    {TRUE}\n");
  }
  fprintf(file, "\
; Some handy macros\n\
        GBLL    immediate\n\
        MACRO\n\
        Immediate $var\n\
immediate SETL  {FALSE}\n\
        LCLA    count\n\
        LCLA    varcopy\n\
varcopy SETA    $var\n\
        WHILE   count <= 30\n\
 [ ((varcopy:SHL:count) + (varcopy:SHR:(32-count))) :AND: (:NOT: &FF) = 0\n\
immediate SETL  {TRUE}\n\
        MEXIT\n\
 ]\n\
count   SETA    count + 2\n\
        WEND\n\
        MEND\n\
\n\
        MACRO\n\
$label  addr    $reg, $object, $cc\n\
    [ :DEF: UsingAS\n\
$label  ADR$cc.L $reg, $object\n\
    |\n\
        LCLA    value\n\
value   SETA    .-$object+8\n\
        Immediate &$value\n\
 [ immediate\n\
$label  ADR$cc  $reg, $object\n\
 |\n\
$label  ADR$cc.L $reg, $object\n\
 ]\n\
    ]\n\
        MEND\n\
\n\
");

  fprintf(file, "; Now the REAL module header\n");
  fprintf(file, "\tAREA\t|!Header$$code|, CODE, READONLY%s%s\n\n",
                 (opt.apcs & APCS_REENTRANT) ? ", PIC, REENTRANT" : "",
                 (opt.apcs & APCS_FPE3) ? ", FP3" : "");

  /* Things that everyone needs */
  fprintf(file, "\tIMPORT\t|_Lib$Reloc$Off$DP|\n");
}

static void mod_header(void) {

  if (opt.mode_errors)
    return;

  fprintf(file, "\tEXPORT\t__module_header\n");
  fprintf(file, "__module_header\n\n");

  fprintf(file, "_CMUNGE_origin\n");
  if (opt.runnable) {
    fprintf(file, "\tDCD\t_CMUNGE_start\t\t-_CMUNGE_origin\t; Start offset\n");
  } else {
    fprintf(file, "\tDCD\t0\t\t\t\t\t; Start offset\n");
  }
  fprintf(file, "\tDCD\t_CMUNGE_init\t\t-_CMUNGE_origin\t; Initialisation offset\n");
  fprintf(file, "\tDCD\t_CMUNGE_fin\t\t-_CMUNGE_origin\t; Finalisation offset\n");
  if (opt.service) {
    fprintf(file, "\tDCD\t_CMUNGE_service\t\t-_CMUNGE_origin\t; Service handler offset\n");
  } else {
    fprintf(file, "\tDCD\t0\t\t\t\t\t; Service handler offset\n");
  }
  fprintf(file, "\tDCD\t_CMUNGE_title\t\t-_CMUNGE_origin\t; Title string offset\n");
  fprintf(file, "\tDCD\t_CMUNGE_help\t\t-_CMUNGE_origin\t; Help string offset\n");

  if (opt.commands)
    fprintf(file, "\tDCD\t_CMUNGE_command\t\t-_CMUNGE_origin\t; Command table offset\n");
  else
    IF_OPTIMISED_HEADER(opt.swi_base || opt.swi_names || opt.swi_decoder || opt.mfile)
      fprintf(file, "\tDCD\t0\t\t\t; No commands specified\n");

  if (opt.swi_base) {
    fprintf(file, "\tDCD\t0x%08x\t\t\t\t; SWI chunk base number\n", opt.swi_base);
    fprintf(file, "\tDCD\t_CMUNGE_swi_handler\t-_CMUNGE_origin\t; SWI handler offset\n");
  } else {
    IF_OPTIMISED_HEADER(opt.swi_names || opt.swi_decoder || opt.mfile)
    {
      fprintf(file, "\tDCD\t0\t\t; SWI chunk base number\n");
      fprintf(file, "\tDCD\t0\t\t; SWI handler offset\n");
    }
  }
  if (opt.swi_names)
    fprintf(file, "\tDCD\t_CMUNGE_swi_table\t-_CMUNGE_origin\t; SWI table offset\n");
  else
    IF_OPTIMISED_HEADER(opt.swi_decoder || opt.mfile)
      fprintf(file, "\tDCD\t0\t\t\t; SWI table offset\n");
  if (opt.swi_decoder)
    fprintf(file, "\tDCD\t_CMUNGE_swi_decoder\t-_CMUNGE_origin\t; SWI decoding code offset\n");
  else
    IF_OPTIMISED_HEADER(opt.mfile)
      fprintf(file, "\tDCD\t0\t\t\t; SWI decoding code offset\n");
  if (opt.mfile)
    fprintf(file, "\tDCD\t_CMUNGE_message_file\t-_CMUNGE_origin\t; Message file filename offset\n");
  else
  {
    IF_OPTIMISED_HEADER(opt.mfile)
      fprintf(file, "\tDCD\t0\t\t\t; Message file filename offset\n");
  }
  if (CODE26)
  {}
  else
    fprintf(file, "\tDCD\t_CMUNGE_module_flags\t-_CMUNGE_origin\t; Module flags offset\n");
}

static void strings(void) {

  if (opt.mode_errors)
    return;

  fprintf(file, "_CMUNGE_title\n");
  outstring(opt.title,1,'\n',0);
  fprintf(file, "_CMUNGE_help\n");
  outstring(opt.help,1,'\n',1);
#ifndef CMHG_RESOURCE_FILE_ORDERING
  if (opt.mfile) {
    fprintf(file, "\tALIGN\n");
    fprintf(file, "_CMUNGE_message_file\n");
    outstring(opt.mfile,1,'\n',0);
  }
#endif
}

static void swi_table(void) {

  swi_list l;

  if (!opt.swi_names)
    return;
  l = opt.swi_names;
  fprintf(file, "_CMUNGE_swi_table\n");
  while (l) {
    fprintf(file, "\t= \"%s\",0\n", l->name);
    l = l->next;
  }
  fprintf(file, "\t= 0\n");
}

static void commands(void) {

/* JRF: 32bit'd */
  help_list l;
  int n;
  int info;

  /* FIXME: Help entries can be commands - should work; or at least mirror CHMG */
  if (!opt.commands)
    return;
  l = opt.commands;
  n = 0;
  while (l) {
    if (l->help_text) {
      fprintf(file, "_CMUNGE_ht%d\n", n);
      if ((l->invalid_syntax) && (l->add_syntax))
        outstring(l->help_text,0,'\r',0);
      else
        outstring(l->help_text,1,'\r',0);
    }
    if (l->invalid_syntax) {
      fprintf(file, "_CMUNGE_is%d\n", n);
      outstring(l->invalid_syntax,1,'\r',0);
    }
    l = l->next;
    n++;
  }
  l = opt.commands;
  n = 0;
  fprintf(file, "\tALIGN\n");
  fprintf(file, "_CMUNGE_command\n");
  while (l) {
    fprintf(file, "\t= \"%s\",0\n", l->name);
    fprintf(file, "\tALIGN\n");
    fprintf(file, "\tDCD\t_CMUNGE_ce%d\t- _CMUNGE_origin\n", n);
    info = l->min_args | (l->max_args<<16) | (l->gstrans<<8) |
           (l->fs_command ? (1U<<31) : 0) | (l->status ? (1<<30) : 0) |
           (l->configure ? (1<<30) : 0) | (l->help ? (1<<29) : 0) |
           (l->international ? (1<<28) : 0);
    fprintf(file, "\tDCD\t0x%08x\n", info);
    if (l->invalid_syntax)
      fprintf(file, "\tDCD\t_CMUNGE_is%d\t- _CMUNGE_origin\n", n);
    else
      fprintf(file, "\tDCD\t0\n");
    if (l->help_text)
      fprintf(file, "\tDCD\t_CMUNGE_ht%d\t- _CMUNGE_origin\n", n);
    else
      fprintf(file, "\tDCD\t0\n");
    l = l->next;
    n++;
  }
  /* CMHG *doesn't* output the following, because the low byte of the next */
  /* instruction is 0. Hacky or what? For compatibility I'll do the same. */
  //fprintf(file, "\tDCD\t0\n");
  l = opt.commands;
  n = 0;
  while (l) {
    fprintf(file, "_CMUNGE_ce%d\n", n);
    fprintf(file, "\tMOV\tr2,#%d\n", n);
    l = l->next;
    n++;
    if (l)
      fprintf(file, "\tB\t_CMUNGE_ce\n");
  }
  fprintf(file, "_CMUNGE_ce\n");
  fprintf(file, "\tSTMDB\tr13!,{r0,r10,r11,r14}\n");
  fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
  fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
  fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tMOV\tr3,r12\n");
  fprintf(file, "\tLDR\tr12,[r12]\n");
  fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
  fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
  fprintf(file, ADD_Lib_Reloc);
  fprintf(file, "\tMOV\tr11,#0\n");
  if (opt.swi_codesupplied)
  {
    help_list l;
    int numcoms=0;

    l = opt.commands;
    while (l)
    {
      numcoms++;
      l=l->next;
    }
    fprintf(file, "\tMOV\tr14,pc\n");
    fprintf(file, "\tADD\tr14,r14,# _CMUNGE_com_ret - _CMUNGE_com_pc\n");
    fprintf(file, "_CMUNGE_com_pc\n");
    fprintf(file, "\tCMP\tr2,#%i\n",numcoms);
    fprintf(file, "\tADDLT\tpc,pc,r2,LSL #2\n");
    if (opt.helpfn)
    {
      fprintf(file, "\tIMPORT\t%s\n", opt.helpfn);
      fprintf(file, "\tB\t%s\n", opt.helpfn);
    }
    else
      fprintf(file, "\tB\t_CMUNGE_nocom_handler\n");

    l = opt.commands;
    while (l)
    {
      if (l->handler)
      {
        fprintf(file, "\tIMPORT\t%s\n", l->handler);
        fprintf(file, "\tB\t%s\n", l->handler);
      }
      else
      {
        if (opt.commands)
          fprintf(file, "\tB\t%s\n", opt.helpfn);
        else
          fprintf(file, "\tB\t_CMUNGE_nocom_handler\n");
      }
      l=l->next;
    }
    if (!opt.helpfn)
    {
      fprintf(file, "_CMUNGE_nocom_handler\n");
      fprintf(file, "\tMOV\tr0,#0\n"); /* no error (wrong!) */
    }
    fprintf(file, "_CMUNGE_com_ret\n");
  }
  else
  {
    fprintf(file, "\tIMPORT\t%s\n", opt.helpfn);
    fprintf(file, "\tBL\t%s\n", opt.helpfn);
  }
  fprintf(file, SUB_Lib_Reloc);
  fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tLDMIA\tr13!,{r1,r10,r11,r14}\n");
  fprintf(file, "\tCMP\tr1,r0\n");
  fprintf(file, "\tCMPNE\tr0,#0\n");
  if (CODE26)
    fprintf(file, "\tBICEQS\tpc,r14,#0x10000000\n");
  else
    fprintf(file, "\tMOVEQ\tpc,r14\n");
  fprintf(file, "\tCMN\tr0,#1\n");
  fprintf(file, "\tMOVEQ\tr0,#0\n");
  if (CODE26)
    fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
  else
  {
    fprintf(file, "\tMOV\tr1,#0\n");
    fprintf(file, "\tCMP\tr1,#1<<31\n");
    fprintf(file, "\tMOV\tpc,r14\n");
  }
}

static unsigned int representable(unsigned int i) {

  unsigned int mask;

  mask = 255;
  while (((i & mask) & ~(mask<<2)) == 0)
    mask = (mask << 2) | (mask >> 30);
  return i & mask;
}

static void service(void) {

/* JRF: 32bit */
  unsigned int n, m;
  int_list l;
  int big;
  int first;

  if (!opt.service)
    return;
  fprintf(file, "\tALIGN\n");
  if (opt.services) {
    unsigned int min = 0;
    unsigned int found;

    fprintf(file, "_CMUNGE_service_fast\n");
    fprintf(file, "\tDCD\t0\n");
    fprintf(file, "\tDCD\t_CMUNGE_service_fast_entry\t- _CMUNGE_origin\n");
    /* List services in ascending order */
    do {
      found = 0;
      for (l = opt.services; l; l = l->next)
      {
        if (l->val > min && ((l->val < found) || (found == 0)))
          found = l->val;
      }
      fprintf(file, "\tDCD\t0x%08x\n", found);
      min = found;
    } while (found);
    fprintf(file, "\tDCD\t_CMUNGE_service_fast\t\t- _CMUNGE_origin\n");
    fprintf(file, "_CMUNGE_service\n");
    fprintf(file, "\tMOV\tr0,r0\n");
  }
  else
  {
#ifdef CMHG_REDUNDANT_FAST_SERVICE
    fprintf(file, "\tDCD\t0\n");
    fprintf(file, "_CMUNGE_service\n");
    fprintf(file, "\tMOV\tr0,r0\n");
#else
    fprintf(file, "_CMUNGE_service\n");
#endif
  }

  if (opt.services) {
    /* Do we have any 'big' numbers? */
    big = 0;
    for (l = opt.services; l; l = l->next) {
      if (representable(l->val) != l->val) {
        big = 1;
        break;
      }
    }
    /* Now the rejection code */
    if (big) {
      fprintf(file, "\tSTR\tr14,[r13,#-4]!\n");
    }
    l = opt.services;
    first = 1;
    while (l) {
      n = l->val;
      m = representable(n);
      if (n == m) {
        if (first)
          fprintf(file, "\tTEQ\tr1,#0x%02x\n", n);
        else
          fprintf(file, "\tTEQNE\tr1,#0x%02x\n", n);
      } else {
        fprintf(file, "\tMOV\tr14,#0x%02x\n", m);
        n &= ~m;
        do {
          m = representable(n);
          fprintf(file, "\tORR\tr14,r14,#0x%02x\n", m);
          n &= ~m;
        } while (n);
        if (first)
          fprintf(file, "\tTEQ\tr1,r14\n");
        else
          fprintf(file, "\tTEQNE\tr1,r14\n");
      }
      l = l->next;
      first = 0;
    }
    if (big) {
      if (CODE26)
        fprintf(file, "\tLDMNEIA\tr13!,{pc}^\n");
      else
        fprintf(file, "\tLDMNEIA\tr13!,{pc}\n");
      /* CMHG is inefficient here, but I'll match it */
      fprintf(file, "\tLDR\tr14,[r13],#4\n");
    } else {
      if (CODE26)
        fprintf(file, "\tMOVNES\tpc,r14\n");
      else
        fprintf(file, "\tMOVNE\tpc,r14\n");
    }
  }
  fprintf(file, "_CMUNGE_service_fast_entry\n");
  fprintf(file, "\tSTMDB\tr13!,{r0-r11,r14}\n");
  fprintf(file, "\tMOV\tr0,r1\n");
  fprintf(file, "\tMOV\tr1,r13\n");
  if (CODE26)
  {
    fprintf(file, "\tMOV\tr6,pc\n");
    fprintf(file, "\tBIC\tr3,r6,#3\n");
    fprintf(file, "\tTEQP\tr3,#3\n");
  }
  else
  {
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tMOVNE    r8,pc\n");
    fprintf(file, "\tBICNE    r3,r8,#3\n");
    fprintf(file, "\tTEQNEP   r3,#3\n");
    fprintf(file, "\tMRSEQ    r6,cpsr\n");
    fprintf(file, "\tORREQ    r3,r6,#3\n");
    fprintf(file, "\tMSREQ    cpsr_ctl,r3\n");
  }
  fprintf(file, "\tMOV\tr11,#0\n");
  fprintf(file, "\tMOV\tr7,r14\n");
  fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
  fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
  fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tMOV\tr2,r12\n");
  fprintf(file, "\tLDR\tr12,[r12,#0]\n");
  if (CODE26)
  {
    fprintf(file, "\tLDMIB\tr12,{r8,r9}\n");
    fprintf(file, "\tSTMIA\tr10,{r8,r9}\n");
  }
  else
  {
    fprintf(file, "\tLDMIB\tr12,{r12,r14}\n");
    fprintf(file, "\tSTMIA\tr10,{r12,r14}\n");
  }
  fprintf(file, ADD_Lib_Reloc);
  fprintf(file, "\tIMPORT\t%s\n", opt.service);
  fprintf(file, "\tBL\t%s\n", opt.service);
  fprintf(file, "\tMOV\tr14,r7\n");
  if (CODE26)
  {
    fprintf(file, "\tTEQP\tr6,#0\n");
  }
  else
  {
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tMSREQ    cpsr_ctl,r6\n");
    fprintf(file, "\tTEQNEP   r8,#0\n");
  }
  fprintf(file, SUB_Lib_Reloc);
  fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
  if (CODE26)
    fprintf(file, "\tLDMIA\tr13!,{r0-r11,pc}^\n");
  else
    fprintf(file, "\tLDMIA\tr13!,{r0-r11,pc}\n");
}

static void start(void) {

  if (opt.runnable) {
    fprintf(file, "_CMUNGE_start\n");
    switch (opt.runnable)
    {
      case run_blib:
      case run_clib:
        {
          char *routine;
          if (opt.runnable == run_blib)
            routine="_blib_entermodule";
          else
            routine="_clib_entermodule";

          fprintf(file, "\tIMPORT\t%s\n",routine);
          fprintf(file, "\tB\t%s\n",routine);
        }
        break;

      case run_rmaapp_simple: /* an incredibly simple task using RMA space */
        fprintf(file,"OS_Module * 30\n");
        fprintf(file,"OS_Exit * 17\n");
        fprintf(file,"OS_GenerateError * 43\n");
        fprintf(file,"\n");
        fprintf(file,"\tIMPORT\t|__root_stack_size|, WEAK\n");
        fprintf(file,"\tIMPORT\tmain\n");
        fprintf(file,"\tEXPORT\t_CMUNGE_stack\n");
        fprintf(file,"\tMOV\tv1,r0 \t; Save command tail\n");
        fprintf(file,"\tLDR\tr12,[r12]\t; Workspace ptr from private word\n");
        fprintf(file,"\tLDMIB\tr12,{v2,v3}\t; Module relocations\n");
        fprintf(file,"\tLDR\tv4,_CMUNGE_stackptr\t; A Ptr to stack variable\n");
        fprintf(file,"\tADD\tv4,v4,v3\t; gets relocated for user variable\n");
        fprintf(file,"\tLDR\tr0,[v4]\t; stack chunk\n");
        fprintf(file,"\tTEQ\tr0,#0\t; is it 0 ?\n");
        fprintf(file,"\tBNE\t_CMUNGE_apprunning\t; if not, there's a stack already\n");
        fprintf(file,"\tMOV\tr0,#6\n");
        fprintf(file,"\tLDR\tr3, =|__root_stack_size|\n");
        fprintf(file,"\tTEQ\tr3, #0\n");
        fprintf(file,"\tMOVEQ\tr3,#8192\t; default stack size\n");
        fprintf(file,"\tSWI\tOS_Module\n");
        fprintf(file,"\tMOV\tsl,r2\n");
        fprintf(file,"\tSTR\tsl,[v4]\n");
        fprintf(file,"\tADD\tsp,sl,r3\n");
        fprintf(file,"\tSTMIA\tsl,{v2,v3}\n");
        fprintf(file,"\n");
        fprintf(file,"" ADD_Lib_Reloc "");
        fprintf(file,"\n");
        fprintf(file,"\tMOV\tfp,#0\n");
        fprintf(file,"\tMOV\ta1,v1\n");
        fprintf(file,"\tBL\tmain\n");
        fprintf(file,"\n");
        fprintf(file,"" SUB_Lib_Reloc "");
        fprintf(file,"\n");
        fprintf(file,"\tMOV\tv1,r0\n");
        fprintf(file,"\n");
        fprintf(file,"\tMOV\tr2,sl\n");
        fprintf(file,"\tMOV\tr0,#7\n");
        fprintf(file,"\tSWI\tOS_Module\n");
        fprintf(file,"\tMOV\tr0,#0\n");
        fprintf(file,"\tSTR\tr0,[v4]\n");
        fprintf(file,"\n");
        fprintf(file,"\tMOV\tr0,v1\t; FIXME: this is wrong - it's ShareFS code\n");
        fprintf(file,"\tSWI\tOS_Exit\n");
        fprintf(file,"\n");
        fprintf(file,"_CMUNGE_freeappstack\n");
        fprintf(file,"\tSTMFD\tsp!,{r0-r4,r14}\n");
        fprintf(file,"\tLDR\tr4,_CMUNGE_stackptr\t; A Ptr to stack variable\n");
        fprintf(file,"\tLDR\tr3,[sl,#-536]\n");
        fprintf(file,"\tADD\tr4,r4,r3\t; gets relocated for user variable\n");
        fprintf(file,"\tLDR\tr2,[r4]\t; stack chunk pointer\n");
        fprintf(file,"\tTEQ\tr2,#0\t; is it allocated ?\n");
        fprintf(file,"\tMOVNE\tr0,#7\t; if so, free it\n");
        fprintf(file,"\tSWINE\tOS_Module\n");
        fprintf(file,"\tMOV\tr0,#0\n");
        fprintf(file,"\tSTR\tr0,[r4]\n");
        if (CODE26)
          fprintf(file,"\tLDMFD\tsp!,{r0-r4,pc}^\n");
        else
        {
          fprintf(file,"\tCMP\tpc,#0\t; clear V\n");
          fprintf(file,"\tLDMFD\tsp!,{r0-r4,pc}^\n");
        }
        fprintf(file,"\n");
        fprintf(file,"_CMUNGE_stackptr\n");
        fprintf(file,"\tDCD\t_CMUNGE_stack\n");
        fprintf(file,"\n");
        fprintf(file,"_CMUNGE_apprunning\n");
        fprintf(file,"\tADR\tr0,_CMUNGE_apprunning_error\n");
        fprintf(file,"\tSWI\tOS_GenerateError\n");
        fprintf(file,"_CMUNGE_apprunning_error\n");
        fprintf(file,"\tDCD 0\t; FIXME: This is a bad error number to use\n");
        fprintf(file,"\t= \"%s already running\",0\n", opt.title);
        fprintf(file,"\tALIGN\n");
        break;

      default:
        ErrorFatal("Start code type confusion");
    }
  }
}

static void init(void) {

/* JRF: 32bit ok */
  if (opt.mode_errors)
    return;

  fprintf(file, "\n\tALIGN\n");
  fprintf(file, "_CMUNGE_init\n");
  fprintf(file, "\tSTMFD\tr13!,{r7-r11,r14}\n");
  fprintf(file, "\tMOV\tr0,#%i\n",opt.reentrant ? 1 : 0);
  if (opt.lib_init) {
    fprintf(file, "\tIMPORT\t%s\n", opt.lib_init);
    fprintf(file, "\tBL\t%s\n", opt.lib_init);
  } else {
    fprintf(file, "\tIMPORT\t_clib_initialisemodule\n");
    fprintf(file, "\tBL\t_clib_initialisemodule\n");
  }
  if (!opt.init && !opt.cplusplus) {
    fprintf(file, "\tLDMIA\tr13!,{r7-r11,pc}\n");
  } else {
    if (CODE26)
    {
      fprintf(file, "\tLDMVSIA\tr13!,{r7-r11,pc}\n");
      fprintf(file, "\tMOV\tr6,r0\n");
      fprintf(file, SUB_Lib_Reloc);
      fprintf(file, "\tLDMIA\tr10,{r0,r1}\n");
      fprintf(file, "\tSUB\tr10,r10,#0x14\n");
      fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
      fprintf(file, "\tSTMIA\tr10,{r0,r1}\n");
      fprintf(file, ADD_Lib_Reloc);
      fprintf(file, "\tMOV\tr11,#0\n");
      if (opt.cplusplus)
      {
        fprintf(file, "\tIMPORT\t______main\n");
        fprintf(file, "\tBL\t______main\n");
      }
      if (opt.init)
      {
        fprintf(file, "\tADD\tr0,r13,#0xc\n");
        fprintf(file, "\tLDMIA\tr0,{r0,r1}\n");
        fprintf(file, "\tMOV\tr2,r6\n");
        fprintf(file, "\tIMPORT\t%s\n", opt.init);
        fprintf(file, "\tBL\t%s\n", opt.init);
        fprintf(file, "\tTEQ\tr0,#0\n");
        fprintf(file, "\tBEQ\t_CMUNGE_init_10\n");
        fprintf(file, "\tSTR\tr0,[r13,#-4]!\n");
        fprintf(file, "\tMOV\tr0,r6\n");
        if (!finalise_imported)
          fprintf(file, "\tIMPORT\t_clib_finalisemodule\n"), finalise_imported = 1;
        fprintf(file, "\tBL\t_clib_finalisemodule\n");
        fprintf(file, "\tLDR\tr0,[r13],#4\n");
        fprintf(file, "_CMUNGE_init_10\n");
        fprintf(file, SUB_Lib_Reloc);
        fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
        fprintf(file, "\tTEQ\tr0,#0\n");
        fprintf(file, "\tLDMEQIA\tr13!,{r7-r11,pc}^\n");
        fprintf(file, "\tLDMIA\tr13!,{r7-r11,r14}\n");
        fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
      }
      else
      {
        fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
        fprintf(file, "\tLDMIA\tr13!,{r7-r11,pc}^\n");
      }
    }
    else
    {
      fprintf(file, "\tLDMVSIA\tr13!,{r7-r11,pc}\n");
      fprintf(file, "\tMOV\tr6,r0\n");
      fprintf(file, SUB_Lib_Reloc);
      fprintf(file, "\tLDMIA\tr10,{r0,r1}\n");
      fprintf(file, "\tSUB\tr10,r10,#0x14\n");
      fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
      fprintf(file, "\tSTMIA\tr10,{r0,r1}\n");
      fprintf(file, ADD_Lib_Reloc);
      fprintf(file, "\tMOV\tr11,#0\n");
      if (opt.cplusplus)
      {
        fprintf(file, "\tIMPORT\t______main\n");
        fprintf(file, "\tBL\t______main\n");
      }
      if (opt.init)
      {
        fprintf(file, "\tADD\tr0,r13,#0xc\n");
        fprintf(file, "\tLDMIA\tr0,{r0,r1}\n");
        fprintf(file, "\tMOV\tr2,r6\n");
        fprintf(file, "\tIMPORT\t%s\n", opt.init);
        fprintf(file, "\tBL\t%s\n", opt.init);
        fprintf(file, "\tTEQ\tr0,#0\n");
        fprintf(file, "\tBEQ\t_CMUNGE_init_10\n");
        fprintf(file, "\tSTR\tr0,[r13,#-4]!\n");
        fprintf(file, "\tMOV\tr0,r6\n");
        if (!finalise_imported)
          fprintf(file, "\tIMPORT\t_clib_finalisemodule\n"), finalise_imported = 1;
        fprintf(file, "\tBL\t_clib_finalisemodule\n");
        fprintf(file, "\tLDR\tr0,[r13],#4\n");
        fprintf(file, "_CMUNGE_init_10\n");
        fprintf(file, SUB_Lib_Reloc);
        fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
        fprintf(file, "\tCMP\tr0,#0\n");
        fprintf(file, "\tMOVNE\tr1,#0\n");
        fprintf(file, "\tCMPNE\tr1,#1<<31\n");
        fprintf(file, "\tLDMIA\tr13!,{r7-r11,pc}\n");
      }
      else
      {
        fprintf(file, "\tCMP\tr0,r0\n"); /* Clear V */
        fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
        fprintf(file, "\tLDMIA\tr13!,{r7-r11,pc}\n");
      }
    }
  }
}

static void final(void) {

  if (opt.mode_errors)
    return;

  fprintf(file, "_CMUNGE_fin\n");
  if (opt.final) {
    /* JRF: 32bit ok */
    fprintf(file, "\tSTMDB\tr13!,{r7-r12,r14}\n");
    fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
    fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
    fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
    fprintf(file, "\tLDR\tr12,[r12,#0]\n");
    fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
    fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
    fprintf(file, ADD_Lib_Reloc);
    fprintf(file, "\tMOV\tr11,#0\n");
    fprintf(file, "\tADD\tr0,r13,#0xc\n");
    fprintf(file, "\tLDMIA\tr0,{r0-r2}\n");
    fprintf(file, "\tIMPORT\t%s\n", opt.final);
    fprintf(file, "\tBL\t%s\n", opt.final);
    fprintf(file, "\tCMP\tr0,#0\n");
    if (CODE26)
    {
      fprintf(file, "\tLDREQ\tr0,[r13,#0x14]\n");
      if (!finalise_imported)
        fprintf(file, "\tIMPORT\t_clib_finalisemodule\n"), finalise_imported = 1;
      fprintf(file, "\tBLEQ\t_clib_finalisemodule\n");
      if (opt.runnable == run_rmaapp_simple)
        fprintf(file,"\tBLEQ\t_CMUNGE_freeappstack\n");
    }
    else
    {
      fprintf(file, "\tBNE\t_CMUNGE_final_10\n");
      fprintf(file, "\tLDR\tr0,[r13,#0x14]\n");
      if (!finalise_imported)
        fprintf(file, "\tIMPORT\t_clib_finalisemodule\n"), finalise_imported = 1;
      fprintf(file, "\tBL\t_clib_finalisemodule\n");
      if (opt.runnable == run_rmaapp_simple)
        fprintf(file,"\tBL\t_CMUNGE_freeappstack\n");
      fprintf(file, "\tMOVS\tr0,#0\n");
      fprintf(file,"_CMUNGE_final_10\n");
    }
    fprintf(file, SUB_Lib_Reloc);
    fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
    if (CODE26)
    {
      fprintf(file, "\tLDMEQIA\tr13!,{r7-r12,pc}^\n");
      fprintf(file, "\tLDMIA\tr13!,{r7-r12,r14}\n");
      fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
    }
    else
    {
      fprintf(file, "\tMOVNE\tr1,#0\n");
      fprintf(file, "\tCMPNE\tr1,#1<<31\n");
      fprintf(file, "\tLDMIA\tr13!,{r7-r12,pc}\n");
    }
  } else {
    fprintf(file, "\tSTMDB\tr13!,{r7-r11,r14}\n");
    fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
    fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
    fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
    fprintf(file, "\tMOV\tr0,r12\n");
    fprintf(file, "\tLDR\tr12,[r12]\n");
    fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
    fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
    fprintf(file, ADD_Lib_Reloc);
    fprintf(file, "\tMOV\tr11,#0\n");
    if (!finalise_imported)
      fprintf(file, "\tIMPORT\t_clib_finalisemodule\n"), finalise_imported = 1;
    fprintf(file, "\tBL\t_clib_finalisemodule\n");
    if (opt.runnable == run_rmaapp_simple)
      fprintf(file,"\tBLVC\t_CMUNGE_freeappstack\n");
    if (CODE26)
      fprintf(file, SUB_Lib_Reloc);
    else
      fprintf(file, SUB_Lib_Reloc_S);
    fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
    if (CODE26)
      fprintf(file, "\tLDMIA\tr13!,{r7-r11,pc}^\n");
    else
      fprintf(file, "\tLDMIA\tr13!,{r7-r11,pc}\n");
  }
}

static void swi_handler(void) {

  /* JRF: 32bit ok */
  if (!opt.swi_base)
    return;
  fprintf(file, "\tALIGN\n");
  fprintf(file, "_CMUNGE_swi_handler\n");
  fprintf(file, "\tSTMDB\tr13!,{r0-r9,r14}\n");
  if (CODE26)
  {}
  else
    fprintf(file, "\tMRS\tr8,cpsr\n");
  fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
  fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
  fprintf(file, "\tMOV\tr0,r11\n");
  fprintf(file, "\tMOV\tr1,r13\n");
  fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tMOV\tr2,r12\n");
  fprintf(file, "\tLDR\tr12,[r12]\n");
  fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
  fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
  fprintf(file, ADD_Lib_Reloc);
  fprintf(file, "\tMOV\tr11,#0\n");
  if (opt.swi_codesupplied)
  {
    swi_list l;
    int numswis=0;

    l = opt.swi_names->next; /* First one must be valid */
    while (l)
    {
      numswis++;
      l=l->next;
    }
    fprintf(file, "\tMOV\tr14,pc\n");
    fprintf(file, "\tADD\tr14,r14,# _CMUNGE_swi_ret - _CMUNGE_swi_pc\n");
    fprintf(file, "_CMUNGE_swi_pc\n");
    fprintf(file, "\tCMP\tr0,#%i\n",numswis);
    fprintf(file, "\tADDLT\tpc,pc,r0,LSL #2\n");
    if (opt.swi_handler)
    {
      fprintf(file, "\tIMPORT\t%s\n", opt.swi_handler);
      fprintf(file, "\tB\t%s\n", opt.swi_handler);
    }
    else
      fprintf(file, "\tB\t_CMUNGE_noswi_handler\n");

    l = opt.swi_names->next; /* First one must be valid */
    while (l)
    {
      if (l->handler)
      {
        fprintf(file, "\tIMPORT\t%s\n", l->handler);
        fprintf(file, "\tB\t%s\n", l->handler);
      }
      else
      {
        if (opt.swi_handler)
          fprintf(file, "\tB\t%s\n", opt.swi_handler);
        else
          fprintf(file, "\tB\t_CMUNGE_noswi_handler\n");
      }
      l=l->next;
    }
    if (!opt.swi_handler)
    {
      fprintf(file, "_CMUNGE_noswi_handler\n");
      fprintf(file, "\tMOV\tr0,#-1\n"); /* 'SWI not known' */
    }
    fprintf(file, "_CMUNGE_swi_ret\n");
  }
  else
  {
    fprintf(file, "\tIMPORT\t%s\n", opt.swi_handler);
    fprintf(file, "\tBL\t%s\n", opt.swi_handler);
  }
  fprintf(file, SUB_Lib_Reloc);
  fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tTEQ\tr0,#0\n");
  if (CODE26)
    fprintf(file, "\tLDMEQIA\tr13!,{r0-r9,pc}^\n");
  else
  {
    fprintf(file, "\tBNE      _CMUNGE_swi_10\n");
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tLDMNEIA  r13!,{r0-r9,pc}^\n");
    fprintf(file, "\tDCD &e12ff008 ; MSR cpsr_cxsf,r8\n");
    fprintf(file, "\tLDMIA    r13!,{r0-r9,pc}\n");
    fprintf(file, "_CMUNGE_swi_10\n");
  }
  fprintf(file, "\tADD\tr13,r13,#4\n");
  fprintf(file, "\tCMN\tr0,#1\n");
  if (CODE26)
  {
    fprintf(file, "\tLDMNEIA\tr13!,{r1-r9,r14}\n");
    fprintf(file, "\tORRNES\tpc,r14,#0x10000000\n");
  }
  else
  {
    fprintf(file, "\tBEQ      _CMUNGE_swi_30\n");
    fprintf(file, "_CMUNGE_swi_20\n");
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tLDMNEIA  r13!,{r1-r9,r14}\n");
    fprintf(file, "\tORRNES   pc,r14,#0x10000000\n");
    fprintf(file, "\tORR      r8,r8,#0x10000000\n");
    fprintf(file, "\tDCD &e12ff008 ; MSR cpsr_cxsf,r8\n");
    fprintf(file, "\tLDMIA    r13!,{r1-r9,pc}\n");
    fprintf(file, "_CMUNGE_swi_30\n");
  }
  fprintf(file, "\tADR\tr0,_CMUNGE_sht\n");
  fprintf(file, "\tMOV\tr1,#0\n");
  fprintf(file, "\tMOV\tr2,#0\n");
  fprintf(file, "\taddr\tr4,_CMUNGE_title\n");
  fprintf(file, "\tSWI\t0x61506 ; XMessageTrans_ErrorLookup\n");
  if (CODE26)
    fprintf(file, "\tLDMIA\tr13!,{r1-r9,pc}\n");
  else
    fprintf(file, "\tB\t_CMUNGE_swi_20\n");
  fprintf(file, "_CMUNGE_sht\n");
  fprintf(file, "\tDCD\t&1e6\n");
  fprintf(file, "\t= \"BadSWI\",0\n");
  fprintf(file, "\tALIGN\n");
}

static void swi_decoder(void) {

  if (!opt.swi_decoder)
    return;
  fprintf(file, "\tALIGN\n");
  fprintf(file, "_CMUNGE_swi_decoder\n");
  if (opt.swi_decoder->handler) {
    fprintf(file, "\tSTMDB\tr13!,{r0-r3,r10,r11,r14}\n");
    fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
    fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
    fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
    fprintf(file, "\tLDR\tr14,[r12]\n");
    fprintf(file, "\tLDMIB\tr14,{r11,r14}\n");
    fprintf(file, "\tSTMIA\tr10,{r11,r14}\n");
    fprintf(file, ADD_Lib_Reloc);
    fprintf(file, "\tMOV\tr11,#0\n");
    fprintf(file, "\tCMP\tr0,#0\n");
    fprintf(file, "\tBGE\t_CMUNGE_sd1\n");
    fprintf(file, "\tMOV\tr0,r1\n");
    fprintf(file, "\tMOV\tr1,r12\n");
    fprintf(file, "\tIMPORT\t%s\n", opt.swi_decoder->name);
    fprintf(file, "\tBL\t%s\n", opt.swi_decoder->name);
    fprintf(file, "\tSTR\tr0,[r13,#0]\n");
    fprintf(file, "\tB\t_CMUNGE_sd2\n");
    fprintf(file, "_CMUNGE_sd1\n");
    fprintf(file, "\tSTMDB\tr13!,{r12}\n");
    fprintf(file, "\tIMPORT\t%s\n", opt.swi_decoder->handler);
    fprintf(file, "\tBL\t%s\n", opt.swi_decoder->handler);
    fprintf(file, "\tADD\tr13,r13,#4\n");
    fprintf(file, "\tSTR\tr0,[r13,#8]\n");
    fprintf(file, "_CMUNGE_sd2\n");
    if (CODE26)
      fprintf(file, SUB_Lib_Reloc);
    else
      fprintf(file, SUB_Lib_Reloc_S);
    fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
    if (CODE26)
      fprintf(file, "\tLDMIA\tr13!,{r0-r3,r10,r11,pc}^\n");
    else
      fprintf(file, "\tLDMIA\tr13!,{r0-r3,r10,r11,pc}\n");
  } else {
    fprintf(file, "\tSTMDB\tr13!,{r0-r3,r10,r11,r14}\n");
    fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
    fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
    fprintf(file, "\tMOV\tr0,r13\n");
    fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
    fprintf(file, "\tMOV\tr1,r12\n");
    fprintf(file, "\tLDR\tr12,[r12]\n");
    fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
    fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
    fprintf(file, ADD_Lib_Reloc);
    fprintf(file, "\tMOV\tr11,#0\n");
    fprintf(file, "\tIMPORT\t%s\n", opt.swi_decoder->name);
    fprintf(file, "\tBL\t%s\n", opt.swi_decoder->name);
    if (CODE26)
      fprintf(file, SUB_Lib_Reloc);
    else
      fprintf(file, SUB_Lib_Reloc_S);
    fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
    if (CODE26)
      fprintf(file, "\tLDMIA\tr13!,{r0-r3,r10,r11,pc}^\n");
    else
      fprintf(file, "\tLDMIA\tr13!,{r0-r3,r10,r11,pc}\n");
  }
}

static void veneers(void) {

  int n;
  int first;
  handler_list l;
  int_list il;

  first = 1;
  n = 0;
  /* Events */
  l = opt.events;
  while (l)
  {
    if (!first)
      fprintf(file, "\tB\t_CMUNGE_ve\n");
    fprintf(file, "\tEXPORT\t%s\n", l->name);
    fprintf(file, "%s\n", l->name);
    /* Output the event list */
    if (l->extradata) {
      int firstteq;
      il = (int_list)l->extradata;
      firstteq = 1;
      while (il) {
        if (firstteq) {
          fprintf(file, "\tTEQ\tr0,#%d\n", il->val);
        } else {
          fprintf(file, "\tTEQNE\tr0,#%d\n", il->val);
        }
        il = il->next;
        firstteq = 0;
      }
      if (CODE26)
      {
        fprintf(file, "\tMOVNES\tpc,r14\n");
      }
      else
      {
        fprintf(file, "\tMOVNE\tpc,r14\n");
      }
      l=l->next;
    }
    fprintf(file, "\tSTMDB\tr13!,{r0-r11,r14}\n");
    fprintf(file, "\tMOV\tr2,#%d\n", n);
    n += 4;
    first = 0;
  }

  /* Vectors */
  l = opt.vectors;
  while (l) {
    if (!first)
      fprintf(file, "\tB\t_CMUNGE_ve\n");
    fprintf(file, "\tEXPORT\t%s\n", l->name);
    fprintf(file, "%s\n", l->name);
    fprintf(file, "\tSTMDB\tr13!,{r0-r11,r14}\n");
    fprintf(file, "\tMOV\tr2,#%d\n", n);
    l = l->next;
    n += 4;
    first = 0;
  }
  /* Irqs */
  l = opt.irqs;
  while (l) {
    if (!first)
      fprintf(file, "\tB\t_CMUNGE_ve\n");
    fprintf(file, "\tEXPORT\t%s\n", l->name);
    fprintf(file, "%s\n", l->name);
    fprintf(file, "\tSTMDB\tr13!,{r0-r11,r14}\n");
    fprintf(file, "\tMOV\tr2,#%d\n", n);
    l = l->next;
    n += 4;
    first = 0;
  }
  if (n == 0)
    return;
  fprintf(file, "_CMUNGE_ve\n");
  fprintf(file, "\tMOV\tr0,r13\n");
  if (CODE26)
  {
    fprintf(file, "\tMOV\tr6,pc\n");
    fprintf(file, "\tBIC\tr3,r6,#3\n");
    fprintf(file, "\tTEQP\tr3,#3\n");
  }
  else
  {
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tMOVNE    r8,pc\n");
    fprintf(file, "\tORRNE    r3,r8,#3\n");
    fprintf(file, "\tTEQNEP   r3,#0\n");
    fprintf(file, "\tMRSEQ    r6,cpsr\n");
    fprintf(file, "\tORREQ    r3,r6,#3\n");
    fprintf(file, "\tMSREQ    cpsr_ctl,r3\n");
  }
  fprintf(file, "\tMOV\tr1,r12\n");
  fprintf(file, "\tMOV\tr7,r14\n");
  fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
  fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
  fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tLDR\tr12,[r12]\n");
  fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
  fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
  fprintf(file, ADD_Lib_Reloc);
  fprintf(file, "\tMOV\tr11,#0\n");
  if (CODE26)
  {
    fprintf(file, "\tMOV\tr14,pc\n");
    fprintf(file, "\tADD\tr14,r14,# _CMUNGE_vret - _CMUNGE_vpc\n");
  }
  else
  {
    fprintf(file, "\tADD\tr14,pc,# _CMUNGE_vret - _CMUNGE_vpc - 4\n");
  }
  fprintf(file, "_CMUNGE_vpc\n");
  fprintf(file, "\tADD\tpc,pc,r2\n");
  fprintf(file, "\tMOV\tr0,r0\n");

  /* Events */
  l = opt.events;
  while (l) {
    if (l->handler) {
      fprintf(file, "\tIMPORT\t%s\n", l->handler);
      fprintf(file, "\tB\t%s\n", l->handler);
    } else {
      fprintf(file, "\tIMPORT\t%s_handler\n", l->name);
      fprintf(file, "\tB\t%s_handler\n", l->name);
    }
    l = l->next;
  }
  /* Vectors */
  l = opt.vectors;
  while (l) {
    if (l->handler) {
      fprintf(file, "\tIMPORT\t%s\n", l->handler);
      fprintf(file, "\tB\t%s\n", l->handler);
    } else {
      fprintf(file, "\tIMPORT\t%s_handler\n", l->name);
      fprintf(file, "\tB\t%s_handler\n", l->name);
    }
    l = l->next;
  }
  /* Irqs */
  l = opt.irqs;
  while (l) {
    if (l->handler) {
      fprintf(file, "\tIMPORT\t%s\n", l->handler);
      fprintf(file, "\tB\t%s\n", l->handler);
    } else {
      fprintf(file, "\tIMPORT\t%s_handler\n", l->name);
      fprintf(file, "\tB\t%s_handler\n", l->name);
    }
    l = l->next;
  }
  fprintf(file, "_CMUNGE_vret\n");
  fprintf(file, SUB_Lib_Reloc);
  fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tMOV\tr14,r7\n");
  if (CODE26)
  {
    fprintf(file, "\tTEQP\tr6,#0\n");
  }
  else
  {
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tBEQ      _CMUNGE_vret_10\n");
    fprintf(file, "\tTEQP     r8,#0\n");
  }
  fprintf(file, "\tTEQ\tr0,#0\n");
  fprintf(file, "\tLDMEQIA\tr13!,{r0-r11,r14,pc}^\n");
  fprintf(file, "\tLDMNEIA\tr13!,{r0-r11,pc}^\n");
  if (CODE26)
  {}
  else
  {
    fprintf(file, "_CMUNGE_vret_10\n");
    fprintf(file, "\tMOV      r12,r6\n");
    fprintf(file, "\tMSR      cpsr_ctl,r6\n");
    fprintf(file, "\tTEQ      r0,#0\n");
    fprintf(file, "\tLDMIA    r13!,{r0-r11,r14}\n");
    fprintf(file, "\tLDREQ    r14,[r13],#4\n");
    fprintf(file, "\tMSR      cpsr_flg,r12\n");
    fprintf(file, "\tMOV      pc,r14\n");
  }
}

/* Vector traps are a special case of veneers */
static void vector_traps(void) {

  int n;
  int first;
  handler_list l;

  first = 1;
  n = 0;
  /* Vector traps */
  l = opt.vector_traps;
  while (l) {
    if (!first)
      fprintf(file, "\tB\t_CMUNGE_vte\n");
    fprintf(file, "\tEXPORT\t%s\n", l->name);
    fprintf(file, "%s\n", l->name);
    fprintf(file, "\tSTMDB\tr13!,{r0-r11,r14}\n");
    fprintf(file, "\tMOV\tr2,#%d\n", n);
    l = l->next;
    n += 4;
    first = 0;
  }
  if (n == 0)
    return;
  fprintf(file, "_CMUNGE_vte\n");
  fprintf(file, "\tMOV\tr0,r13\n");
  if (CODE26)
  {
    fprintf(file, "\tMOV\tr6,pc\n");
    fprintf(file, "\tBIC\tr3,r6,#3\n");
    fprintf(file, "\tTEQP\tr3,#3\n");
  }
  else
  {
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tMOVNE    r8,pc\n");
    fprintf(file, "\tBICNE    r3,r8,#3\n");
    fprintf(file, "\tTEQNEP   r3,#3\n");
    fprintf(file, "\tMRSEQ    r6,cpsr\n");
    fprintf(file, "\tORREQ    r3,r6,#3\n");
    fprintf(file, "\tMSREQ    cpsr_ctl,r3\n");
  }
  fprintf(file, "\tMOV\tr1,r12\n");
  fprintf(file, "\tMOV\tr7,r14\n");
  fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
  fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
  fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tLDR\tr12,[r12]\n");
  fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
  fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
  fprintf(file, ADD_Lib_Reloc );
  fprintf(file, "\tMOV\tr11,#0\n");
  fprintf(file, "\tMOV\tr12,r2\n");
  fprintf(file, "\tADR\tr2,_CMUNGE_vtcall\n");
  fprintf(file, "\tMOV\tr3,r0\n");
  fprintf(file, "\tMOV\tr14,pc\n");
  fprintf(file, "\tADD\tr14,r14,# _CMUNGE_vtret - _CMUNGE_vtpc\n");
  fprintf(file, "_CMUNGE_vtpc\n");
  fprintf(file, "\tADD\tpc,pc,r12\n");
  fprintf(file, "\tMOV\tr0,r0\n");

  /* Vector traps */
  l = opt.vector_traps;
  while (l) {
    if (l->handler) {
      fprintf(file, "\tIMPORT\t%s\n", l->handler);
      fprintf(file, "\tB\t%s\n", l->handler);
    } else {
      fprintf(file, "\tIMPORT\t%s_handler\n", l->name);
      fprintf(file, "\tB\t%s_handler\n", l->name);
    }
    l = l->next;
  }
  fprintf(file, "_CMUNGE_vtret\n");
  fprintf(file, SUB_Lib_Reloc );
  fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
  fprintf(file, "\tMOV\tr14,r7\n");
  /* Return to the caller's mode */
  if (CODE26)
  {
    fprintf(file, "\tTEQP\tr6,#0\n");
  }
  else
  {
    fprintf(file, "\tTEQ      pc,pc\n");
    fprintf(file, "\tMSREQ    cpsr_ctl,r6\n");
    fprintf(file, "\tTEQNEP   r8,#0\n");
    ErrorFatal("vector-traps have not been made 32bit-compatible yet");
  }
  /* We need to return if 1,
                claim if 0,
                return VS, r0 passed on if other values
   */
  /* FIXME: This end section hasn't been checked for 32bit */
  if (CODE26)
  {
    fprintf(file, "\tTEQ\tr0,#1\n");
    fprintf(file, "\tLDMEQIA\tr13!,{r0-r11,pc}^\n");
    fprintf(file, "\tTEQ\tr0,#0\n");
    fprintf(file, "\tLDMEQIA\tr13!,{r0-r11,r14,pc}^\n");
    fprintf(file, "\tADD\tr13,r13,#4\n");
    fprintf(file, "\tLDMIA\tr13!,{r1-r11,r14}\n");
    fprintf(file, "\tLDR\tr14,[r13],#4\n");
    fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
  }
  else
  {
    fprintf(file,"\tCMP     r0, #1\n");
    fprintf(file,"\tBHI     _CMUNGE_vtretv\n");
    fprintf(file,"\tMOV     r12, r6\n");
    fprintf(file,"\tLDMEQIA r13!,{r0-r11,r14}\n");
    fprintf(file,"\tLDMLOIA r13!,{r0-r11}\n");
    fprintf(file,"\tTEQ     pc,pc\n");
    fprintf(file,"\tLDR     r14, [sp], #4\n");
    fprintf(file,"\t_CMUNGE_vtret\n");
    fprintf(file,"\tMOVNES  pc,r14\n");
    fprintf(file,"\tMSR     cpsr_flg,r12\n");
    fprintf(file,"\tMOV     pc, r14\n");

    fprintf(file,"_CMUNGE_vtretv\n");
    fprintf(file,"\tADD     r13, r13, #4\n");
    fprintf(file,"\tLDMIA   r13!,{r1-r11,r14}\n");
    fprintf(file,"\tTEQ     pc,pc\n");
    fprintf(file,"\tLDR     r14, [sp], #4\n");
    fprintf(file,"\tORREQ   r12, r6, #0x10000000\n");
    fprintf(file,"\tORRNE   r14, r14, #0x10000000\n");
    fprintf(file,"\tMOVNES  pc,r14\n");
    fprintf(file,"\tMSR     cpsr_flg,r12\n");
    fprintf(file,"\tMOV     pc, r14\n");
  }

  /* Now the call routine...
     This routine is called with :
       r0-> register block to pass to routine
       r1-> *original* register block
     What we must do is...
  */
  fprintf(file, "_CMUNGE_vtcall\n");

  fprintf(file, "\tSTMFD\tr13!,{r0,r4-r11,r14}\n");
  fprintf(file, "\tADD\tr12,r1,#10*4\n");
  fprintf(file, "\tLDMIA\tr0,{r0-r9}\n");
  fprintf(file, "\tSTMFD\tr13!,{pc}\n");
  fprintf(file, "\tLDMFD\tr12,{r10,r11,pc}\n");
  fprintf(file, "\tNOP\n");
  fprintf(file, "\tLDR\tr12,[r13],#4\n");
  fprintf(file, "\tSTMIA\tr12,{r0-r9}\n");
  fprintf(file, "\tMOVVC\tr0,#0\n");
  if (CODE26)
  {
    fprintf(file, "\tLDMFD\tr13!,{r4-r11,pc}^\n");
  }
  else
  {
    /* we're returning to APCS-R or APCS-32 so we preserve flags if in 26bit
       where that's easy and ignore them in 32bit */
    fprintf(file, "\tTEQ\tpc,pc\n");
    fprintf(file, "\tLDMNEFD\tr13!,{r4-r11,pc}^\n");
    fprintf(file, "\tLDMFD\tr13!,{r4-r11,pc}\n");
  }
}

static void errors(void) {

  int error=opt.error_base;
  error_list l=opt.errors;

  if (opt.errors==NULL)
    return;

  fprintf(file,"\n; Error messages, based at &%08x\n",error);
  while (l)
  {
    fprintf(file,"\tEXPORT\t__err_%s\n",l->name);
    fprintf(file,"__err_%s\n",l->name);
    if (l->number)
      fprintf(file,"\tDCD\t&%08x\n",l->number);
    else
      fprintf(file,"\tDCD\t&%08x\n",error++);
    fprintf(file,"\t= \"%s\",0\n",l->message);
    fprintf(file,"\tALIGN\n");
    l = l->next;
  }
}

static void generics(void) {

  int n;
  int first;
  handler_list l;

  /* So that we can preserve r12 when we use the generic veneers, we remember
     whether we have had any registers specified */
  int preserve_endreg=11;

  /* 0 if we're not doing the carry_capable handlers,
     1 if we're doing the carry_capable handlers */
  int carry_now;

  /* Check if we use any specific registers */
  l = opt.generics;
  while (l) {
    if (l->private_word != -1)
      preserve_endreg=12;
    l = l->next;
  }

  for (carry_now=0; carry_now<2; carry_now++)
  {
    first = 1;
    n = 0;

    /* Generic */
    l = opt.generics;
    for (l=opt.generics; l; l=l->next)
    {
      if (carry_now != l->carry_capable)
        continue;

      if (!first)
        fprintf(file, "\tB\t_CMUNGE_ge%s\n",carry_now ? "_carry" : "");
      fprintf(file, "\tEXPORT\t%s\n", l->name);
      fprintf(file, "%s\n", l->name);
      fprintf(file, "\tSTMDB\tr13!,{r0-r%i,r14}\n",preserve_endreg);

      /* If the private word appears elsewhere, use that */
      if (l->private_word != -1 &&
          l->private_word != 12)
        fprintf(file, "\tMOV\tr12,r%i\n", l->private_word);

      fprintf(file, "\tMOV\tr2,#%d\n", n);
      n += 4;
      first = 0;
    }

    if (n == 0)
      continue;

    fprintf(file, "_CMUNGE_ge%s\n",carry_now ? "_carry" : "");
    fprintf(file, "\tMOV\tr0,r13\n");
    if (CODE26)
    {
      fprintf(file, "\tMOV\tr6,pc\n");
      fprintf(file, "\tBIC\tr3,r6,#3\n");
      fprintf(file, "\tTEQP\tr3,#3\n");
    }
    else
    {
      fprintf(file, "\tTEQ      pc,pc\n");
      fprintf(file, "\tMOVNE    r8,pc\n");
      fprintf(file, "\tORRNE    r3,r8,#3\n");
      fprintf(file, "\tTEQNEP   r3,#0\n");
      fprintf(file, "\tMRSEQ    r6,cpsr\n");
      fprintf(file, "\tORREQ    r3,r6,#3\n");
      fprintf(file, "\tMSREQ    cpsr_ctl,r3\n");
    }
    fprintf(file, "\tMOV\tr1,r12\n");
    fprintf(file, "\tMOV\tr7,r14\n");
    fprintf(file, "\tMOV\tr10,r13,LSR #20\n");
    fprintf(file, "\tMOV\tr10,r10,LSL #20\n");
    fprintf(file, "\tLDMIA\tr10,{r4,r5}\n");
    fprintf(file, "\tLDR\tr12,[r12]\n");
    fprintf(file, "\tLDMIB\tr12,{r11,r12}\n");
    fprintf(file, "\tSTMIA\tr10,{r11,r12}\n");
    fprintf(file, ADD_Lib_Reloc);
    fprintf(file, "\tMOV\tr11,#0\n");
    if (CODE26)
    {
      fprintf(file, "\tMOV\tr14,pc\n");
      fprintf(file, "\tADD\tr14,r14,#_CMUNGE_gret%s - _CMUNGE_gpc%s\n",
                    carry_now ? "_carry" : "",
                    carry_now ? "_carry" : "");
    }
    else
    {
      fprintf(file, "\tADD\tr14,pc,#_CMUNGE_gret%s - _CMUNGE_gpc%s - 4\n",
                    carry_now ? "_carry" : "",
                    carry_now ? "_carry" : "");
    }
    fprintf(file, "_CMUNGE_gpc%s\n", carry_now ? "_carry" : "");
    fprintf(file, "\tADD\tpc,pc,r2\n");
    fprintf(file, "\tMOV\tr0,r0\n");
    for (l = opt.generics; l; l=l->next) {
      if (carry_now != l->carry_capable)
        continue;

      if (l->handler) {
        fprintf(file, "\tIMPORT\t%s\n", l->handler);
        fprintf(file, "\tB\t%s\n", l->handler);
      } else {
        fprintf(file, "\tIMPORT\t%s_handler\n", l->name);
        fprintf(file, "\tB\t%s_handler\n", l->name);
      }
    }
    fprintf(file, "_CMUNGE_gret%s\n", carry_now ? "_carry" : "");
    fprintf(file, SUB_Lib_Reloc);
    fprintf(file, "\tSTMIA\tr10,{r4,r5}\n");
    fprintf(file, "\tMOV\tr14,r7\n");
    if (CODE26)
    {
      fprintf(file, "\tTEQP\tr6,#0\n");
      fprintf(file, "\tTEQ\tr0,#0\n");
      fprintf(file, "\tLDMEQIA\tr13!,{r0-r%i,pc}^\n",preserve_endreg);
      if (carry_now)
      {
        fprintf(file, "\tTEQ\tr0,#2\n");
        fprintf(file, "\tLDMEQIA\tr13!,{r0-r%i,r14}\n",preserve_endreg);
        fprintf(file, "\tORREQS\tpc,r14,#0x20000000\n");
        fprintf(file, "\tADD\tr13,r13,#4\n");
        fprintf(file, "\tLDMIA\tr13!,{r1-r%i,r14}\n",preserve_endreg);
        fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
      }
      else
      {
        fprintf(file, "\tADD\tr13,r13,#4\n");
        fprintf(file, "\tLDMIA\tr13!,{r1-r%i,r14}\n",preserve_endreg);
        fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
      }
    }
    else
    {
      fprintf(file, "\tTEQ      pc,pc\n");
      fprintf(file, "\tBEQ      _CMUNGE_genv%i ; 32bit PC\n",(int)l);
      fprintf(file, "\tTEQP     r8,#0\n");
      fprintf(file, "\tTEQ      r0,#0\n");
      fprintf(file, "\tLDMEQIA  r13!,{r0-r11,pc}^\n");
      if (carry_now)
      {
        fprintf(file, "\tTEQ\tr0,#2\n");
        fprintf(file, "\tLDMEQIA\tr13!,{r0-r%i,r14}\n",preserve_endreg);
        fprintf(file, "\tORREQS\tpc,r14,#0x20000000\n");
        fprintf(file, "\tADD\tr13,r13,#4\n");
        fprintf(file, "\tLDMIA\tr13!,{r1-r%i,r14}\n",preserve_endreg);
        fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
        fprintf(file, "_CMUNGE_genv%i\n",(int)l);
        ErrorFatal("32bit code not present for carry handling");
        /* JRF: Fix me; looks like I was lazy for this bit */
      }
      else
      {
        fprintf(file, "\tADD\tr13,r13,#4\n");
        fprintf(file, "\tLDMIA\tr13!,{r1-r%i,r14}\n",preserve_endreg);
        fprintf(file, "\tORRS\tpc,r14,#0x10000000\n");
        fprintf(file, "_CMUNGE_genv%i\n",(int)l);
        fprintf(file, "\tMSR      cpsr_ctl,r6\n");
        fprintf(file, "\tTEQ      r0,#0\n");
        fprintf(file, "\tSTRNE    r0,[r13,#0]\n");
        fprintf(file, "\tORRNE    r6,r6,#0x10000000\n");
        fprintf(file, "\tMSR      cpsr_flg,r6\n");
        fprintf(file, "\tLDMIA    r13!,{r0-r11,pc}\n");
      }
    }
  }
}

static void trailer(void) {
  /* We need to have some space allocated for the stack for an entered RMA
     application. This code needs re-working such that other parts of the
     system can place blocks in this section without code re-writes. This
     will basically mean that they can have a list of blocks to allocate
     and their sizes which can just be traversed here. That's the idea.
     How soon I implement it... gawd only knows... depends on when I next
     have the opportunity to do something fun with CMunge that doesn't mean
     large changes to the vast majority of RISC OS. Oh yes. I like RISC OS.
     I do. Really. Oh yes. */
  if (opt.runnable == run_rmaapp_simple)
  { /* Icky */
    fprintf(file,"\n\n\tAREA\t|!Header$$Data|, DATA\n");
    fprintf(file, "_CMUNGE_stack\n");
    fprintf(file, "\tDCD\t0 ; no stack at present\n");
  }
  fprintf(file, "\n\n\tEND\n");
}

/* This function generates the module flags for 32bit modules */
static void flags(void) {
  if (CODE26)
  {}
  else
  {
    fprintf(file, "\tALIGN\n");
    fprintf(file, "_CMUNGE_module_flags\n");
    fprintf(file, "\tDCD\t1 ; 32bit supported\n");
  }
}

void WriteFile(void) {

  file = file_write(opt.sfile, remove_onfail);
  if (file == NULL)
    ErrorFatal("Couldn't open output file: %s", opt.sfile);

  asm_header();
  mod_header();
  strings();
  swi_table();
  commands();
#ifdef CMHG_RESOURCE_FILE_ORDERING
  if (opt.mfile) {
    fprintf(file, "_CMUNGE_message_file\n");
    outstring(opt.mfile,1,'\n',0);
    fprintf(file, "\tALIGN\n");
  }
#endif
  flags();
  service();
  start();
  init();
  final();
  swi_handler();
  swi_decoder();
  veneers();
  vector_traps();
  generics();
  errors();

  trailer();

  file_close(file);
}

