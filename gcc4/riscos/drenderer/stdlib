 REM *******************************************************************
 REM *
 REM * Stdlib
 REM *
 REM * Useful modules for BASIC assembler
 REM * (C) 1995-2006 Andreas Dehmel (zarquon@t-online.de)
 REM *
 REM * This program is free software; you can redistribute it and/or modify
 REM * it under the terms of the GNU General Public License as published by
 REM * the Free Software Foundation; either version 2 of the License, or
 REM * (at your option) any later version.
 REM *
 REM * This program is distributed in the hope that it will be useful,
 REM * but WITHOUT ANY WARRANTY; without even the implied warranty of
 REM * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 REM * GNU General Public License for more details.
 REM *
 REM * You should have received a copy of the GNU General Public License
 REM * along with this program; if not, write to the Free Software
 REM * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 REM * 02111-1307  USA.
 REM *
 REM *******************************************************************

 REM Test code
 DIM Code% &1000

 FOR pass%=0 TO 2 STEP 2
 P%=Code%
[OPT pass%
 FNadr2("EQ",0,&20000)
 FNadr3("NV",5,&1234)
 FNadr3("",12,&800000)
 FNadr4("",4,&12345678)
 FNadr4("",0,0)
.divide
 MOV R0,#(1<<16)
 MOV R1,#(2<<16)
 FNoverdiv32(16,0,1,2)
 STR R2,result
 MOVS PC,R14
.result
 EQUD 0
.LongMults
 FNumull("",0,1,2,3)
 FNumlal("",0,1,2,3)
 FNmultL32(8,0,1,2,3)
 FNumultL64(8,0,1,2,3,4,5,10,11,12)
 FNusquareL64(8,0,1,2,3,10,11,12)
.sqrt
 MOV R0,#1024
 FNsqrt(0,1,2)
 STR R1,result
 MOVS PC,R14
]
 NEXT pass%
 REM OSCLI "*mi "+STR$~(sqrt)+" "+STR$~(sqrt+512)
 REM CALL divide
 REM PRINT STR$~(!result)
 CALL sqrt
 PRINT !result
 END



 REM ***************
 REM * THE LIBRARY *
 REM ***************

 REM FNadr<i> ADR i%,a% for various offsets
 DEF FNadr2(c$,i%,a%)
=FNadrcore(c$,i%,a%,2)

 DEF FNadr3(c$,i%,a%)
=FNadrcore(c$,i%,a%,3)

 DEF FNadr4(c$,i%,a%)
=FNadrcore(c$,i%,a%,4)

 DEF FNadrcore(c$,i%,a%,l%)
 LOCAL c%,opc%,off%,s%,d%,r%
 c%=FNcond(c$)
 off%=a%-P%-8: s%=0: r%=15
 IF off%<0 THEN opc%=2: off%=-off% ELSE opc%=4
 d%=&02000000+(c%<<28)+(opc%<<21)+(i%<<12)
 REPEAT
 WHILE (((off%AND3)=0) AND (off%<>0))
 s%-=1:off%=(off%>>2)
 ENDWHILE
 IF off%=0 THEN s%=0 ELSE s%=s%AND15
[OPT pass%
 EQUD d%+(r%<<16)+(s%<<8)+(off%AND&FF)
]
 s%=(s%-4)AND15: off%=(off%>>8): r%=i%: l%-=1
 UNTIL l%=0
 IF off%<>0 ERROR 0,"Bad address offset at P%=&"+STR$~(P%-8)
=0

 DEF FNcond(c$)
 CASE c$ OF
  WHEN "": =14
  WHEN "EQ": =0
  WHEN "NE": =1
  WHEN "CS": =2
  WHEN "CC": =3
  WHEN "MI": =4
  WHEN "PL": =5
  WHEN "VS": =6
  WHEN "VC": =7
  WHEN "HI": =8
  WHEN "LS": =9
  WHEN "GE": =10
  WHEN "LT": =11
  WHEN "GT": =12
  WHEN "LE": =13
  WHEN "AL": =14
  WHEN "NV": =15
  OTHERWISE: ERROR 0,"Illegal condition code at P%=&"+STR$~(P%)
 ENDCASE


 REM 32 Bit Fixpoint multiplication. v% = #pre-point bits
 DEF FNmult32(v%,s1%,s2%,t%,h1%,h2%,h3%,h4%)
 LOCAL sh1%,sh2%
 sh1% = INT(v%/2): sh2% = v%-sh1%
[OPT pass%
 MOV h2%,s1%
 ANDS t%,h2%,#&80000000
 RSBNE h2%,h2%,#0
 MOVS h4%,s2%
 EORLT t%,t%,#&80000000
 RSBLT h4%,h4%,#0
 MOV h1%,h2%,LSR #(16-sh1%)
 MOV h3%,h4%,LSR #(16-sh2%)
 BIC h2%,h2%,h1%,LSL #(16-sh1%)
 BIC h4%,h4%,h3%,LSL #(16-sh2%)
 CMP t%,#0
 MUL t%,h2%,h4%
 MUL h4%,h1%,h4%
]
 IF (sh1% <> sh2%) THEN
[OPT pass%
 MOV h4%,h4%,LSL #1
]
 ENDIF
[OPT pass%
 MLA h4%,h3%,h2%,h4%
 ADD t%,h4%,t%,LSR #(16-sh2%)
 MUL h4%,h1%,h3%
 ADD t%,h4%,t%,LSR #(16-sh1%)
 RSBNE t%,t%,#0
]
=0


 REM 32 Bit Fixpoint squaring
 DEF FNsquare32(v%,s%,t%,h1%,h2%)
 LOCAL sh%
 sh% = INT((v%+1)/2)
[OPT pass%
 MOVS h2%,s%
 RSBLT h2%,h2%,#0
 MOV h1%,h2%,LSR #(16-sh%)
 BIC h2%,h2%,h1%,LSL #(16-sh%)
 MUL t%,h2%,h2%
 MUL h2%,h1%,h2%
 ADD t%,h2%,t%,LSR #(17-sh%)
 MUL h2%,h1%,h1%
 ADD t%,h2%,t%,LSR #(15-sh%)
]
 IF ((v% AND 1) <> 0) THEN
[OPT pass%
 MOV t%,t%,LSR #1
]
 ENDIF
=0


 REM 32 Bit unsigned Fixpoint Division i%/j% = k%. prec% = #post-point bits
 DEF FNdiv32(prec%,i%,j%,k%)
 LOCAL l%,n%,ptr%,otr%
 ptr%=P%: otr%=O%
 FOR l%=1 TO 2
 P%=ptr%: O%=otr%
[OPT pass%
 MOV k%,#0
]
 FOR n%=0 TO (30-prec%)
[OPT pass%
 CMP i%,j%,LSL #n%
 BCC div_mark+(30-prec%-n%)*12+12
]
 NEXT n%
[OPT pass%
 SUBCS i%,i%,j%,LSL #(31-prec%)
 ORRCS k%,k%,#(1<<31)
.div_mark
]
 FOR n%=(30-prec%) TO 0 STEP -1
[OPT pass%
 CMP i%,j%,LSL #n%
 SUBCS i%,i%,j%,LSL #n%
 ORRCS k%,k%,#(1<<(prec%+n%))
]
 NEXT n%
 IF prec% > 0 THEN
 FOR n%=1 TO prec%
[OPT pass%
 CMP i%,j%,LSR #n%
 SUBCS i%,i%,j%,LSR #n%
 ORRCS k%,k%,#(1<<(prec%-n%))
]
 NEXT n%
 ENDIF
 NEXT l%
=0


 REM 32 Bit unsigned Fixpoint Division i%/j% = k%. prec% = #post-point bits
 REM also works if overflow occurs (i.e. remainder of bits is correct
 DEF FNoverdiv32(prec%,i%,j%,k%)
 LOCAL l%,n%,ptr%,otr%
 ptr%=P%: otr%=O%
 FOR l%=1 TO 2
 P%=ptr%: O%=otr%
[OPT pass%
 MOV k%,#0
]
 FOR n%=0 TO (30-prec%)
[OPT pass%
 CMP i%,j%,LSL #n%
 BCC odiv_mark+(30-prec%-n%)*12+12
]
 NEXT n%
 FOR n%=(31-prec%) TO 30
[OPT pass%
 CMP i%,j%,LSL #n%
 BCC odiv_mark2+(30-n%)*8+8
]
 NEXT n%
[OPT pass%
 CMP i%,j%,LSL #31
 SUBCS i%,i%,j%,LSL #31
.odiv_mark2
]
 FOR n%=30 TO (31-prec%) STEP -1
[OPT pass%
 CMP i%,j%,LSL #n%
 SUBCS i%,i%,j%,LSL #n%
]
 NEXT n%
[OPT pass%
.odiv_mark
]
 FOR n%=(30-prec%) TO 0 STEP -1
[OPT pass%
 CMP i%,j%,LSL #n%
 SUBCS i%,i%,j%,LSL #n%
 ORRCS k%,k%,#(1<<(prec%+n%))
]
 NEXT n%
 IF prec% > 0 THEN
 FOR n%=1 TO prec%
[OPT pass%
 CMP i%,j%,LSR #n%
 SUBCS i%,i%,j%,LSR #n%
 ORRCS k%,k%,#(1<<(prec%-n%))
]
 NEXT n%
 ENDIF
 NEXT l%
=0


 REM unsigned integer division, optimized for small code rather than speed. i%/j
%=k%
 REM prec% = #post-point bits, m% = temporary register
 DEF FNsmalldiv32(prec%,i%,j%,k%,m%)
 LOCAL l%,ptr%,otr%
 ptr%=P%: otr%=O%
 FOR l%=1 TO 2
 P%=ptr%: O%=otr%
[OPT pass%
 MOV     m%,#(1<<prec%)
 MOV     k%,#0
.sdiv_alignloop
 CMP     i%,j%
 MOVHI   j%,j%,LSL #1
 MOVHI   m%,m%,LSL #1
 BHI     sdiv_alignloop
.sdiv_divloop
 CMP     i%,j%
 SUBCS   i%,i%,j%
 ORRCS   k%,k%,m%
 MOV     i%,i%,LSL #1
 MOVS    m%,m%,LSR #1
 BNE     sdiv_divloop
]
 NEXT l%
=0


 REM Long Multiplication (ARM7DM)
 DEF FNumull(c$,l%,h%,m%,s%)
[OPT pass%
 EQUD FNmull(c$,l%,h%,m%,s%,0)
]
=0

 DEF FNumlal(c$,l%,h%,m%,s%)
[OPT pass%
 EQUD FNmull(c$,l%,h%,m%,s%,2)
]
=0

 DEF FNsmull(c$,l%,h%,m%,s%)
[OPT pass%
 EQUD FNmull(c$,l%,h%,m%,s%,4)
]
=0

 DEF FNsmlal(c%,l%,h%,m%,s%)
[OPT pass%
 EQUD FNmull(c$,l%,h%,m%,s%,6)
]
=0

 DEF FNmull(c$,l%,h%,m%,s%,f%)
 IF ((l%=h%) OR (h%=m%) OR (l%=m%)) THEN ERROR 0,"Bad registers for mull"
 IF ((l%>15) OR (h%>15) OR (m%>15) OR (s%>15)) THEN ERROR 0,"Register out of ran
ge"
 = (FNcond(c$)<<28) + ((f%+8)<<20) + (h%<<16) + (l%<<12) + (s%<<8) + 144 + m%


 REM 32 bit fixpoint multiplication with long mult
 DEF FNmultL32(v%,s1%,s2%,t%,h%)
 LOCAL sh1%,sh2%
[OPT pass%
 FNsmull("",h%,t%,s1%,s2%)
 MOV t%,t%,LSL #v%
 ORR t%,t%,h%,LSR #(32-v%)
 TST h%,#(1<<(31-v%))
 ADDNE t%,t%,#1
]
=0

 REM unsigned 64 bit fixpoint multiplication with long mult
 DEF FNumultL64(v%,sl1%,sh1%,sl2%,sh2%,tl%,th%,h1%,h2%,h3%)
[OPT pass%
 FNumull("",tl%,th%,sh1%,sh2%)
 FNumull("",h1%,h2%,sh1%,sl2%)
 ADDS tl%,tl%,h2%
 ADC th%,th%,#0
 FNumull("",h2%,h3%,sl1%,sh2%)
 ADDS h1%,h1%,h2%
 ADCS tl%,tl%,h3%
 ADC th%,th%,#0
 FNumull("",h2%,h3%,sl1%,sl2%)
 ADDS h1%,h1%,h3%
 ADCS tl%,tl%,#0
 ADC th%,th%,#0
 MOV th%,th%,LSL #v%
 ORR th%,th%,tl%,LSR #(32-v%)
 MOV tl%,tl%,LSL #v%
 ORR tl%,tl%,h1%,LSR #(32-v%)
 ; maybe add rounding code
]
=0

 REM unsigned 64 bit squaring with long mult
 DEF FNusquareL64(v%,sl%,sh%,tl%,th%,h1%,h2%,h3%)
[OPT pass%
 FNumull("",tl%,th%,sh%,sh%)
 FNumull("",h1%,h2%,sh%,sl%)
 MOV h3%,h2%,LSL #1
 ORR h3%,h3%,h1%,LSR #31
 MOV h1%,h1%,LSL #1
 ADDS tl%,tl%,h3%
 ADC th%,th%,h2%,LSR #31
 FNumull("",h2%,h3%,sl%,sl%)
 ADDS h1%,h1%,h3%
 ADCS tl%,tl%,#0
 ADC th%,th%,#0
 MOV th%,th%,LSL #v%
 ORR th%,th%,tl%,LSR #(32-v%)
 MOV tl%,tl%,LSL #v%
 ORR tl%,tl%,h1%,LSR #(32-v%)
]
=0


 REM convert extended floating point number to 64 bit fixpoint
 DEF FNxtendto64(v%,adr%,tl%,th%,h%)
 LOCAL i%,ptr%,otr%,xtf_zero,xtf_shiftl,xtf_shifted,xtf_bigr,xtf_bigl,xtf_sign
 ptr%=P%: otr%=O%
 FOR i%=1 TO 2
 P%=ptr%: O%=otr%
[OPT pass%
 LDR th%,[adr%,#4]
 LDR tl%,[adr%,#8]
 LDR h%,[adr%]
 BICS h%,h%,#(255<<24)
 BEQ xtf_zero
 SUB h%,h%,#16384
 RSBS h%,h%,#(v%-2)
 BLT xtf_shiftl
 CMP h%,#64
 MOVGE tl%,#0
 MOVGE th%,#0
 BGE xtf_zero
 CMP h%,#32
 BGE xtf_bigr
 MOV tl%,tl%,LSR h%
 RSB h%,h%,#32
 ORR tl%,tl%,th%,LSL h%
 RSB h%,h%,#32
 MOV th%,th%,LSR h%
 B xtf_sign
.xtf_bigr
 SUB h%,h%,#32
 MOV tl%,th%,LSR h%
 MOV th%,#0
 B xtf_sign
.xtf_shiftl
 RSB h%,h%,#0
 CMP h%,#64
 MOVGE tl%,#0
 MOVGE th%,#0
 BGE xtf_zero
 CMP h%,#32
 BGE xtf_bigl
 MOV th%,th%,LSL h%
 RSB h%,h%,#32
 ORR th%,th%,tl%,LSR h%
 RSB h%,h%,#0
 MOV tl%,tl%,LSL h%
 B xtf_sign
.xtf_bigl
 MOV th%,tl%,LSL h%
 MOV tl%,#0
.xtf_sign
 LDR h%,[adr%]
 TST h%,#(1<<31)
 BEQ xtf_zero
 RSBS tl%,tl%,#0
 RSC th%,th%,#0
.xtf_zero
]
 NEXT i%
=0


 REM compute sqrt of an int
 DEF FNsqrt(s%,d%,h%)
 LOCAL i%
[OPT pass%
 CMP s%,#1
 MOVLS d%,s%
 BLS P%+15*32-4
]
 FOR i%=1 TO 14
[OPT pass%
 CMP s%,#(1<<(i%<<1))
 MOVLS d%,#(1<<i%)
 BLS P%+(15-i%)*32 - 4
]
 NEXT i%
[OPT pass%
 MOV d%,#(1<<15)
]
 FOR i%=15 TO 1 STEP -1
[OPT pass%
 MUL h%,d%,d%
 CMP h%,s%
 BEQ P% + i%*20 - 8
 ADDCC d%,d%,#(1<<(i%-1))
 SUBHI d%,d%,#(1<<(i%-1))
]
 NEXT i%
=0



 REM efficient computation of d%=b%+m%*s%
 REM for correct results in all cases s% <> d% !!!
 DEF FNArrayAdr(d%,s%,b%,m%)
 LOCAL i%,j%,k%,c%,mm%
 i%=32: j%=0: c%=0
 FOR k%=0 TO 15
 IF ((m%AND(1<<k%))<>0) THEN
  IF (k%<i%) THEN i%=k%: c%=c%+1
  IF (k%>j%) THEN j%=k%: c%=c%+1
 ENDIF
 NEXT k%
 IF (i%=j%) THEN
[OPT pass%
 ADD     d%,b%,s%,LSL #i%
]
 ELSE
 IF ((d%=s%) OR (d%=b%)) THEN ERROR 0,"ArrayAdr: registers must differ!"
 IF (c%<=j%) THEN
  [OPT pass%
   ADD    d%,s%,s%,LSL #(j%-i%)
  ]
  IF (j%>i%+2) THEN
   FOR k%=i%+1 TO j%-1
   IF ((m%AND(1<<k%))<>0) THEN
   [OPT pass%
    ADD   d%,d%,s%,LSL #(k%-i%)
   ]
   ENDIF
   NEXT k%
  ENDIF
 ELSE
  c%=0: mm%=(1<<(j%+1))-m%
  i%=32
  FOR k%=0 TO j%
  IF ((mm%AND(1<<k%))<>0) THEN
   IF (k%<i%) THEN i%=k%
  ENDIF
  NEXT k%
  [OPT pass%
   RSB    d%,s%,s%,LSL #(j%+1-i%)
  ]
  IF (j%>i%+2) THEN
   FOR k%=i%+1 TO j%-1
   IF ((m%AND(1<<k%))<>0) THEN
   [OPT pass%
    SUB   d%,d%,s%,LSL #(k%-i%)
   ]
   ENDIF
   NEXT k%
  ENDIF
 ENDIF
[OPT pass%
 ADD     d%,b%,d%,LSL #i%
]
 ENDIF
=0


 DEF FNldr2(r%,a%)
 LOCAL off%
 off%=(a%-P%-8)
 IF (off%>=0) THEN
[OPT pass%
 ADD     r%,PC,#(off%AND&FFFFF000)
 LDR     r%,[r%,#(off%AND&FFF)]
]
 ELSE
 off%=-off%
[OPT pass%
 SUB     r%,PC,#(off%AND&FFFFF000)
 LDR     r%,[r%,#-(off%AND&FFF)]
]
 ENDIF
=0

 DEF FNldrb2(r%,a%)
 LOCAL off%
 off%=(a%-P%-8)
 IF (off%>=0) THEN
[OPT pass%
 ADD     r%,PC,#(off%AND&FFFFF000)
 LDRB    r%,[r%,#(off%AND&FFF)]
]
 ELSE
 off%=-off%
[OPT pass%
 SUB     r%,PC,#(off%AND&FFFFF000)
 LDRB    r%,[r%,#-(off%AND&FFF)]
]
 ENDIF
=0

 DEF FNstr2(r%,a%,h%)
 LOCAL off%
 off%=(a%-P%-8)
 IF (off%>=0) THEN
[OPT pass%
 ADD     h%,PC,#(off%AND&FFFFF000)
 STR     r%,[h%,#(off%AND&FFF)]
]
 ELSE
 off%=-off%
[OPT pass%
 SUB     h%,PC,#(off%AND&FFFFF000)
 STR     r%,[h%,#-(off%AND&FFF)]
]
 ENDIF
=0

 DEF FNstrb2(r%,a%,h%)
 LOCAL off%
 off%=(a%-P%-8)
 IF (off%>=0) THEN
[OPT pass%
 ADD     h%,PC,#(off%AND&FFFFF000)
 STRB    r%,[h%,#(off%AND&FFF)]
]
 ELSE
 off%=-off%
[OPT pass%
 SUB     h%,PC,#(off%AND&FFFFF000)
 STRB    r%,[h%,#-(off%AND&FFF)]
]
 ENDIF
=0



 REM 32bit abstraction

 DEF FNModReturnOK
[OPT pass%
 TEQ     R0,R0
 TEQ     PC,PC
 MOVNES  PC,R14
 MSR     CPSR_f, #0
 MOV     PC,R14
]
=0


 DEF FNModReturnError
[OPT pass%
 TEQ     R0,R0
 TEQ     PC,PC
 ORRNES  PC,R14,#PFlag_V%
 MSR     CPSR_f,#PFlag_V%
 MOV     PC,R14
]
=0


 DEF FNAPCSReturnUser
[OPT pass%
 TEQ     R0,R0
 TEQ     PC,PC
 MOVNES  PC,R14
 MOV     PC,R14
]
=0


