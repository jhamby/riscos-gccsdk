 REM *******************************************************************
 REM *
 REM * Digital Renderer module source code
 REM *
 REM * Support for sound playback from applications
 REM * (C) 1997-2006 Andreas Dehmel (zarquon@t-online.de)
 REM *
 REM * This program is free software; you can redistribute it and/or modify
 REM * it under the terms of the GNU General Public License as published by
 REM * the Free Software Foundation; either version 2 of the License, or
 REM * (at your option) any later version.
 REM *
 REM * This program is distributed in the hope that it will be useful,
 REM * but WITHOUT ANY WARRANTY; without even the implied warranty of
 REM * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 REM * GNU General Public License for more details.
 REM *
 REM * You should have received a copy of the GNU General Public License
 REM * along with this program; if not, write to the Free Software
 REM * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 REM * 02111-1307  USA.
 REM *
 REM *******************************************************************

 ProgSize%=&3000

 DIM Code% ProgSize%, FSDate% 64

 LIBRARY "%.stdlib"

 REM mini buffer for putting samples, must be a multiple of 2!
 MiniBufferSize%=32

 Work_MagicWord%=0
 Work_Channels%=4: Work_BuffSize%=8: Work_Period%=12: Work_Buffer%=16: Work_Stat
e%=20
 Work_OldChannels%=24: Work_OldSize%=28: Work_OldPeriod%=32
 Work_OldEnable%=36: Work_OldVolume%=40
 Work_NumBuffers%=44: Work_WriteBuffer%=48: Work_ReadBuffer%=52: Work_RingBuffer
%=56
 Work_FillLevel%=60: Work_LastReadBuff%=64: Work_StreamFlags%=68: Work_ReadLevel
%=72
 Work_CallBackFill%=76: Work_BuffersPlayed%=80: Work_BuffersGiven%=84
 Work_VoiceSlot%=88: Work_OldVoiceName%=92: Work_LinToLog%=96: Work_LogScale%=10
0
 Work_PollWord%=104: Work_TotBuffSize%=108: Work_StreamHandle%=112: Work_StrExtH
and%=116
 Work_BuffOffset%=120: Work_OldStrFlags%=124: Work_OldNumBuff%=128: Work_RingIsF
ull%=132
 Work_Frequency%=136: Work_FreqIndex%=140: Work_OldFreqIndex%=144: Work_TableVol
ume%=148
 Work_OldLinHandler%=152: Work_OldLinParam%=156: Work_DMABuffSize%=160
 Work_SampleFormat%=164
 REM defaults for file interface
 Work_DfltChannels%=168: Work_DfltFormat%=172: Work_DfltPeriod%=176
 Work_DfltBuffSize%=180: Work_DfltBuffers%=184: Work_DfltFrequency%=188
 REM arrays of 8 ints:
 Work_OldVoices%=192: Work_OldCBWords%=Work_OldVoices%+8*4
 Work_MiniBuffer%=Work_OldCBWords%+8*4
 Work_LogTable%=Work_MiniBuffer%+MiniBufferSize%
 Work_SIZE%=Work_LogTable%+1024

 REM sound buffer states
 State_Active%=1: State_NeedData%=2: State_Overflow%=4: State_UpCall%=8
 State_Paused%=16: State_NewSound%=32: State_Restore16%=64

 REM formats (8bit ulaw, 16bit signed linear)
 Format_Undef%=0: Format_8u%=1: Format_16sl%=2: Format_16swap%=3

 REM shift factor for volume (assume 128 rather than 127)
 Volume_Shift%=7

 REM Filing system number (not allocated yet)
 FSNumber%=167

 Program%=0
 SWI_ChunkBase%=&4F700: SWI_XChunkBase%=SWI_ChunkBase% OR &20000
 XDR_Activate%=SWI_XChunkBase%: XDR_Deactivate%=SWI_XChunkBase%+1
 XDR_Pause%=SWI_XChunkBase%+2: XDR_Resume%=SWI_XChunkBase%+3
 XDR_GetTables%=SWI_XChunkBase%+4: XDR_ReadState%=SWI_XChunkBase%+5
 XDR_NewSample%=SWI_XChunkBase%+6: XDR_NewSamp16%=SWI_XChunkBase%+7
 XDR_BufferStat%=SWI_XChunkBase%+8: XDR_NumBuffers%=SWI_XChunkBase%+9
 XDR_StreamSamples%=SWI_XChunkBase%+10: XDR_StreamSamples16%=SWI_XChunkBase%+11
 XDR_StreamStatus%=SWI_XChunkBase%+12: XDR_StreamFlags%=SWI_XChunkBase%+13
 XDR_Defaults%=SWI_XChunkBase%+14
 XDR_Activate16%=SWI_XChunkBase%+15
 XDR_GetFrequency%=SWI_XChunkBase%+16
 XDR_ActivateAuto%=SWI_XChunkBase%+17
 XDR_SampleFormat%=SWI_XChunkBase%+18

 REM offset in SCCB where workspace pointer of this module is stored (PRM4-11)
 SCCB_PrivateOffset%=64

 REM magic word to make sure the workspace pointer is correct in the voice handl
er
 DigitalRendererMagicWord%=&444e5244: REM = DRND

 REM Stream flags
 StrFlg_OverrunNull%=1: REM fill buffer with 0 on an overrun
 StrFlg_IssueUpCall%=2: REM use upcalls for waiting
 StrFlg_OverBlock%=4:   REM block on stream overflow (otherwise truncate)

 REM DMA control block (as passed to Channel Handler in R9):
 DMACB_Header%=192

 REM Processor flags
 PFlag_V%=(1<<28): PFlag_C%=(1<<29): PFlag_IRQ%=(1<<27): PFlag_FIRQ%=(1<<26)
 PMode_User%=0: PMode_FIRQ%=1: PMode_IRQ%=2: PMode_SVC%=3

 REM store module's private word in SCCB#1 here.
 SCCB_PrivateWord%=64

 REM Sound control flags (offset 3 in SCCB)
 SFlag_F1%=1: SFlag_F2%=2: SFlag_Overrun%=4: SFlag_Active%=8
 SFlag_FPending%=16: SFlag_IPending%=32: SFlag_KPending%=64: SFlag_Qiet%=128

 REM compute current date for help string
 FSDate%?0=3: SYS "OS_Word",14,FSDate%
 SYS "OS_ConvertDateAndTime",FSDate%,FSDate%+5,59,"%DY %M3 %CE%YR" TO ,FSSize%
 FSSize% -= FSDate%+5

 FOR pass%=12 TO 14 STEP 2
 P%=Program%: O%=Code%: L%=Code%+ProgSize%
[OPT pass%
 EXT 1
 EQUD 0             ;start code
 EQUD InitCode
 EQUD FinalCode
 EQUD ServiceHandler
 EQUD TitleString
 EQUD HelpString
 EQUD HelpTable
 EQUD SWI_ChunkBase%
 EQUD SWIHandler
 EQUD SWIDecodingTable
 EQUD 0             ;SWI decoding code
 EQUD 0
 EQUD DRenderModuleFlags

.DRenderMagic
 EQUD    DigitalRendererMagicWord%
.DRenderModuleFlags
 EQUD    1

.InitCode
 STMDB   R13!,{R14}
 LDR     R2,[R12]
 CMP     R2,#0
 BNE     ICreinit
 MOV     R0,#6
 MOV     R3,#(Work_SIZE% AND &ff)
 ORR     R3,R3,#(Work_SIZE% AND &ff00)
 SWI     "XOS_Module"         ;get workspace
 BVS     InitError
 STR     R2,[R12]
 MOV     R0,R2
 MOV     R1,R3
 BL      MemSet
 LDR     R0,DRenderMagic
 STR     R0,[R2,#Work_MagicWord%]
.ICreinit
 MOV     R0,#1                ;defaults for 1channel 22kHz, 1 second buffer time
 STR     R0,[R2,#Work_DfltChannels%]
 MOV     R0,#Format_16sl%
 STR     R0,[R2,#Work_DfltFormat%]
 MOV     R0,#45
 STR     R0,[R2,#Work_DfltPeriod%]
 MOV     R0,#512
 STR     R0,[R2,#Work_DfltBuffSize%]
 MOV     R0,#43
 STR     R0,[R2,#Work_DfltBuffers%]
 MOV     R0,#(22050 AND &ff00)
 ORR     R0,R0,#(22050 AND &ff)
 STR     R0,[R2,#Work_DfltFrequency%]
 MOV     R0,#StrFlg_IssueUpCall%
 STR     R0,[R2,#Work_StreamFlags%]
 BL      RegisterFilingSystem
 LDMIA   R13!,{R14}
.ModuleReturnOK
 FNModReturnOK
.InitError
 ADR     R0,Error_Initialise
 LDMIA   R13!,{R14}
.ModuleReturnError
 FNModReturnError


.FinalCode
 STMDB   R13!,{R14}
 MOV     R4,R12               ;preserve private word
 LDR     R12,[R12]
 LDR     R0,[R12,#Work_State%]
 TST     R0,#State_Active%
 BLNE    RestoreOldContext
 CMP     R10,#0
 BEQ     FCnonfatal           ;if fatal free workspace
 MOV     R12,R4
 BL      DeregisterFilingSystem
 MOV     R0,#7
 LDR     R2,[R4]
 SWI     "XOS_Module"
 MOV     R0,#0
 STR     R0,[R4]              ;clear private word
.FCnonfatal
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FCcantquit
 ADR     R0,Error_NoHandlers
 LDMIA   R13!,{R14}
 B       ModuleReturnError


.ServiceHandler
 CMP     R1,#&40
 BNE     ModuleReturnOK
 B       RegisterFilingSystem


.MemSet                       ;clears buffer R0, size R1 to 0 (multiple of words
!)
 STMDB   R13!,{R14}           ;MUST BE SAFE FOR IRQ MODE!
.MemStIRQ
 STMDB   R13!,{R0-R5}         ;in IRQ mode, the caller must store the return add
ress!
 MOV     R2,#0
 MOV     R3,#0
 MOV     R4,#0
 MOV     R5,#0
 CMP     R1,#16
 BLT     MSsmall
.MSbig
 STMIA   R0!,{R2-R5}
 SUB     R1,R1,#16
 CMP     R1,#16
 BGE     MSbig
.MSsmall
 TST     R1,#8
 STMNEIA R0!,{R2,R3}
 TST     R1,#4
 STRNE   R2,[R0],#4
 LDMIA   R13!,{R0-R5,PC}      ;MEMSET DOESN'T RESTORE FLAGS! IRQ SAFE!


.Error_Initialise
 EQUD    0:  EQUS "Unable to initialise.": EQUB 0: ALIGN
.Error_BadSWI
 EQUD    1:  EQUS "Bad SWI number.": EQUB 0: ALIGN
.Error_NoReinit
 EQUD    2:  EQUS "Digital Renderer is already active.": EQUB 0: ALIGN
.Error_BadBuffSize
 EQUD    3:  EQUS "Bad buffer size (must be multiple of 16).": EQUB 0: ALIGN
.Error_Memory
 EQUD    4:  EQUS "Couldn't claim enough memory.": EQUB 0: ALIGN
.Error_Inactive
 EQUD    5:  EQUS "Digital renderer not activated.": EQUB 0: ALIGN
.Error_NoHandlers
 EQUD    6:  EQUS "Must install new Channel Handler / Scheduler first.": EQUB 0:
 ALIGN
.Error_RingBuffer
 EQUD    7:  EQUS "Ring buffer not initialized": EQUB 0: ALIGN
.Error_Install
 EQUD    8:  EQUS "Unable to install voice generator": EQUB 0: ALIGN
.Error_ParseError
 EQUB    9:  EQUS "Parse error in command": EQUB 0: ALIGN
.Error_No16Bit
 EQUD    10: EQUS "No 16bit sound available": EQUB 0: ALIGN
.Error_NoRate
 EQUD    11: EQUS "No sample rate found": EQUB 0: ALIGN
.Error_Channels16
 EQUD    12: EQUS "Number of channels must be 1 or 2 in 16bit mode": EQUB 0


.TitleString
 EQUS "DigitalRenderer": EQUB 0: ALIGN

.HelpString
 EQUS "DigitalRenderer": EQUB 9: EQUS "0.52 GPL ("+LEFT$($(FSDate%+5),FSSize%)+"
)": EQUB 13: EQUB 10
 EQUS "Provides a means to playback samples from applications. © 1997-2006 Andre
as Dehmel"
 EQUB 0: ALIGN

.HelpTable
 EQUS    "DRenderOff": EQUB 0: ALIGN
 EQUD    CommandDRoff
 EQUD    &0000ff00
 EQUD    0
 EQUD    Help_DRoff
 EQUS    "DRenderDefaults": EQUB 0: ALIGN
 EQUD    CommandDRdefault
 EQUD    &0010ff00
 EQUD    0
 EQUD    Help_DRdefault
 EQUS    "DRenderStatus": EQUB 0: ALIGN
 EQUD    CommandDRstatus
 EQUD    &0000ff00
 EQUD    0
 EQUD    Help_DRstatus
 EQUD    0

.Help_DRoff
 EQUS    "Switch off DigitalRenderer": EQUB 0: ALIGN
.Help_DRdefault
 EQUS    "Set the defaults or print the current ones if no parameters given"
 EQUB    13: EQUB 10: EQUB 9
 EQUS    "-c #: number of channels (1,2,4,8)"
 EQUB    13: EQUB 10: EQUB 9
 EQUS    "-f #: format (1: 8bit ulaw, 2: 16bit sl)"
 EQUB    13: EQUB 10: EQUB 9
 EQUS    "-p #: sample period (1e6/frequency)"
 EQUB    13: EQUB 10: EQUB 9
 EQUS    "-q #: sample frequency (for 16bit sound, zero to disable)"
 EQUB    13: EQUB 10: EQUB 9
 EQUS    "-s #: buffer size"
 EQUB    13: EQUB 10: EQUB 9
 EQUS    "-n #: number of buffers ( > 1!)"
 EQUB    0
 ALIGN
.Help_DRstatus
 EQUS    "Show current status": EQUB 0: ALIGN




.DoIntegerDivision
 STMDB   R13!,{R1-R2,R14}
 CMP     R1,#0
 MVNEQ   R0,#0
 BEQ     DUIVexit
 FNsmalldiv32(0,0,1,2,14)
 MOV     R0,R2
.DUIVexit
 LDMIA   R13!,{R1-R2,R14}
 B       ModuleReturnOK


.DisableRenderer
 STMDB   R13!,{R0-R3,R14}
 LDR     R1,[R12,#Work_StrExtHand%]
 CMP     R1,#0
 BEQ     DisRenNoFile
 MOV     R0,#0                ;make sure everything is closed correctly by using
 SWI     "XOS_Find"           ;the external handle
.DisRenNoFile
 LDR     R2,[R12,#Work_Buffer%]
 MOV     R0,#7
 CMP     R2,#0
 SWINE   "XOS_Module"
 MOV     R0,#0
 STR     R0,[R12,#Work_Buffer%]
 STR     R0,[R12,#Work_State%]
 LDMIA   R13!,{R0-R3,R14}
 B       ModuleReturnOK


.RestoreOldContext
 STMDB   R13!,{R0-R5,R14}
 MOV     R0,#1
 SWI     "XSound_Enable"      ;switch off sound prior to handler change
 LDR     R0,[R12,#Work_State%]
 TST     R0,#State_NewSound%
 BNE     ROCnewsound
 LDR     R0,[R12,#Work_VoiceSlot%]
 CMP     R0,#0
 BEQ     ROCnotinitialized
 ADD     R3,R12,#Work_OldVoices%
 LDR     R4,[R12,#Work_Channels%]
 MOV     R5,#0
.ROCunattachloop
 ADD     R0,R5,#1
 MOV     R1,#SCCB_PrivateOffset%
 LDR     R2,[R3,#(Work_OldCBWords%-Work_OldVoices%)]
 SWI     "XSound_WriteControlBlock"
 ADD     R0,R5,#1
 LDR     R1,[R3],#4
 SWI     "XSound_AttachVoice"
 ADD     R5,R5,#1
 CMP     R5,R4
 BLT     ROCunattachloop
 LDR     R1,[R12,#Work_VoiceSlot%]
 SWI     "XSound_RemoveVoice"
 MOV     R0,#0
 STR     R0,[R12,#Work_VoiceSlot%]
.ROCnotinitialized
 ADD     R0,R12,#Work_OldChannels%
 LDMIA   R0,{R0-R2}
 MOV     R3,#0
 MOV     R4,#0
 SWI     "XSound_Configure"   ;restore previous sound context
 B       ROCepilogue
.ROCnewsound
 LDR     R0,[R12,#Work_State%]
 TST     R0,#State_Restore16%
 BNE     ROCnewrestore
 MOV     R0,#1
 MOV     R1,#0
 MOV     R2,#0
 SWI     "XSound_LinearHandler"
 MOV     R0,#1
 STR     R0,[R12,#Work_OldEnable%] ;don't enable sound later on either
 B       ROCnewepilogue
.ROCnewrestore
 MOV     R0,#1
 LDR     R1,[R12,#Work_OldLinHandler%]
 LDR     R2,[R12,#Work_OldLinParam%]
 SWI     "XSound_LinearHandler"
 MOV     R0,#3
 LDR     R1,[R12,#Work_OldFreqIndex%]
 SWI     "XSound_SampleRate"
.ROCnewepilogue
 MOV     R0,#0
 STR     R0,[R12,#Work_OldLinHandler%]
 MOV     R0,#0
 LDR     R1,[R12,#Work_OldSize%]
 MOV     R2,#0
 MOV     R3,#0
 MOV     R4,#0
 SWI     "XSound_Configure"   ;restore old buffer size
.ROCepilogue
 BL      DisableRenderer      ;remove channel handler AFTER disabling sound!!!
 LDR     R0,[R12,#Work_OldVolume%]
 SWI     "XSound_Volume"
 LDR     R0,[R12,#Work_OldEnable%]
 SWI     "XSound_Enable"      ;again, enable is the last thing we do
 LDMIA   R13!,{R0-R5,R14}
 B       ModuleReturnOK



.SWIHandler
 CMP     R11,#((SWIJumpTableEnd-SWIJumpTableStart)>>2)
 ADDLO   PC,PC,R11,LSL #2
 B       SWI_NotSupported
.SWIJumpTableStart
 B       SWIActivate
 B       SWIDeactivate
 B       SWIPause
 B       SWIResume
 B       SWIGetTables
 B       SWIReadState
 B       SWINewSample
 B       SWINew16Sample
 B       SWIBufferStatistics
 B       SWINumBuffers
 B       SWIStreamSamples
 B       SWIStreamSamples16
 B       SWIStreamStatistics
 B       SWIStreamFlags
 B       SWISetDefaults
 B       SWIActivate16
 B       SWIGetFrequency
 B       SWIActivateAuto
 B       SWISampleFormat
.SWIJumpTableEnd

.SWI_NotSupported
 FNadr2("", 0, Error_BadSWI)
 B       ModuleReturnError


; Call
; ----
;
; R0 = Number of Channels (bits 0-7). bit 31 ==> r3 points to buffer fill code,
;      else use polling. All other bits reserved.
; R1 = sample length
; R2 = sample period
; R3 = ^ buffer fill code if R0 bit 31 set.
;
; returns with all registers preserved

.SWIActivate                  ;claim buffer, init channel handler
 STMDB   R13!,{R0-R5,R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_Buffer%]
 CMP     R14,#0
 BNE     SWIActNoReinit
 LDR     R14,[R12,#Work_State%]
 TST     R14,#State_Active%
 BNE     SWIActNoReinit
 TST     R1,#15
 BNE     SWIActBuffSize
 MOV     R4,R0
 MOV     R0,#1                ;switch off sound before reconfiguring
 SWI     "XSound_Enable"
 STR     R0,[R12,#Work_OldEnable%]
 TST     R4,#(1<<31)
 MOVEQ   R3,#0
 STR     R3,[R12,#Work_CallBackFill%]
 ANDS    R0,R4,#&FF
 MOVEQ   R0,#1                ;limit channels to 1,2,4 or 8 (rounding up)
 CMP     R0,#3
 MOVEQ   R0,#4
 CMP     R0,#5
 MOVCS   R0,#8
 ADD     R14,R12,#Work_Channels%
 STMIA   R14,{R0-R2}
 MUL     R14,R0,R1
 STR     R14,[R12,#Work_TotBuffSize%]
 CMP     R3,#0
 MOVNE   R2,#0
 STRNE   R2,[R12,#Work_Buffer%]
 BNE     SWIActNoBuff         ;don't need a buffer in case of callback handler
 LDR     R3,[R12,#Work_TotBuffSize%]
 MOV     R0,#6
 SWI     "XOS_Module"         ;get RMA buffer for data
 BVS     SWIActMemory
 STR     R2,[R12,#Work_Buffer%]
 MOVS    R0,R2
 MOV     R1,R3
 BLNE    MemSet
.SWIActNoBuff
 MOV     R0,#0
 MOV     R1,#0
 MOV     R2,#0
 MOV     R3,#0
 MOV     R4,#0
 SWI     "XSound_Configure"   ;get table pointers from old Channel Handler
 ADD     R14,R12,#Work_OldChannels%
 STMIA   R14,{R0-R2}          ;store old sound context
 LDR     R14,[R3,#8]          ;memorize lin2log table
 STR     R14,[R12,#Work_LinToLog%]
 LDR     R14,[R3,#12]
 STR     R14,[R12,#Work_LogScale%]
; MOV     R3,R0
 ADD     R0,R12,#Work_Channels%
 LDMIA   R0,{R0-R2}
; CMP     R0,R3                 ;did we have more channels configured than we ne
ed?
; MOVLT   R0,R3                 ;yes ==> keep number of channels
; STRLT   R0,[R12,#Work_Channels%]
 MOV     R3,#0
 MOV     R4,#0
 SWI     "XSound_Configure"
 MOV     R0,#0
 SWI     "XSound_Volume"
 STR     R0,[R12,#Work_OldVolume%]
 MOV     R0,#(State_Active% + State_NeedData%)
 STR     R0,[R12,#Work_State%]
 MOV     R0,#0
 STR     R0,[R12,#Work_BuffersPlayed%]
 STR     R0,[R12,#Work_BuffersGiven%] ;reset buffer statistics
 STR     R0,[R12,#Work_RingIsFull%]
 BL      FreeRingBufferBuffers
 BL      ClaimRingBufferBuffers
 ; install voice
 FNadr2("", 0, DigitalVoiceGenerator)
 MOV     R1,#0
 SWI     "XSound_InstallVoice"
 STR     R0,[R12,#Work_OldVoiceName%]
 STR     R1,[R12,#Work_VoiceSlot%]
 CMP     R1,#0
 BEQ     SWIActInstall
 ADD     R3,R12,#Work_OldVoices%
 LDR     R4,[R12,#Work_Channels%]
 MOV     R5,#0
.SWIActVoiceLoop
 ADD     R0,R5,#1               ;first write a pointer to workspace into the SCC
B
 MOV     R1,#SCCB_PrivateOffset%;and memorize the old value
 MOV     R2,R12
 SWI     "XSound_WriteControlBlock"
 STR     R2,[R3,#(Work_OldCBWords%-Work_OldVoices%)]
 ADD     R0,R5,#1
 LDR     R1,[R12,#Work_VoiceSlot%]
 SWI     "XSound_AttachVoice"
 STR     R1,[R3],#4
 ADD     R5,R5,#1
 CMP     R5,R4
 BLT     SWIActVoiceLoop
 ; voices installed
 MOV     R0,#Format_8u%
 STR     R0,[R12,#Work_SampleFormat%]
 MOV     R0,#2
 SWI     "XSound_Enable"      ;enable sound as last action
 ; fire voices
 LDR     R4,[R12,#Work_Channels%]
 MOV     R0,#1
 MOV     R1,#&0180
 MOV     R2,#&8000
 MOV     R3,#&ff
.SWIActFireLoop
 SWI     "XSound_Control"
 ADD     R0,R0,#1
 CMP     R0,R4
 BLE     SWIActFireLoop
 LDMIA   R13!,{R0-R5,R14}
 B       ModuleReturnOK
.SWIActNoReinit
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R5,R14}
 FNadr2("", 0, Error_NoReinit)
 B       ModuleReturnError
.SWIActBuffSize
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R5,R14}
 FNadr2("", 0, Error_BadBuffSize)
 B       ModuleReturnError
.SWIActMemory2
 LDR     R2,[R12,#Work_Buffer%]
 MOV     R0,#7
 CMP     R2,#0
 SWINE   "XOS_Module"
 MOV     R0,#0
 STR     R0,[R12,#Work_Buffer%]
.SWIActMemory
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R5,R14}
 FNadr2("", 0, Error_Memory)
 B       ModuleReturnError
.SWIActInstall
 ADD     R13,R13,#4
 LDMIA   R13,{R1-R5,R14}
 FNadr2("", 0, Error_Install)
 B       ModuleReturnError


; Call
; ----
;
; no input, all registers preserved

.SWIDeactivate                ;free buffer, restore channel handler
 STMDB   R13!,{R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_State%]
 TST     R14,#State_Active%
 BEQ     SWIDecInactive
 BL      RestoreOldContext
 BL      FreeRingBuffer
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.SWIDecInactive
 FNadr2("", 0, Error_Inactive)
 LDMIA   R13!,{R14}
 B       ModuleReturnError


; Call
; ----
;
; no input, all registers preserved

.SWIPause                     ;pause playback
 STMDB   R13!,{R0,R14}
 LDR     R0,[R12]
 LDR     R14,[R0,#Work_State%]
 TST     R14,#State_Active%
 BEQ     SWIPsInactive
 ORR     R14,R14,#State_Paused%
 STR     R14,[R0,#Work_State%]
 MOV     R0,#1
 SWI     "XSound_Enable"
 LDMIA   R13!,{R0,R14}
 B       ModuleReturnOK
.SWIPsInactive
 FNadr2("", 0, Error_Inactive)
 ADD     R13,R13,#4
 LDMIA   R13!,{R14}
 B       ModuleReturnError


; Call
; ----
;
; no input, all registers preserved

.SWIResume                    ;resume playback
 STMDB   R13!,{R0,R14}
 LDR     R0,[R12]
 LDR     R14,[R0,#Work_State%]
 TST     R14,#State_Active%
 BEQ     SWIRsInactive
 BIC     R14,R14,#State_Paused%
 STR     R14,[R0,#Work_State%]
 MOV     R0,#2
 SWI     "XSound_Enable"
 LDMIA   R13!,{R0,R14}
 B       ModuleReturnOK
.SWIRsInactive
 FNadr2("",0,Error_Inactive)
 ADD     R13,R13,#4
 LDMIA   R13!,{R14}
 B       ModuleReturnError


; Call
; ----
;
; no input. Returns with R0 = ^LinToLog, R1 = ^LogScale

.SWIGetTables                 ;get pointers to LinToLog and LogScale tables
 LDR     R0,[R12]
 LDR     R1,[R0,#Work_State%]
 TST     R1,#State_Active%
 BEQ     SWIGTInactive
 LDR     R1,[R0,#Work_LogScale%]
 LDR     R0,[R0,#Work_LinToLog%]
 B       ModuleReturnOK
.SWIGTInactive
 FNadr2("",0,Error_Inactive)
 B       ModuleReturnError


; Call
; ----
;
; no input. Returns Work_State in R0

.SWIReadState                 ;read state (has valid buffer yes/no)
 LDR     R0,[R12]
 LDR     R0,[R0,#Work_State%]
 B       ModuleReturnOK


; Call
; ----
;
; R0 = pointer to buffer with sample, all registers preserved

.SWINewSample                 ;read sample from external buffer into internal bu
ffer
 STMDB   R13!,{R0-R3,R14}
 LDR     R12,[R12]
 LDR     R3,[R12,#Work_State%]
 TST     R3,#State_Active%
 BEQ     SWINSInactive
 BIC     R3,R3,#State_NeedData%
 STR     R3,[R12,#Work_State%]
 LDR     R1,[R12,#Work_Buffer%]
 CMP     R1,#0
 BEQ     SWINSInactive
 LDR     R2,[R12,#Work_BuffersGiven%]
 ADD     R2,R2,#1
 STR     R2,[R12,#Work_BuffersGiven%]
 LDR     R2,[R12,#Work_TotBuffSize%]
 TST     R3,#State_NewSound%
 BNE     SNSnewsound
 BL      CopyByteBuffer
 LDMIA   R13!,{R0-R3,R14}
 B       ModuleReturnOK
.SNSnewsound
 MOV     R2,R2,LSR #1         ;this call needs the number of _samples_!
 BL      CopyByteToShortBuffer
 LDMIA   R13!,{R0-R3,R14}
 B       ModuleReturnOK
.SWINSInactive
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R3,R14}
 FNadr2("",0,Error_Inactive)
 B       ModuleReturnError


; Call
; ----
;
; R0 = pointer to buffer holding sampled (16 bit signed), all registers preserve
d

.SWINew16Sample
 STMDB   R13!,{R0-R3,R14}
 LDR     R12,[R12]
 LDR     R3,[R12,#Work_State%]
 TST     R3,#State_Active%
 BEQ     SWINS16Inactive
 BIC     R3,R3,#State_NeedData%
 STR     R3,[R12,#Work_State%]
 LDR     R1,[R12,#Work_Buffer%]
 CMP     R1,#0
 BEQ     SWINS16Inactive
 LDR     R2,[R12,#Work_BuffersGiven%]
 ADD     R2,R2,#1
 STR     R2,[R12,#Work_BuffersGiven%]
 LDR     R2,[R12,#Work_TotBuffSize%]
 TST     R3,#State_NewSound%
 BNE     SNS16newsound
 BL      CopyShortBuffer
 LDMIA   R13!,{R0-R3,R14}
 B       ModuleReturnOK
.SNS16newsound
 MOV     R2,R2,LSR #1          ;this call needs the number of _samples_!
 BL      CopyShortToShortBuffer
 LDMIA   R13!,{R0-R3,R14}
 B       ModuleReturnOK
.SWINS16Inactive
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R3,R14}
 FNadr2("",0,Error_Inactive)
 B       ModuleReturnError


; Call
; ----
;
; returns R0 = "BuffersPlayed", R1 = "BuffersGiven"

.SWIBufferStatistics
 LDR     R12,[R12]
 LDR     R0,[R12,#Work_BuffersPlayed%]
 LDR     R1,[R12,#Work_BuffersGiven%]
 B       ModuleReturnOK


; Call
; ----
;
; R0 = number of buffers to use, or -1 to read.
; returns number of buffers in R0

.SWINumBuffers
 STMDB   R13!,{R1-R4,R14}
 LDR     R12,[R12]
 MOVS    R4,R0
 LDR     R0,[R12,#Work_NumBuffers%]
 BLT     SWINBexit
 CMP     R0,R4
 BEQ     SWINBexit
 BL      FreeRingBuffer
 CMP     R4,#0
 BLE     SWINBexit
 MOV     R3,R4,LSL #2
 MOV     R0,#6
 SWI     "XOS_Module"
 BVS     SWINBerrmem
 MOV     R14,#0
.SWINBclearloop
 SUBS    R3,R3,#4
 STR     R14,[R2,R3]
 BGT     SWINBclearloop
 STR     R2,[R12,#Work_RingBuffer%] ;must be safe against IRQ fill code
 STR     R4,[R12,#Work_NumBuffers%]
 MOV     R0,R4
.SWINBexit
 LDMIA   R13!,{R1-R4,R14}
 B       ModuleReturnOK
.SWINBerrmem
 LDMIA   R13!,{R1-R4,R14}
 MVN     R0,#0
 B       ModuleReturnOK


; Call
; ----
;
; R0 = pointer to buffer holding 8bit samples, r1 = number of samples
; no return value

.SWIStreamSamples
 STMDB   R13!,{R0-R11,R14}
 LDR     R12,[R12]
 MOV     R10,#1
 LDR     R2,[R12,#Work_State%]
 TST     R2,#State_NewSound%
 BNE     SSSnewsound
 MOV     R11,#1
 FNadr2("",9,CopyByteBuffer)
 B       StreamSampleCore
.SSSnewsound
 MOV     R11,#2
 FNadr2("",9,CopyByteToShortBuffer)
 B       StreamSampleCore


; Call
; ----
;
; R0 = pointer to buffer holding 16bit samples, r1 = number of samples
; no return value

.SWIStreamSamples16
 STMDB   R13!,{R0-R11,R14}
 LDR     R12,[R12]
 MOV     R10,#2
 LDR     R2,[R12,#Work_State%]
 TST     R2,#State_NewSound%
 BNE     SSS16newsound
 MOV     R11,#1
 FNadr2("",9,CopyShortBuffer)
 B       StreamSampleCore
.SSS16newsound
 MOV     R11,#2
 FNadr2("",9,CopyShortToShortBuffer)
 B       StreamSampleCore


; Call
; ----
;
; returns number of filled buffers

.SWIStreamStatistics
 STMDB   R13!,{R1,R14}
 LDR     R12,[R12]
 LDR     R0,[R12,#Work_WriteBuffer%]
 LDR     R1,[R12,#Work_ReadBuffer%]
 SUBS    R0,R0,R1
 LDR     R1,[R12,#Work_NumBuffers%]
 BEQ     SWISSequal            ;if both are equal check for the RingFull status
 ADDLT   R0,R0,R1
 LDR     R1,[R12,#Work_FillLevel%] ;if any data was written to the buffer, add 1
 CMP     R1,#0
 ADDNE   R0,R0,#1
 LDMIA   R13!,{R1,R14}
 B       ModuleReturnOK
.SWISSequal
 LDR     R0,[R12,#Work_RingIsFull%]
 CMP     R0,#0
 MOVNE   R0,R1                ;if the ring is full, return num buffers, otherwis
e 0
 LDMIA   R13!,{R1,R14}
 B       ModuleReturnOK


; Call
; ----
;
; R0 = eor mask, r1 = and mask (applied first), (0,-1) to read
; returns old flags in r0

.SWIStreamFlags
 STMDB   R13!,{R1,R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_StreamFlags%]
 AND     R1,R1,R14
 EOR     R1,R1,R0
 STR     R1,[R12,#Work_StreamFlags%]
 MOV     R0,R14
 LDMIA   R13!,{R1,R14}
 B       ModuleReturnOK


; Call
; ----
;
; R0 = channels, R1 = format, R2 = sample period, R3 = sample length, R4 = buffe
rs
; R5 = frequency, or for each parameter 0 to read
; returns with the currently valid configuration

.SWISetDefaults
 LDR     R12,[R12]
 CMP     R0,#0
 LDREQ   R0,[R12,#Work_DfltChannels%]
 STRNE   R0,[R12,#Work_DfltChannels%]
 CMP     R1,#0
 LDREQ   R1,[R12,#Work_DfltFormat%]
 STRNE   R1,[R12,#Work_DfltFormat%]
 CMP     R2,#0
 LDREQ   R2,[R12,#Work_DfltPeriod%]
 STRNE   R2,[R12,#Work_DfltPeriod%]
 CMP     R3,#0
 LDREQ   R3,[R12,#Work_DfltBuffSize%]
 STRNE   R3,[R12,#Work_DfltBuffSize%]
 CMP     R4,#0
 LDREQ   R4,[R12,#Work_DfltBuffers%]
 STRNE   R4,[R12,#Work_DfltBuffers%]
 CMP     R5,#0
 LDREQ   R5,[R12,#Work_DfltFrequency%]
 STRNE   R5,[R12,#Work_DfltFrequency%]
 B       ModuleReturnOK


; Call
; ----
;
; R0 = number of channels (1 or 2), R1 = buffer size, R2 = frequency, R3 = flags
; flags is a bitfield using 0 (restore old handler on exit)
; returns with all registers preserved

.SWIActivate16
 STMDB   R13!,{R0-R6,R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_Buffer%]
 CMP     R14,#0
 BNE     SWIAct16Reinit
 LDR     R14,[R12,#Work_State%]
 TST     R14,#State_Active%
 BNE     SWIAct16Reinit
 CMP     R0,#1
 CMPNE   R0,#2
 BNE     SWIAct16Channels
 STR     R0,[R12,#Work_Channels%]
 STR     R1,[R12,#Work_BuffSize%]
 STR     R2,[R12,#Work_Frequency%]
 MUL     R0,R1,R0
 MOV     R0,R0,LSL #1
 STR     R0,[R12,#Work_TotBuffSize%] ; total buffer size = num channels * buffsi
ze * 2
 TST     R3,#1
 MOVEQ   R0,#0
 MOVNE   R0,#State_Restore16%
 STR     R0,[R12,#Work_State%]
 MOV     R0,#0
 SWI     "XSound_Mode"
 BVS     SWIAct16GenErr
 CMP     R0,#0
 BEQ     SWIAct16NotAvailable
 MOV     R0,#0
 SWI     "XSound_Volume"
 STR     R0,[R12,#Work_OldVolume%]
 MOV     R0,#1
 SWI     "XSound_Enable"             ; switch off sound before reconfiguring
 STR     R0,[R12,#Work_OldEnable%]
 MOV     R0,#1
 SWI     "XSound_SampleRate"
 BVS     SWIAct16GenErr
 STR     R1,[R12,#Work_OldFreqIndex%]; this is the index, not the actual frequen
cy (r2)!
 MOV     R0,#0
 LDR     R1,[R12,#Work_BuffSize%]
 MOV     R2,#0
 MOV     R3,#0
 MOV     R4,#0
 SWI     "XSound_Configure"          ; try to configure the buffer size
 STR     R1,[R12,#Work_OldSize%]
 MOV     R0,#0
 SWI     "XSound_SampleRate"         ; read number of sample rates to r1
 MOV     R3,R1
 MVN     R4,#0                       ; best match so far (signed)
 MVN     R5,#0                       ; error so far (unsigned)
 LDR     R6,[R12,#Work_Frequency%]
 MOV     R1,#1                       ; sample rate indices start at 1!
.SWIAct16FindRate                    ; primitive linear search...
 MOV     R0,#2
 SWI     "XSound_SampleRate"
 BVS     SWIAct16SkipRate
 SUBS    R2,R2,R6,LSL #10
 RSBLT   R2,R2,#0
 CMP     R2,R5
 MOVCC   R4,R1
 MOVCC   R5,R2
.SWIAct16SkipRate
 ADD     R1,R1,#1
 CMP     R1,R3
 BLE     SWIAct16FindRate            ; sample rate indices are 1-based
 CMP     R4,#0
 BLT     SWIAct16NoRate
 STR     R4,[R12,#Work_FreqIndex%]
 MOV     R1,R4
 MOV     R0,#2
 SWI     "XSound_SampleRate"
 MOV     R2,R2,LSR #10
 STR     R2,[R12,#Work_Frequency%]
 MOV     R0,#3
 SWI     "XSound_SampleRate"         ; switch on the new sample rate
 MOV     R0,#6
 LDR     R3,[R12,#Work_TotBuffSize%]
 SWI     "XOS_Module"
 BVS     SWIAct16Memory
 MOVS    R0,R2
 BEQ     SWIAct16Memory
 STR     R2,[R12,#Work_Buffer%]
 MOV     R1,R3
 BL      MemSet
 MOV     R0,#0
 SWI     "XSound_LinearHandler"      ; read old linear handler
 STR     R1,[R12,#Work_OldLinHandler%]
 STR     R2,[R12,#Work_OldLinParam%]
 MOV     R0,#1
 FNadr2("", 1, LinearHandlerCode)
 MOV     R2,R12
 SWI     "XSound_LinearHandler"      ; install new linear handler
 LDR     R0,[R12,#Work_State%]
 ORR     R0,R0,#(State_Active% + State_NeedData% + State_NewSound%)
 STR     R0,[R12,#Work_State%]
 MOV     R0,#0
 STR     R0,[R12,#Work_BuffersPlayed%]
 STR     R0,[R12,#Work_BuffersGiven%]
 STR     R0,[R12,#Work_RingIsFull%]
 BL      FreeRingBufferBuffers
 BL      ClaimRingBufferBuffers
 MOV     R0,#Format_16sl%
 STR     R0,[R12,#Work_SampleFormat%]
 MOV     R0,#2
 SWI     "XSound_Enable"             ; turn on sound
 LDMIA   R13!,{R0-R6,R14}
 B       ModuleReturnOK
.SWIAct16Reinit
 FNadr2("", 0, Error_NoReinit)
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R6,R14}
 B       ModuleReturnError
.SWIAct16NotAvailable
 FNadr2("", 0, Error_No16Bit)
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R6,R14}
 B       ModuleReturnError
.SWIAct16NoRate
 FNadr2("", 0, Error_NoRate)
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R6,R14}
 B       ModuleReturnError
.SWIAct16Channels
 FNadr2("", 0, Error_Channels16)
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R6,R14}
 B       ModuleReturnError
.SWIAct16Memory
 FNadr2("", 0, Error_Memory)
.SWIAct16GenErr
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R6,R14}
 B       ModuleReturnError



; Call
; ----
;
; returns frequency in r0, or 0 if inactive

.SWIGetFrequency
 STMDB   R13!,{R1,R14}
 LDR     R12,[R12]
 LDR     R0,[R12,#Work_State%]
 TST     R0,#State_Active%
 MOVEQ   R0,#0
 BEQ     SWIGFexit
 TST     R0,#State_NewSound%
 LDRNE   R0,[R12,#Work_Frequency%]
 BNE     SWIGFexit
 LDR     R0,Constant_Mega
 LDR     R1,[R12,#Work_Period%]
 ADD     R0,R0,R1,LSR #1             ;for rounding
 BL      DoIntegerDivision
.SWIGFexit
 LDMIA   R13!,{R1,R14}
 B       ModuleReturnOK



; Call
; ----
;
; R0 = number of channels, R1 = buffer size, R2 = frequency
; returns with all registers preserved

.SWIActivateAuto
 STMDB   R13!,{R0-R4,R14}
 MOV     R4,R0
 MOV     R3,#1                       ;restore old handler
 SWI     XDR_Activate16%
 BVC     SWIAAexit
 MOV     R3,R1
 LDR     R0,Constant_Mega
 MOV     R1,R2
 ADD     R0,R0,R1,LSR #1             ;for rounding
 BL      DoIntegerDivision
 MOV     R2,R0
 MOV     R0,R4
 MOV     R1,R3
 SWI     XDR_Activate%
 BVS     SWIAAGenErr
.SWIAAexit
 LDMIA   R13!,{R0-R4,R14}
 B       ModuleReturnOK
.SWIAAGenErr
 ADD     R13,R13,#4
 LDMIA   R13!,{R1-R4,R14}
 B       ModuleReturnError



; Call
; ----
;
; R0 = new sample format or 0 to read
; returns sample format

.SWISampleFormat
 LDR     R12,[R12]
 CMP     R0,#0
 LDREQ   R0,[R12,#Work_SampleFormat%]
 STRNE   R0,[R12,#Work_SampleFormat%]
 B       ModuleReturnOK





.Constant_Mega                       ;used for conversions period <--> frequency
 EQUD    1000000



.SWIDecodingTable
 EQUS "DigitalRenderer": EQUB 0
 EQUS "Activate": EQUB 0
 EQUS "Deactivate": EQUB 0
 EQUS "Pause": EQUB 0
 EQUS "Resume": EQUB 0
 EQUS "GetTables": EQUB 0
 EQUS "ReadState": EQUB 0
 EQUS "NewSample": EQUB 0
 EQUS "New16BitSample": EQUB 0
 EQUS "BufferStatistics": EQUB 0
 EQUS "NumBuffers": EQUB 0
 EQUS "StreamSamples": EQUB 0
 EQUS "Stream16BitSamples": EQUB 0
 EQUS "StreamStatistics": EQUB 0
 EQUS "StreamFlags": EQUB 0
 EQUS "SetDefaults": EQUB 0
 EQUS "Activate16": EQUB 0
 EQUS "GetFrequency": EQUB 0
 EQUS "ActivateAuto": EQUB 0
 EQUS "SampleFormat": EQUB 0
 EQUB 0: ALIGN



;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 8bit sound handler ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

.DigitalVoiceGenerator
 B       VoiceFillCode         ;fill code
 B       VoiceFillCode         ;update code
 B       VoiceFillCode         ;gate on code
 B       VoiceFillCode         ;gate off code
 LDMIA   R13!,{PC}
 LDMIA   R13!,{PC}
 LDMIA   R13!,{PC}
 EQUD    VoiceGeneratorName - DigitalVoiceGenerator
.VoiceGeneratorName
 EQUS    "DigitalRenderer": EQUB 0: ALIGN


.VoiceFillCode
 CMP     R7,#0                 ;only do something for the first channel
 BNE     CHFCexit
 LDR     R0,[R9,#SCCB_PrivateOffset%]   ;retrieve module workspace pointer
 FNldr2(1, DRenderMagic)
 LDR     R4,[R0,#Work_MagicWord%]
 CMP     R1,R4
 BNE     CHFCexit              ;the private word pointer got corrupted somehow!
 LDR     R1,[R0,#Work_State%]
 TST     R1,#State_NeedData%
 ORRNE   R1,R1,#State_Overflow%         ;if data needed flag set, overflow occur
red
 BICEQ   R1,R1,#State_Overflow%
 ORR     R1,R1,#State_NeedData%
 STR     R1,[R0,#Work_State%]
 LDR     R1,[R0,#Work_BuffersPlayed%]
 ADD     R1,R1,#1
 STR     R1,[R0,#Work_BuffersPlayed%]
 SUB     R1,R10,R12
 STR     R1,[R0,#Work_DMABuffSize%]
 LDR     R4,[R0,#Work_CallBackFill%]
 CMP     R4,#0
 BNE     CHFCcallback
 LDR     R4,[R0,#Work_NumBuffers%]      ;stream mode?
 CMP     R4,#0
 BNE     CHFCstreaming
 LDR     R0,[R0,#Work_Buffer%]          ;R0 = ^internal buffer
 CMP     R0,#0
 BEQ     CHFCexit
.CHFCBegin
 SUB     R4,R10,R12
 CMP     R4,#32
 BLT     CHFCsmall
.CHFCbig
 LDMIA   R0!,{R1,R2,R5-R9,R11}
 STMIA   R12!,{R1,R2,R5-R9,R11}
 SUB     R4,R4,#32
 CMP     R4,#32
 BGE     CHFCbig
.CHFCsmall
 TST     R4,#16
 LDMNEIA R0!,{R5-R8}
 STMNEIA R12!,{R5-R8}
 TST     R4,#8
 LDMNEIA R0!,{R1,R2}
 STMNEIA R12!,{R1,R2}
 TST     R4,#4
 LDRNE   R1,[R0],#4
 STRNE   R1,[R12],#4
.CHFCDone
.CHFCexit
 MOV     R0,#(1<<3)           ;active (normal fill)
 LDMIA   R13!,{PC}

.CHFCcallback
 TEQ     R0,R0
 TEQ     PC,PC
 MOVEQ   R1,#0
 ANDNE   R1,PC,#&fc000003
 ADR     R2,CHFCDone
 ORR     R1,R1,R2
 STMDB   R13!,{R1}
 LDR     R1,[R0,#Work_LinToLog%]
 LDR     R3,[R0,#Work_CallBackFill%]
 SUB     R2,R10,R12           ;R2 = buffer size
 MOV     R0,R12
 MOV     PC,R3                ;call handler

.CHFCstreaming                          ;R4 = num buffers
 MOV     R5,R0
 MOV     R0,#1
 STR     R0,[R5,#Work_PollWord%]        ;on every buffer refill loop, set poll w
ord
 LDR     R3,[R5,#Work_RingBuffer%]
 CMP     R3,#0
 BEQ     CHFCovernull
 LDR     R0,[R5,#Work_WriteBuffer%]
 LDR     R6,[R5,#Work_ReadBuffer%]
 CMP     R0,R6
 BNE     CHFCloopstream
 LDR     R0,[R5,#Work_RingIsFull%]      ;is the ring empty or completely full?
 CMP     R0,#0
 BNE     CHFCloopstream
.CHFCchkoveract
 LDR     R0,[R5,#Work_StreamFlags%]
 TST     R0,#StrFlg_OverrunNull%
 BNE     CHFCovernull
 LDR     R6,[R5,#Work_LastReadBuff%]
 CMP     R6,R4
 MOVCS   R6,#0                          ;in case LastReadBuff >= NumBuffers...
 MOV     R4,#0                          ;buffer overrun ==> set R4 to 0
 STR     R4,[R5,#Work_ReadLevel%]
.CHFCloopstream
 LDR     R0,[R3,R6,LSL #2]
 CMP     R0,#0
 BEQ     CHFCexit
 LDR     R7,[R5,#Work_ReadLevel%]
 LDR     R8,[R5,#Work_TotBuffSize%]
 CMP     R7,R8
 MOVCS   R7,#0                          ;additional security
 ADD     R0,R0,R7
 SUB     R1,R8,R7                       ;bytes remaining in source buffer
 SUB     R2,R10,R12                     ;bytes remaining in DMA buffer
 CMP     R2,R1
 MOVCS   R2,R1
 ADR     R1,CHFCcopyreturn              ;IRQ CODE STORES RETURN ADDRESS BEFORE C
ALL!
 STMDB   R13!,{R1}
 MOV     R1,R12
 B       CopyByteBuffIRQ                ;CAN'T USE R14 IN IRQ MODE!!!
.CHFCcopyreturn
 ADD     R12,R12,R2
 STR     R6,[R5,#Work_LastReadBuff%]
 ADD     R7,R7,R2                        ;increment read level
 CMP     R7,R8
 STRCC   R7,[R5,#Work_ReadLevel%]
 BCC     CHFCnobuffinc
 MOV     R7,#0
 STR     R7,[R5,#Work_ReadLevel%]
 CMP     R4,#0
 BEQ     CHFCnobuffinc                   ;buffer overrun ==> don't increment rea
d buffer
 ADD     R6,R6,#1
 CMP     R6,R4
 MOVCS   R6,#0
 STR     R6,[R5,#Work_ReadBuffer%]
 LDR     R0,[R5,#Work_WriteBuffer%]      ;if ReadBuffer == WriteBuffer after inc
rementing
 CMP     R6,R0                           ;the buffer is completely empty.
 BNE     CHFCnobuffinc
 MOV     R0,#0
 STR     R0,[R5,#Work_RingIsFull%]       ;make a note for StreamStatistics
 CMP     R12,R10
 BCC     CHFCchkoveract
.CHFCnobuffinc
 CMP     R12,R10
 BCC     CHFCloopstream
 B       CHFCexit
.CHFCovernull
 MOV     R0,#0
 STR     R0,[R5,#Work_RingIsFull%]
 MOV     R0,R12
 ADR     R1,CHFCexit
 STMDB   R13!,{R1}
 SUB     R1,R10,R12
 B       MemStIRQ                        ;CAN'T USE R14 IN IRQ MODE!




;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 16bit sound handler ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;

.LinearHandlerCode
 STMDB   R13!,{R12,R14}
 MOV     R12,R0
 LDR     R0,[R12,#Work_State%]
 TST     R0,#State_NeedData%
 ORRNE   R0,R0,#State_Overflow%
 BICEQ   R0,R0,#State_Overflow%
 ORR     R0,R0,#State_NeedData%
 STR     R0,[R12,#Work_State%]
 LDR     R0,[R12,#Work_BuffersPlayed%]
 ADD     R0,R0,#1
 STR     R0,[R12,#Work_BuffersPlayed%]
 SUB     R2,R2,R1                        ;buffer length
 STR     R2,[R12,#Work_DMABuffSize%]
 LDR     R4,[R12,#Work_NumBuffers%]
 CMP     R4,#0
 BNE     LHCstreaming
 LDR     R0,[R12,#Work_Buffer%]
 CMP     R0,#0
 BEQ     LHCexit
 LDR     R3,[R12,#Work_Channels%]
 LDR     R4,[R12,#Work_TotBuffSize%]
 CMP     R3,#1
 MOVEQ   R4,R4,LSL #1
 CMP     R2,R4
 MOVCS   R2,R4
 BL      CopyLinearBuffer                ;does 1->2 channel expansion if necessa
ry
.LHCexit
 LDMIA   R13!,{R12,R14}
 B       ModuleReturnOK

.LHCstreaming                            ;streaming interface, similar to Voice
handler
 MOV     R0,#1
 STR     R0,[R12,#Work_PollWord%]
 LDR     R3,[R12,#Work_RingBuffer%]
 CMP     R3,#0
 BEQ     LHCovernull
 LDR     R10,[R12,#Work_Channels%]       ;number of channels in r10
 MOV     R9,R2                           ;number of bytes left in r9
 LDR     R0,[R12,#Work_WriteBuffer%]
 LDR     R6,[R12,#Work_ReadBuffer%]
 CMP     R0,R6
 BNE     LHCloopstream
 LDR     R0,[R12,#Work_RingIsFull%]
 CMP     R0,#0
 BNE     LHCloopstream
.LHCchkoveract
 LDR     R0,[R12,#Work_StreamFlags%]
 TST     R0,#StrFlg_OverrunNull%
 BNE     LHCovernull
 LDR     R6,[R12,#Work_LastReadBuff%]
 CMP     R6,R4
 MOVCS   R6,#0
 MOV     R4,#0
 STR     R4,[R12,#Work_ReadLevel%]
.LHCloopstream
 LDR     R0,[R3,R6,LSL #2]
 CMP     R0,#0
 BEQ     LHCovernull
 LDR     R7,[R12,#Work_ReadLevel%]
 LDR     R8,[R12,#Work_TotBuffSize%]
 CMP     R7,R8
 MOVCS   R7,#0
 ADD     R0,R0,R7
 SUB     R2,R8,R7
 CMP     R10,#1
 MOVEQ   R2,R2,LSL #1                    ;1 channel ==> pretend twice as many sa
mples
 CMP     R2,R9
 MOVCS   R2,R9
 BL      CopyLinearBuffer
 ADD     R1,R1,R2
 SUB     R9,R9,R2
 STR     R6,[R12,#Work_LastReadBuff%]
 CMP     R10,#1
 ADDEQ   R7,R7,R2,LSR #1
 ADDNE   R7,R7,R2
 CMP     R7,R8
 STRCC   R7,[R12,#Work_ReadLevel%]
 BCC     LHCnobuffinc
 MOV     R7,#0
 STR     R7,[R12,#Work_ReadLevel%]
 CMP     R4,#0
 BEQ     LHCnobuffinc
 ADD     R6,R6,#1
 CMP     R6,R4
 MOVCS   R6,#0
 STR     R6,[R12,#Work_ReadBuffer%]
 LDR     R0,[R12,#Work_WriteBuffer%]
 CMP     R6,R0
 BNE     LHCnobuffinc
 MOV     R0,#0
 STR     R0,[R12,#Work_RingIsFull%]
 CMP     R9,#0
 BGT     LHCchkoveract
.LHCnobuffinc
 CMP     R9,#0
 BGT     LHCloopstream
.LHCovernull
 LDMIA   R13!,{R12,R14}
 B       ModuleReturnOK






.FreeRingBufferBuffers         ;R12 = ^workspace
 STMDB   R13!,{R0-R4,R14}
 LDR     R3,[R12,#Work_RingBuffer%]
 LDR     R1,[R12,#Work_NumBuffers%]
 SUBS    R1,R1,#1
 BLT     FRBBexit
 MOV     R0,#7
 MOV     R4,#0
.FRBBloop
 LDR     R2,[R3,R1,LSL #2]
 CMP     R2,#0
 STRNE   R4,[R3,R1,LSL #2]     ;must be safe against IRQ fill code!
 SWINE   "XOS_Module"
 SUBS    R1,R1,#1
 BGE     FRBBloop
.FRBBexit
 LDMIA   R13!,{R0-R4,R14}
 B       ModuleReturnOK


.FreeRingBuffer
 STMDB   R13!,{R0-R2,R14}
 LDR     R2,[R12,#Work_RingBuffer%]
 CMP     R2,#0
 BEQ     FRBexit
 BL      FreeRingBufferBuffers
 MOV     R0,#0
 STR     R0,[R12,#Work_RingBuffer%] ;must be safe against IRQ fill code!
 MOV     R0,#7
 SWI     "XOS_Module"
 MOV     R2,#0
 STR     R2,[R12,#Work_RingBuffer%]
 STR     R2,[R12,#Work_NumBuffers%]
.FRBexit
 LDMIA   R13!,{R0-R2,R14}
 B       ModuleReturnOK


.ClaimRingBufferBuffers           ;R12 = ^workspace
 STMDB   R13!,{R1-R5,R14}
 LDR     R5,[R12,#Work_NumBuffers%]
 SUBS    R5,R5,#1
 BLT     CRBexit
 LDR     R4,[R12,#Work_RingBuffer%]
 CMP     R4,#0
 BEQ     CRBexit
 LDR     R3,[R12,#Work_TotBuffSize%]
.CRBloop
 MOV     R0,#6
 SWI     "XOS_Module"
 BVS     CRBerror
 MOVS    R0,R2
 MOV     R1,R3
 BLNE    MemSet
 STR     R2,[R4,R5,LSL #2]
 SUBS    R5,R5,#1
 BGE     CRBloop
.CRBexit
 MOV     R0,#0
 STR     R0,[R12,#Work_RingIsFull%]
 STR     R0,[R12,#Work_ReadBuffer%]
 STR     R0,[R12,#Work_WriteBuffer%]
 STR     R0,[R12,#Work_FillLevel%]
 STR     R0,[R12,#Work_ReadLevel%]
 LDMIA   R13!,{R1-R5,R14}
 B       ModuleReturnOK
.CRBerror
 MVN     R0,#0
 LDMIA   R13!,{R1-R5,R14}
 B       ModuleReturnOK



.StreamSampleCore                   ;r9 pointer to copy code, r10 src sample siz
e
 LDR     R8,[R12,#Work_RingBuffer%] ;r11 dest sample size
 CMP     R8,#0
 BEQ     SSCexit
 MOVS    R3,R1
 BLE     SSCexit
 LDR     R4,[R12,#Work_TotBuffSize%]
 LDR     R5,[R12,#Work_WriteBuffer%]
 LDR     R6,[R12,#Work_NumBuffers%]
 LDR     R7,[R12,#Work_FillLevel%]
 LDR     R1,[R12,#Work_ReadBuffer%]
 CMP     R1,R5
 BNE     SSCmainloop
 LDR     R14,[R12,#Work_RingIsFull%]
 CMP     R14,#0
 MOVNE   R2,#0
 BNE     SSCcheckblock
.SSCmainloop
 SUB     R2,R4,R7                   ;buffer size - fill level = bytes in buffer
 CMP     R11,#1                     ;but we need samples!
 MOVNE   R2,R2,LSR #1               ;in case we're using 16bit sound samples = b
ytes/2
 CMP     R2,R3
 MOVGT   R2,R3
 LDR     R1,[R8,R5,LSL #2]          ;ringbuffer[writebuffer]
 CMP     R1,#0
 BEQ     SSCskipbuffer
 ADD     R1,R1,R7                   ;add fill level to dest buffer
 ADR     R14,SSCskipbuffer          ;return address (called code doesn't preserv
e flags)
 MOV     PC,R9
.SSCskipbuffer
 MLA     R0,R10,R2,R0               ;src = src + src_sample_size * samples
 MLA     R7,R11,R2,R7               ;dest = dest + dest_sample_size * samples
 STR     R7,[R12,#Work_FillLevel%]
 CMP     R7,R4
 BLT     SSCexit
 MOV     R7,#0
 STR     R7,[R12,#Work_FillLevel%]
 ADD     R5,R5,#1
 CMP     R5,R6
 MOVGE   R5,#0
 STR     R5,[R12,#Work_WriteBuffer%]
 LDR     R1,[R12,#Work_ReadBuffer%]  ;if WriteBuffer == ReadBuffer _after_ incre
menting,
 CMP     R5,R1                       ;the ring buffer is filled completely.
 BNE     SSCspaceleft
 MOV     R14,#1
 STR     R14,[R12,#Work_RingIsFull%] ;make a note of this (for StreamStatistics)
.SSCcheckblock
 LDR     R14,[R12,#Work_StreamFlags%]
 TST     R14,#StrFlg_OverBlock%      ;what to do on an overflow; block?
 BEQ     SSCexit                     ;no blocking ==> truncate
 LDR     R14,[R12,#Work_State%]
 TST     R14,#State_Paused%
 BNE     SSCexit                     ;if paused, we must NOT block!
.SSCblockloop
 LDR     R14,[R12,#Work_ReadBuffer%]
 CMP     R14,R1                      ;R1 is still the current read buffer
 BEQ     SSCblockloop
.SSCspaceleft
 SUBS    R3,R3,R2
 BGT     SSCmainloop
.SSCexit
 LDMIA   R13!,{R0-R11,R14}
 B       ModuleReturnOK


; THIS CODE MUST BE IRQ SAFE!
.CopyByteBuffer               ;r0 = src, r1 = dest, r2 = size
 STMDB   R13!,{R14}
.CopyByteBuffIRQ              ;in IRQ mode, the caller must store the return add
ress
 STMDB   R13!,{R0-R7}
 CMP     R2,#0
 BLE     CBBexit
.CBBdoalign
 TST     R1,#3
 BEQ     CBBisaligned
 LDRB    R3,[R0],#1
 STRB    R3,[R1],#1
 SUBS    R2,R2,#1
 BGT     CBBdoalign
.CBBisaligned
 CMP     R2,#0
 BEQ     CBBexit
 AND     R3,R0,#3
 ADD     PC,PC,R3,LSL #2
 MOV     R0,R0
 B       CopyByteBuffer0
 B       CopyByteBuffer1
 B       CopyByteBuffer2
 B       CopyByteBuffer3

.CopyByteBuffer0
 SUBS    R2,R2,#16
 BLT     CBB0small
.CBB0big
 LDMIA   R0!,{R3-R6}
 STMIA   R1!,{R3-R6}
 SUBS    R2,R2,#16
 BGE     CBB0big
.CBB0small
 ADDS    R2,R2,#16
 BLE     CBBexit
 TST     R2,#8
 LDMNEIA R0!,{R3,R4}
 STMNEIA R1!,{R3,R4}
 TST     R2,#4
 LDRNE   R3,[R0],#4
 STRNE   R3,[R1],#4
 ANDS    R2,R2,#3
 BEQ     CBBexit
.CBBtail
 LDRB    R3,[R0],#1
 STRB    R3,[R1],#1
 SUBS    R2,R2,#1
 BGT     CBBtail
.CBBexit
 LDMIA   R13!,{R0-R7,PC}      ;DON'T RESTORE FLAGS! IRQ SAFE!

.CopyByteBuffer1
 FNCopyBytes(1)
.CopyByteBuffer2
 FNCopyBytes(2)
.CopyByteBuffer3
 FNCopyBytes(3)


; this code is only run in SVC mode, but doesn't preserve flags
.CopyShortBuffer              ;R12 = *workspace
 STMDB   R13!,{R0-R11,R14}
 CMP     R2,#0
 BLE     CSBexit
 LDR     R11,[R12,#Work_LinToLog%]
.CSBdoalign
 TST     R1,#3
 BEQ     CSBisaligned
 LDRB    R3,[R0],#1
 LDRB    R4,[R0],#1
 ORR     R3,R3,R4,LSL #8
 LDRB    R3,[R11,R3,LSR #3]
 STRB    R3,[R1],#1
 SUBS    R2,R2,#1
 BGT     CSBdoalign
.CSBisaligned
 CMP     R2,#0
 BEQ     CSBexit
 TST     R0,#1
 BNE     CopyShortBuffer1

.CopyShortBuffer0
 SUBS    R2,R2,#8
 BLT     CSB0small
.CSB0big
 LDMIA   R0!,{R4,R6,R8,R10}
 FNConvertToUlaw(11,3,4)
 FNConvertToUlaw(11,5,6)
 ORR     R3,R3,R5,LSL #16
 FNConvertToUlaw(11,7,8)
 FNConvertToUlaw(11,9,10)
 ORR     R7,R7,R9,LSL #16
 STMIA   R1!,{R3,R7}
 SUBS    R2,R2,#8
 BGE     CSB0big
.CSB0small
 ADDS    R2,R2,#8
 BLE     CSBexit
 TST     R2,#4
 BEQ     CSB0tiny
 LDMIA   R0!,{R4,R6}
 FNConvertToUlaw(11,3,4)
 FNConvertToUlaw(11,5,6)
 ORR     R3,R3,R5,LSL #16
 STR     R3,[R1],#4
.CSB0tiny
 TST     R2,#2
 BEQ     CSB0rest
 LDR     R4,[R0], #4
 FNConvertToUlaw(11,3,4)
 STRB    R3,[R1],#1
 MOV     R3,R3,LSR #8
 STRB    R3,[R1],#1
.CSB0rest
 TST     R2,#1
 BEQ     CSBexit
 LDRB    R3,[R0],#1
 LDRB    R4,[R0],#1
 ORR     R3,R3,R4,LSL #8
 LDRB    R3,[R11,R3,LSR #3]
 STRB    R3,[R1],#1
.CSBexit
 LDMIA   R13!,{R0-R11,PC}

.CopyShortBuffer1
 BIC     R0,R0,#3
 LDR     R14,[R0],#4
 LDRB    R14,[R11,R14,LSR #19]
 SUBS    R2,R2,#8
 BLT     CSB1small
.CSB1big
 LDMIA   R0!,{R4,R6,R8,R10}
 FNConvertToUlaw(11,3,4)
 FNConvertToUlaw(11,5,6)
 ORR     R3,R14,R3,LSL #8
 ORR     R3,R3,R5,LSL #24
 MOV     R5,R5,LSR #8
 FNConvertToUlaw(11,7,8)
 FNConvertToUlaw(11,9,10)
 ORR     R5,R5,R7,LSL #8
 ORR     R5,R5,R9,LSL #24
 STMIA   R1!,{R3,R5}
 MOV     R14,R9,LSR #8
 SUBS    R2,R2,#8
 BGE     CSB1big
.CSB1small
 ADDS    R2,R2,#8
 BLE     CSBexit
 TST     R2,#4
 BEQ     CSB1tiny
 LDMIA   R0!,{R4,R6}
 FNConvertToUlaw(11,3,4)
 FNConvertToUlaw(11,5,6)
 ORR     R3,R14,R3,LSL #8
 ORR     R3,R3,R5,LSL #24
 STR     R3,[R1],#4
 MOV     R14,R5,LSR #8
.CSB1tiny
 TST     R2,#2
 BEQ     CSB1rest
 LDR     R4,[R0],#4
 FNConvertToUlaw(11,3,4)
 ORR     R3,R14,R3,LSL #8
 STRB    R3,[R1],#1
 STRB    R3,[R1],#1
 MOV     R14,R3,LSR #16
.CSB1rest
 TST     R2,#1
 STRNEB  R14,[R1],#1
 LDMIA   R13!,{R0-R11,PC}



.CopyByteToShortBuffer               ; doesn't preserve flags
 STMDB   R13!,{R0-R4,R14}
 CMP     R2,#0
 BLE     CBSBexit
 BL      EnsureLogTable
 ADD     R3,R12,#Work_LogTable%
 BIC     R1,R1,#1                    ; just to be on the safe side
 TST     R1,#2
 BEQ     CBSBaligned
 LDRB    R4,[R0],#1
 LDR     R4,[R3,R4,LSL #2]
 STRB    R4,[R1],#1
 MOV     R4,R4,LSR #8
 STRB    R4,[R1],#1
 SUBS    R2,R2,#1
 BLE     CBSBexit
.CBSBaligned
 SUBS    R2,R2,#2
 BLT     CBSBrest
.CBSBbigloop
 LDRB    R4,[R0],#1
 LDR     R4,[R3,R4,LSL #2]
 LDRB    R14,[R0],#1
 LDR     R14,[R3,R14,LSL #2]
 ORR     R4,R4,R14,LSL #16
 STR     R4,[R1],#4
 SUBS    R2,R2,#2
 BGE     CBSBbigloop
.CBSBrest
 ADDS    R2,R2,#2
 BLE     CBSBexit
 LDRB    R4,[R0],#1
 LDR     R4,[R3,R4,LSL #2]
 STRB    R4,[R1],#1
 MOV     R4,R4,LSR #8
 STRB    R4,[R1],#1
.CBSBexit
 LDMIA   R13!,{R0-R4,PC}


; old version without volume scaling
;.CopyShortToShortBuffer
; STMDB   R13!,{R2,R14}
; MOV     R2,R2,LSL #1
; BL      CopyByteBuffer
; LDMIA   R13!,{R2,PC}^

.CopyShortToShortBuffer             ;doesn't preserve flags
 STMDB   R13!,{R0-R7,R14}
 CMP     R2,#0
 BLE     CSSBexit
 MOV     R3,R0                      ;now r3 = source
 MOV     R0,#0
 SWI     "XSound_Volume"
 BIC     R1,R1,#1
 BIC     R3,R3,#1
 MVN     R6,#0
 MOV     R6,R6,LSR #16              ;R6 = mask &ffff
 TST     R1,#2
 BEQ     CSSBaligned
 LDRB    R4,[R3],#1
 LDRB    R14,[R3],#1
 MOV     R14,R14,LSL #24
 ORR     R4,R4,R14,ASR #16
 MUL     R4,R0,R4
 MOV     R4,R4,ASR #Volume_Shift%
 STRB    R4,[R1],#1
 MOV     R4,R4,LSR #8
 STRB    R4,[R1],#1
 SUBS    R2,R2,#1
 BLE     CSSBexit
.CSSBaligned
 TST     R3,#2
 BNE     CSSBshift1
 SUBS    R2,R2,#4
 BLT     CSSBs0small
.CSSBs0big
 LDMIA   R3!,{R4-R5}
 FNscalesamples(4,14,6)
 FNscalesamples(5,14,6)
 STMIA   R1!,{R4-R5}
 SUBS    R2,R2,#4
 BGE     CSSBs0big
.CSSBs0small
 ADDS    R2,R2,#4
 BLE     CSSBexit
 TST     R2,#2
 BEQ     CSSBs0rest
 LDR     R4,[R3],#4
 FNscalesamples(4,14,6)
 STR     R4,[R1],#4
.CSSBs0rest
 TST     R2,#1
 BEQ     CSSBexit
 LDRB    R4,[R3],#1
 LDRB    R14,[R3],#1
 MOV     R14,R14,LSL #24
 ORR     R4,R4,R14,ASR #16
 MUL     R4,R0,R4
 MOV     R4,R4,ASR #Volume_Shift%
 STRB    R4,[R1],#1
 MOV     R4,R4,LSR #8
 STRB    R4,[R1],#1
.CSSBexit
 LDMIA   R13!,{R0-R7,PC}

.CSSBshift1
 BIC     R3,R3,#2
 LDR     R4,[R3],#4
 MOV     R4,R4,ASR #16
 SUBS    R2,R2,#4
 BLT     CSSBs1small
.CSSBs1big
 LDMIA   R3!,{R5,R7}
 FNscalesampshft(4,5,14,6)
 MOV     R5,R5,ASR #16
 FNscalesampshft(5,7,14,6)
 STMIA   R1!,{R4,R5}
 MOV     R4,R7,ASR #16
 SUBS    R2,R2,#4
 BGE     CSSBs1big
.CSSBs1small
 ADDS    R2,R2,#4
 BLE     CSSBexit
 TST     R2,#2
 BEQ     CSSBs1rest
 LDR     R5,[R3],#4
 FNscalesampshft(4,5,14,6)
 STR     R4,[R1],#4
 MOV     R4,R5,ASR #16
.CSSBs1rest
 TST     R2,#1
 BEQ     CSSBexit
 MUL     R4,R0,R4
 MOV     R4,R4,ASR #Volume_Shift%
 STRB    R4,[R1],#1
 MOV     R4,R4,LSR #8
 STRB    R4,[R1],#1
 LDMIA   R13!,{R0-R7,PC}            ;no flags




.EnsureLogTable
 STMDB   R13!,{R0,R14}
 MOV     R0,#0
 SWI     "XSound_Volume"
 LDR     R14,[R12,#Work_TableVolume%]
 CMP     R0,R14
 BEQ     ELTexit
 STMDB   R13!,{R1-R5}
 STR     R0,[R12,#Work_TableVolume%]
 FNadr2("", 1, LogarithmicTable)
 ADD     R2,R12,#Work_LogTable%
 MOV     R3,#128
 MVN     R5,#0
 MOV     R5,R5,LSR #16               ;bitmask &ffff
.ELTmakeloop
 LDR     R4,[R1], #4
 MUL     R4,R0,R4
 ADD     R4,R4,#64                   ;round-to-nearest
 MOV     R4,R4,LSR #Volume_Shift%
 RSB     R14,R4,#0
 AND     R14,R14,R5                  ;store negative values with bits 16-31 clea
r!
 STMIA   R2!,{R4,R14}
 SUBS    R3,R3,#1
 BGT     ELTmakeloop
 LDMIA   R13!,{R1-R5}
.ELTexit
 LDMIA   R13!,{R0,R14}
 B       ModuleReturnOK


.CopyLinearBuffer                    ;r0 = src, r1 = dest, r2 = num bytes (dest)
 CMP     R2,#0
 MOVLE   PC,R14                      ;doesn't preserve flags
 STMDB   R13!,{R14}                  ;called by 16bit sound handler only!
 LDR     R14,[R12,#Work_Channels%]
 CMP     R14,#1
 BEQ     CLBexpand
 LDR     R14,[R12,#Work_SampleFormat%]
 CMP     R14,#Format_16swap%
 BEQ     CLBswaplinear               ;2 channels, but wrong order
 BL      CopyByteBuffer              ;2 channels ==> just copy the whole thing
 LDMIA   R13!,{PC}

.CLBexpand
 STMDB   R13!,{R0-R10}
 BIC     R1,R1,#3                    ;dest only makes sense word-aligned!
 BIC     R0,R0,#1
 TST     R0,#2
 BEQ     CLBaligned
 LDRB    R3,[R0],#1
 LDRB    R14,[R0],#1
 ORR     R3,R3,R14,LSL #8
 ORR     R3,R3,R3,LSL #16
 STR     R3,[R1],#4
 SUBS    R2,R2,#4
 BLE     CLBexpdone
.CLBaligned
 SUBS    R2,R2,#32
 BLT     CLBexprest
.CLBbigloop
 LDMIA   R0!,{R4,R6,R8,R10}
 FNexpandsample(3,4)
 FNexpandsample(5,6)
 FNexpandsample(7,8)
 FNexpandsample(9,10)
 STMIA   R1!,{R3-R10}
 SUBS    R2,R2,#32
 BGE     CLBbigloop
.CLBexprest
 ADDS    R2,R2,#32
 BLE     CLBexpdone
 TST     R2,#16
 BEQ     CLBexpsmall
 LDMIA   R0!,{R4,R6}
 FNexpandsample(3,4)
 FNexpandsample(5,6)
 STMIA   R1!,{R3-R6}
.CLBexpsmall
 TST     R2,#8
 BEQ     CLBexptiny
 LDR     R4,[R0],#4
 FNexpandsample(3,4)
 STMIA   R1!,{R3,R4}
.CLBexptiny
 TST     R2,#4
 BEQ     CLBexpdone
 LDRB    R3,[R0],#1
 LDRB    R14,[R0],#1
 ORR     R3,R3,R14,LSL #8
 ORR     R3,R3,R3,LSL #16
 STR     R3,[R1],#4
.CLBexpdone
 LDMIA   R13!,{R0-R10,PC}            ;no flags

.CLBswaplinear
 STMDB   R13!,{R0-R7}
 BIC     R1,R1,#3                   ;dest only makes sense word-aligned
 BIC     R0,R0,#1
 TST     R0,#2
 BNE     CLBswapshift1
 SUBS    R2,R2,#16
 BLT     CLBss0small
.CLBss0big
 LDMIA   R0!,{R3-R6}
 MOV     R3,R3,ROR #16
 MOV     R4,R4,ROR #16
 MOV     R5,R5,ROR #16
 MOV     R6,R6,ROR #16
 STMIA   R1!,{R3-R6}
 SUBS    R2,R2,#16
 BGE     CLBss0big
.CLBss0small
 ADDS    R2,R2,#16
 BLE     CLBswapexit
 TST     R2,#8
 BEQ     CLBss0tiny
 LDMIA   R0!,{R3,R4}
 MOV     R3,R3,ROR #16
 MOV     R4,R4,ROR #16
 STMIA   R1!,{R3,R4}
.CLBss0tiny
 TST     R2,#4
 LDRNE   R3,[R0],#4
 MOVNE   R3,R3,ROR #16
 STRNE   R3,[R1],#4
 TST     R2,#2                      ;this shouldn't normally happen
 LDRNE   R3,[R0],#4
 MOVNE   R3,R3,LSL #16
 STRNE   R3,[R1],#4
.CLBswapexit
 LDMIA   R13!,{R0-R7,PC}            ;no flags
.CLBswapshift1
 BIC     R0,R0,#3
 LDR     R3,[R0],#4
 MOV     R3,R3,LSR #16
 SUBS    R2,R2,#16
 BLT     CLBss1small
.CLBss1big
 LDMIA   R0!,{R4-R7}
 ORR     R3,R3,R4,LSL #16
 MOV     R3,R3,ROR #16
 MOV     R4,R4,LSR #16
 ORR     R4,R4,R5,LSL #16
 MOV     R4,R4,ROR #16
 MOV     R5,R5,LSR #16
 ORR     R5,R5,R6,LSL #16
 MOV     R5,R5,ROR #16
 MOV     R6,R6,LSR #16
 ORR     R6,R6,R7,LSL #16
 MOV     R6,R6,ROR #16
 STMIA   R1!,{R3-R6}
 MOV     R3,R7,LSR #16
 SUBS    R2,R2,#16
 BGE     CLBss1big
.CLBss1small
 ADDS    R2,R2,#16
 BLE     CLBswapexit
 TST     R2,#8
 BEQ     CLBss1tiny
 LDMIA   R0!,{R4,R5}
 ORR     R3,R3,R4,LSL #16
 MOV     R3,R3,ROR #16
 MOV     R4,R4,LSR #16
 ORR     R4,R4,R5,LSL #16
 MOV     R4,R4,ROR #16
 STMIA   R1!,{R3,R4}
 MOV     R3,R5,LSR #16
.CLBss1tiny
 TST     R2,#4
 BEQ     CLBss1rest
 LDR     R4,[R0],#4
 ORR     R3,R3,R4,LSL #16
 MOV     R3,R3,ROR #16
 STR     R3,[R1],#4
 MOV     R3,R4,LSR #16
.CLBss1rest
 TST     R2,#2                      ;this shouldn't normally happen
 MOVNE   R3,R3,LSL #16
 STRNE   R3,[R1],#4
 LDMIA   R13!,{R0-R7,PC}            ;no flags




; COMMANDS

.CommandDRoff
 STMDB   R13!,{R14}
 SWI     XDR_Deactivate%
 BVS     CDRerror
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.CDRerror
 LDMIA   R13!,{R14}
 B       ModuleReturnError


.CommandDRdefault
 STMDB   R13!,{R14}
 LDR     R12,[R12]
 MOV     R4,#0
.CDRDparse
 LDRB    R14,[R0],#1
 CMP     R14,#32
 BEQ     CDRDparse
 BLT     CDRDfinish
 CMP     R14,#ASC("-")
 BNE     CDRDbadargs
 LDRB    R3,[R0],#1
 CMP     R3,#ASC("c")
 CMPNE   R3,#ASC("f")
 CMPNE   R3,#ASC("p")
 CMPNE   R3,#ASC("s")
 CMPNE   R3,#ASC("n")
 CMPNE   R3,#ASC("q")
 BNE     CDRDbadargs
 ADD     R4,R4,#1
 MOV     R1,R0
 MOV     R0,#10
 SWI     "XOS_ReadUnsigned"
 BVS     CDRDbadargs
 MOV     R0,R1
 CMP     R3,#ASC("c")
 STREQ   R2,[R12,#Work_DfltChannels%]
 CMP     R3,#ASC("f")
 STREQ   R2,[R12,#Work_DfltFormat%]
 CMP     R3,#ASC("p")
 STREQ   R2,[R12,#Work_DfltPeriod%]
 CMP     R3,#ASC("s")
 STREQ   R2,[R12,#Work_DfltBuffSize%]
 CMP     R3,#ASC("n")
 STREQ   R2,[R12,#Work_DfltBuffers%]
 CMP     R3,#ASC("q")
 STREQ   R2,[R12,#Work_DfltFrequency%]
 B       CDRDparse
.CDRDfinish
 CMP     R4,#0
 BEQ     CDRDprintstate
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.CDRDprintstate
 FNPrintConfig(ConfStr_Channels, Work_DfltChannels%)
 ADR     R0,ConfStr_Format
 SWI     "XOS_Write0"
 LDR     R14,[R12,#Work_DfltFormat%]
 ADR     R0,ConfStr_FmtUndef
 CMP     R14,#Format_8u%
 ADREQ   R0,ConfStr_Fmt8u
 CMP     R14,#Format_16sl%
 ADREQ   R0,ConfStr_Fmt16sl
 CMP     R14,#Format_16swap%
 ADREQ   R0,ConfStr_Fmt16swap
 SWI     "XOS_Write0"
 FNPrintConfig(ConfStr_Period, Work_DfltPeriod%)
 FNPrintConfig(ConfStr_Frequency, Work_DfltFrequency%)
 FNPrintConfig(ConfStr_BuffSize, Work_DfltBuffSize%)
 FNPrintConfig(ConfStr_Buffers, Work_DfltBuffers%)
 SWI     "XOS_NewLine"
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.CDRDbadargs
 FNadr2("", 0, Error_ParseError)
 LDMIA   R13!,{R14}
 B       ModuleReturnError

.ConfStr_Channels
 EQUS    "Channels: ": EQUB 0: ALIGN
.ConfStr_Format
 EQUS    ". Format: ": EQUB 0: ALIGN
.ConfStr_Period
 EQUS    ". Period: ": EQUB 0: ALIGN
.ConfStr_Frequency
 EQUS    ". Frequency: ": EQUB 0: ALIGN
.ConfStr_BuffSize
 EQUS    ". Buffer size: ": EQUB 0: ALIGN
.ConfStr_Buffers
 EQUS    ". Num buffers: ": EQUB 0: ALIGN
.ConfStr_FmtUndef
 EQUS    "undefined": EQUB 0: ALIGN
.ConfStr_Fmt8u
 EQUS    "8bit ulaw": EQUB 0: ALIGN
.ConfStr_Fmt16sl
 EQUS    "16bit signed linear": EQUB 0: ALIGN
.ConfStr_Fmt16swap
 EQUS    "16bit signed linear swapped": EQUB 0: ALIGN

.CommandDRstatus
 STMDB   R13!,{R14}
 LDR     R12,[R12]
 LDR     R3,[R12,#Work_State%]
 TST     R3,#State_Active%
 BEQ     CDRSinactive
 ADR     R0,ConfStr_Active
 SWI     "XOS_Write0"
 TST     R3,#State_Paused%
 BEQ     CDRSnopause
 ADR     R0,ConfStr_Paused
 SWI     "XOS_Write0"
.CDRSnopause
 LDR     R0,[R12,#Work_StreamHandle%]
 CMP     R0,#0
 BEQ     CDRSnofile
 ADR     R0,ConfStr_FileStream
 SWI     "XOS_Write0"
.CDRSnofile
 LDR     R0,[R12,#Work_NumBuffers%]
 CMP     R0,#0
 BEQ     CDRSnostream
 FNPrintConfig(ConfStr_Streaming, Work_NumBuffers%)
 ADR     R0,ConfStr_StreamFilled
 SWI     "XOS_Write0"
 SWI     XDR_StreamStatus%
 FNPrintNumber
.CDRSnostream
 MOV     R0,#ASC(" ")
 SWI     "XOS_WriteC"
 FNPrintConfig(ConfStr_Channels, Work_Channels%)
 TST     R3,#State_NewSound%
 BEQ     CDRSoldsound
 FNPrintConfig(ConfStr_Frequency, Work_Frequency%)
 B       CDRSmergesound
.CDRSoldsound
 FNPrintConfig(ConfStr_Period, Work_Period%)
.CDRSmergesound
 FNPrintConfig(ConfStr_BuffSize, Work_BuffSize%)
 B       CDRSdone
.CDRSinactive
 ADR     R0,ConfStr_Inactive
 SWI     "XOS_Write0"
.CDRSdone
 SWI     "XOS_NewLine"
 LDMIA   R13!,{R14}
 B       ModuleReturnOK

.ConfStr_Active
 EQUS    "Active": EQUB 0: ALIGN
.ConfStr_Paused
 EQUS    ", Paused": EQUB 0: ALIGN
.ConfStr_FileStream
 EQUS    ", Pseudodevice": EQUB 0: ALIGN
.ConfStr_Streaming
 EQUS    ", Streaming buffers: ": EQUB 0: ALIGN
.ConfStr_StreamFilled
 EQUS    ", filled: ": EQUB 0: ALIGN
.ConfStr_Inactive
 EQUS    "Inactive.": EQUB 0: ALIGN




; FILING SYSTEM

.RegisterFilingSystem
 STMDB   R13!,{R0-R4,R14}
 MOV     R0,#12
 FNadr2("",1,Program%)
 MOV     R2,#((FilingSystemBlock - Program%) AND &ff)
 ORR     R2,R2,#((FilingSystemBlock - Program%) AND &ff00)
 MOV     R3,R12
 SWI     "XOS_FSControl"
 LDMIA   R13!,{R0-R5,R14}
 B       ModuleReturnOK


.DeregisterFilingSystem
 STMDB   R13!,{R0,R1,R14}
 MOV     R0,#16
 ADR     R1,FSName
 SWI     "XOS_FSControl"
 LDMIA   R13!,{R0,R1,R14}
 B       ModuleReturnOK


.FilingSystemBlock
 EQUD    FSName
 EQUD    FSStartup
 EQUD    FSEntry_Open
 EQUD    FSEntry_GetBytes
 EQUD    FSEntry_PutBytes
 EQUD    FSEntry_Args
 EQUD    FSEntry_Close
 EQUD    FSEntry_File
 EQUD    FSNumber% + (1 << 8) + (&38 << 16) + (&38 << 24)
 EQUD    FSEntry_Func
 EQUD    FSEntry_GBPB

.FSName
 EQUS    "DRender": EQUB 0: ALIGN
.FSStartup
 EQUB    0: ALIGN
.FSDfltSaveName
 EQUS    "DRender:": EQUB 0: ALIGN


.Error_FSread
 EQUD    (FSNumber%<<8) +  0: EQUS "Filing system is write-only": EQUB 0: ALIGN
.Error_FSbusy
 EQUD    (FSNumber%<<8) +  1: EQUS "Filing system is busy": EQUB 0: ALIGN
.Error_FShandle
 EQUD    (FSNumber%<<8) +  2: EQUS "Bad file handle": EQUB 0: ALIGN
.Error_FSargnum
 EQUD    (FSNumber%<<8) +  3: EQUS "Bad FS_Args number": EQUB 0: ALIGN
.Error_FSfunction
 EQUD    (FSNumber%<<8) +  4: EQUS "Unsupported FS_Function": EQUB 0: ALIGN


.FSIssueUpCall
 STMDB   R13!,{R0,R1,R14}
 LDR     R0,[R12,#Work_StreamFlags%]
 TST     R0,#StrFlg_IssueUpCall%
 BEQ     FSIUCexit
 MOV     R0,#0
 STR     R0,[R12,#Work_PollWord%]
 LDR     R0,[R12,#Work_State%]
 ORR     R0,R0,#State_UpCall%
 STR     R0,[R12,#Work_State%]
 MOV     R0,#6
 ADD     R1,R12,#Work_PollWord%
 SWI     "XOS_UpCall"
 LDR     R0,[R12,#Work_State%]
 BIC     R0,R0,#State_UpCall%
 STR     R0,[R12,#Work_State%]
.FSIUCexit
 LDMIA   R13!,{R0,R1,R14}
 B       ModuleReturnOK

.FSWriteNoBlock
 STMDB   R13!,{R0-R6,R14}
 MOVS    R2,R0
 BLE     FSWNBexit
 MOV     R3,R1
 LDR     R4,[R12,#Work_NumBuffers%]
 LDR     R5,[R12,#Work_SampleFormat%]
.FSWNBloop
 LDR     R0,[R12,#Work_WriteBuffer%] ;calc number of used buffers (see StreamSta
tistics)
 LDR     R1,[R12,#Work_ReadBuffer%]
 SUBS    R0,R0,R1
 ADDLT   R0,R0,R4                  ;number of used buffers in R0
 BEQ     FSWNBcheckfull
 LDR     R1,[R12,#Work_FillLevel%]
 CMP     R1,#0
 ADDNE   R0,R0,#1
 CMP     R0,R4                     ;= total number of buffers?
 BNE     FSWNBdocopy
 B       FSWNBdowait
.FSWNBcheckfull
 LDR     R0,[R12,#Work_RingIsFull%]
 CMP     R0,#0
 BEQ     FSWNBdocopy
.FSWNBdowait
 BL      FSIssueUpCall
 B       FSWNBloop                 ;always check for free space after returning!
.FSWNBdocopy
 LDR     R1,[R12,#Work_TotBuffSize%]
 CMP     R1,R3
 MOVCS   R1,R3
 MOV     R6,R1                     ;remember the size to copy
 MOV     R0,R2
 CMP     R5,#Format_8u%
 BNE     FSWNBcopy16
 SWI     XDR_StreamSamples%
 B       FSWNBcopydone
.FSWNBcopy16
 MOV     R1,R1,LSR #1
 SWI     XDR_StreamSamples16%
.FSWNBcopydone
 ADD     R2,R2,R6
 SUBS    R3,R3,R6
 BGT     FSWNBloop
.FSWNBexit
 LDMIA   R13!,{R0-R6,R14}
 B       ModuleReturnOK


.FSFlushMiniBuffer
 STMDB   R13!,{R0,R1,R14}
 ADD     R0,R12,#Work_MiniBuffer%
 LDR     R1,[R12,#Work_BuffOffset%]
 BL      FSWriteNoBlock
 MOV     R0,#0
 STR     R0,[R12,#Work_BuffOffset%]
 LDMIA   R13!,{R0,R1,R14}
 B       ModuleReturnOK


.FSConfigOpen
 STMDB   R13!,{R1-R3,R14}
 LDR     R0,[R12,#Work_NumBuffers%]
 STR     R0,[R12,#Work_OldNumBuff%]
 LDR     R0,[R12,#Work_StreamFlags%]
 STR     R0,[R12,#Work_OldStrFlags%]
 LDR     R0,[R12,#Work_DfltBuffers%]
 CMP     R0,#2
 MOVLT   R0,#2                      ;use at least 2 buffers!
 SWI     XDR_NumBuffers%
 LDR     R0,[R12,#Work_DfltChannels%]
 LDR     R1,[R12,#Work_DfltBuffSize%]
 LDR     R2,[R12,#Work_DfltFrequency%]
 CMP     R2,#0                      ;try 16bit sound
 BLE     FSCOnonewsound
 MOV     R3,#1
 SWI     XDR_Activate16%
 BVC     FSCOnewsound
 LDR     R0,[R12,#Work_DfltChannels%] ;the error message overwrote this!
.FSCOnonewsound
 LDR     R2,[R12,#Work_DfltPeriod%]
 SWI     XDR_Activate%
.FSCOnewsound
 MOVVC   R0,#0
 MOVVC   R1,#1
 STRVC   R1,[R12,#Work_StreamHandle%]
 LDR     R1,[R12,#Work_DfltFormat%]
 STR     R1,[R12,#Work_SampleFormat%] ;may be 16swap!
 LDMIA   R13!,{R1-R3,R14}
 B       ModuleReturnOK


.FSConfigClose                      ;close and wait until sound is played
 STMDB   R13!,{R0,R5,R6,R14}
 LDR     R14,[R12,#Work_BuffOffset%]
 CMP     R14,#0
 BLNE    FSFlushMiniBuffer
 SWI     "XOS_ReadMonotonicTime"
 MOV     R5,R0                      ;time stamp of last read buffer
 LDR     R6,[R12,#Work_ReadBuffer%] ;last read buffer
.FSCCwait
 SWI     "XOS_ReadMonotonicTime"
 SUB     R14,R0,R5
 CMP     R14,#20                    ;if the read buffer hasn't changed in 20cs
 BGE     FSCCfinish                 ;we finish anyway (no infinite loops!!!)
 LDR     R4,[R12,#Work_ReadBuffer%]
 CMP     R4,R6
 MOVNE   R6,R4
 MOVNE   R5,R0                      ;if changed update timestamp and buffer numb
er
 LDR     R14,[R12,#Work_WriteBuffer%]
 CMP     R4,R14
 BNE     FSCCwaitback
 LDR     R4,[R12,#Work_RingIsFull%]
 CMP     R4,#0
 BEQ     FSCCfinish
.FSCCwaitback
 BL      FSIssueUpCall
 B       FSCCwait
.FSCCfinish
 MOV     R14,#0                     ;mark files closed _before_ calling deactiva
te!
 STR     R14,[R12,#Work_StreamHandle%] ;otherwise deactivate tries to close agai
n
 STR     R14,[R12,#Work_StrExtHand%]
 SWI     XDR_Deactivate%
 LDR     R0,[R12,#Work_OldStrFlags%]
 STR     R0,[R12,#Work_StreamFlags%]
 LDR     R0,[R12,#Work_OldNumBuff%]
 STR     R0,[R12,#Work_NumBuffers%]
 LDMIA   R13!,{R0,R5,R6,R14}
 B       ModuleReturnOK


.FSEntry_Open
 CMP     R0,#1
 CMPNE   R0,#2
 BNE     FSEopen_read
 STMDB   R13!,{R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_State%]
 ANDS    R14,R14,#(State_Active% + State_UpCall%)
 BNE     FSEopen_busy
 LDR     R14,[R12,#Work_StreamHandle%] ;there can only be one file open!
 CMP     R14,#0
 BNE     FSEopen_busy
 BL      FSConfigOpen
 CMP     R0,#0
 BNE     FSEopen_generr
 STR     R3,[R12,#Work_StrExtHand%]
 MOV     R0,#(&12 << 27)            ;write only, unbuffered
 LDR     R1,[R12,#Work_StreamHandle%]
 MOV     R2,#0
 MOV     R3,#0
 MOV     R4,#0
 STR     R4,[R12,#Work_BuffOffset%]
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEopen_read
 FNadr2("", 0, Error_FSread)
.FSEopen_generr
 LDMIA   R13!,{R14}
 B       ModuleReturnError
.FSEopen_busy
 LDMIA   R13!,{R14}
 FNadr2("", 0, Error_FSbusy)
 B       ModuleReturnError


.FSEntry_GetBytes               ;should never be called
 TEQ     R0,R0
 TEQ     PC,PC
 ORRNES  PC,R14,#PFlag_C%
 MSR     CPSR_f,#PFlag_C%
 MOV     PC,R14


.FSEntry_PutBytes
 STMDB   R13!,{R2,R14}
 LDR     R12,[R12]
 LDR     R2,[R12,#Work_State%]
 AND     R2,R2,#(State_Active% + State_UpCall%)
 CMP     R2,#State_Active%
 BNE     FSEput_busy
 LDR     R2,[R12,#Work_StreamHandle%]
 CMP     R1,R2
 BNE     FSEput_handle
 LDR     R2,[R12,#Work_BuffOffset%]
 CMP     R2,#MiniBufferSize%
 BLGE    FSFlushMiniBuffer
 ADD     R14,R12,#Work_MiniBuffer%
 LDR     R2,[R12,#Work_BuffOffset%]
 STRB    R0,[R14,R2]
 ADD     R2,R2,#1
 STR     R2,[R12,#Work_BuffOffset%]
 LDMIA   R13!,{R2,R14}
 B       ModuleReturnOK
.FSEput_handle
 FNadr2("", 0, Error_FShandle)
 LDMIA   R13!,{R2,R14}
 B       ModuleReturnError
.FSEput_busy
 FNadr2("", 0, Error_FSbusy)
 LDMIA   R13!,{R2,R14}
 B       ModuleReturnError


.FSEntry_PopAndReturn
 LDMIA   R13!,{R14}
 B       ModuleReturnOK

.FSEntry_Args
 STMDB   R13!,{R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_State%]
 AND     R14,R14,#(State_Active% + State_UpCall%)
 CMP     R14,#State_Active%
 BNE     FSEargs_busy
 CMP     R0,#((FSEargs_illegal - FSEargs_table) >> 2)
 ADDLO   PC,PC,R0,LSL #2
 B       FSEargs_illegal
.FSEargs_table
 B       FSEntry_Arg0    ;read file pointer
 B       FSEntry_PopAndReturn ;write file pointer
 B       FSEntry_Arg2    ;read extent
 B       FSEntry_PopAndReturn ;write extent
 B       FSEntry_Arg4    ;read allocated size
 B       FSEntry_Arg5    ;eof check
 B       FSEntry_Arg6    ;notify of flush
 B       FSEntry_PopAndReturn ;ensure file size
 B       FSEntry_PopAndReturn ;write zeroes (buffered only)
 B       FSEntry_Arg9    ;read datestamp
 B       FSEntry_PopAndReturn ;new image stamp
.FSEargs_illegal
 LDMIA   R13!,{R14}
 FNadr2("", 0, Error_FSargnum)
 B       ModuleReturnError
.FSEargs_busy
 LDMIA   R13!,{R14}
 FNadr2("", 0, Error_FSbusy)
 B       ModuleReturnError

.FSEntry_Arg0
 MOV     R2,#0                      ;no file pointers
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEntry_Arg2
 MOV     R2,#0
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEntry_Arg4
 LDR     R2,[R12,#Work_TotBuffSize%]
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEntry_Arg5
 MVN     R2,#0
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEntry_Arg6
 LDR     R14,[R12,#Work_BuffOffset%]
 CMP     R14,#0
 BLNE    FSFlushMiniBuffer
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEntry_Arg9
 MOV     R2,#0
 MOV     R3,#0
 LDMIA   R13!,{R14}
 B       ModuleReturnOK


.FSEntry_Close
 STMDB   R13!,{R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_State%]
 AND     R14,R14,#(State_Active% + State_UpCall%)
 CMP     R14,#State_Active%
 BNE     FSEclose_busy
 BL      FSConfigClose
 LDMIA   R13!,{R14}
 B       ModuleReturnOK
.FSEclose_busy
 LDMIA   R13!,{R14}
 FNadr2("", 0, Error_FSbusy)
 B       ModuleReturnError


.FSEntry_File
 CMP     R0,#0
 BEQ     FSEntry_File0              ;save
 CMP     R0,#5
 BEQ     FSEntry_File5              ;read file info
 CMP     R0,#10
 BEQ     FSEntry_File10             ;read block size
 B       ModuleReturnOK

.FSEntry_File0
 STMDB   R13!,{R0-R1,R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_State%]
 ANDS    R14,R14,#(State_Active% + State_UpCall%)
 BNE     FSEsave_busy
 BL      FSConfigOpen
 CMP     R0,#0
 BNE     FSEsave_generr
 MOV     R0,R4
 SUB     R1,R5,R4
 BL      FSWriteNoBlock
 BL      FSConfigClose
 FNadr2("", 6, FSDfltSaveName)
 LDMIA   R13!,{R0-R1,R14}
 B       ModuleReturnOK
.FSEsave_busy
 FNadr2("", 0, Error_FSbusy)
.FSEsave_generr
 ADD     R13,R13,#4
 LDMIA   R13!,{R1,R14}
 B       ModuleReturnError

.FSEntry_File5                      ;always return defaults (see FastSpool)
 MOV     R0,#0
 LDR     R1,FSEinfodefault
 MOV     R3,#0
 MOV     R4,#0
 MOV     R5,#&88
 B       ModuleReturnOK
.FSEinfodefault
 EQUD    &fffffd00                  ;default load address (filetype data)

.FSEntry_File10
 LDR     R12,[R12]
 LDR     R2,[R12,#Work_TotBuffSize%]
 B       ModuleReturnOK


.FSEntry_Func
 CMP     R0,#7
 BCC     FSEfunc_error              ;all directory functions return an error
 CMP     R0,#8
 BEQ     FSEntry_Func8              ;rename
 CMP     R0,#10
 BCC     ModuleReturnOK
 CMP     R0,#16
 BCC     FSEfunc_error
 CMP     R0,#19
 BCC     ModuleReturnOK
 CMP     R0,#24
 BCC     FSEfunc_error
 BEQ     FSEntry_Func24             ;resolve wildcard
 CMP     R0,#35
 BCC     FSEfunc_error
 B       ModuleReturnOK
.FSEfunc_error
 FNadr2("", 0, Error_FSfunction)
 B       ModuleReturnError

.FSEntry_Func8
 MOV     R1,#1
 B       ModuleReturnOK

.FSEntry_Func24
 MVN     R4,#0
 B       ModuleReturnOK


.FSEntry_GBPB
 CMP     R0,#1
 CMPNE   R0,#2
 BNE     FSEgbpb_read
 STMDB   R13!,{R0,R1,R14}
 LDR     R12,[R12]
 LDR     R14,[R12,#Work_State%]
 AND     R14,R14,#(State_Active% + State_UpCall%)
 CMP     R14,#State_Active%
 BNE     FSEgbpb_busy
 LDR     R14,[R12,#Work_BuffOffset%]
 CMP     R14,#0
 BLNE    FSFlushMiniBuffer
 MOV     R0,R2
 MOV     R1,R3
 BL      FSWriteNoBlock
 ADD     R2,R2,R3
 ADD     R4,R4,R3
 MOV     R3,#0
 LDMIA   R13!,{R0,R1,R14}
 B       ModuleReturnOK
.FSEgbpb_busy
 FNadr2("", 0, Error_FSbusy)
 ADD     R13,R13,#4
 LDMIA   R13!,{R1,R14}
 B       ModuleReturnError
.FSEgbpb_read
 FNadr2("", 0, Error_FSread)
 B       ModuleReturnError









; logarithmic table (8bit ulaw -> 16bit signed linear) for maximum volume (128).
; Real maximum volume is 127, therefore the maximum value in the table is a litt
le
; higher (32961), but after volume-scaling it's fine (32961*127/128 = 32703

.LogarithmicTable
]
 sampstep=4.17: samppos=sampstep/2
 FOR i%=0 TO 127
[OPT pass%
 EQUD    INT(samppos)
]
 IF ((i% AND 15) = 0) THEN
  sampstep = sampstep * 2
 ENDIF
 samppos = samppos + sampstep
 NEXT i%

 NEXT pass%
 SYS "OS_File",10,"$.Programs.DRender.DRenderer",&ffa,,Code%,O%
 END



 REM lo%, hi% registers holding first/second sample on exit, hi% holds sample wo
rd on entry
 DEF FNConvertToUlaw(tab%,lo%,hi%)
[OPT pass%
 MOV     lo%,hi%,LSL #16
 LDRB    lo%,[tab%,lo%,LSR #19]
 LDRB    hi%,[tab%,hi%,LSR #19]
 ORR     lo%,lo%,hi%,LSL #8
]
=0


 DEF FNCopyBytes(shift%)
 LOCAL i%,ptr%,otr%
 ptr%=P%: otr%=O%
 FOR i%=1 TO 2
 P%=ptr%: O%=otr%
[OPT pass%
 BIC    R0,R0,#3
 LDR    R3,[R0],#4
 MOV    R3,R3,LSR #(shift%*8)
 SUBS   R2,R2,#16
 BLT    CBBxsmall
.CBBxbig
 LDMIA  R0!,{R4-R7}
 ORR    R3,R3,R4,LSL #(32-8*shift%)
 MOV    R4,R4,LSR #8*shift%
 ORR    R4,R4,R5,LSL #(32-8*shift%)
 MOV    R5,R5,LSR #8*shift%
 ORR    R5,R5,R6,LSL #(32-8*shift%)
 MOV    R6,R6,LSR #8*shift%
 ORR    R6,R6,R7,LSL #(32-8*shift%)
 STMIA  R1!,{R3-R6}
 MOV    R3,R7,LSR #8*shift%
 SUBS   R2,R2,#16
 BGE    CBBxbig
.CBBxsmall
 ADDS   R2,R2,#16
 BLE    CBBexit
 TST    R2,#8
 BEQ    CBBxtiny
 LDMIA  R0!,{R4,R5}
 ORR    R3,R3,R4,LSL #(32-8*shift%)
 MOV    R4,R4,LSR #8*shift%
 ORR    R4,R4,R5,LSL #(32-8*shift%)
 STMIA  R1!,{R3,R4}
 MOV    R3,R5,LSR #8*shift%
.CBBxtiny
 TST    R2,#4
 LDRNE  R4,[R0],#4
 ORRNE  R3,R3,R4,LSL #(32-8*shift%)
 STRNE  R3,[R1],#4
 MOVNE  R3,R4,LSR #8*shift%
 ANDS   R2,R2,#3
 BEQ    CBBexit
 CMP    R2,#(4-shift%)
 LDRGT  R4,[R0],#4
 ORRGT  R3,R3,R4,LSL #(32-8*shift%)
.CBBxrest
 STRB   R3,[R1],#1
 MOV    R3,R3,LSR #8
 SUBS   R2,R2,#1
 BGT    CBBxrest
 LDMIA  R13!,{R0-R7,PC}          ;DON'T RESTORE FLAGS! IRQ SAFE!
]
 NEXT i%
=0


 REM print number in R0
 DEF FNPrintNumber
[OPT pass%
 SUB    R13,R13,#16
 MOV    R1,R13
 MOV    R2,#16
 SWI    "XOS_ConvertInteger4"
 SWI    "XOS_Write0"
 ADD    R13,R13,#16
]
=0

 REM print str followed by the number stored at off in the workspace
 DEF FNPrintConfig(str%,off%)
[OPT pass%
 ADR    R0,str%
 SWI    "XOS_Write0"
 LDR    R0,[R12,#off%]
 FNPrintNumber
]
=0


 REM expand 2 mono 16 bit samples in reg2% into stereo samples in reg1, reg2%
 DEF FNexpandsample(reg1%,reg2%)
[OPT pass%
 MOV     reg1%,reg2%,LSL #16
 BIC     reg2%,reg2%,reg1%,LSR #16
 ORR     reg1%,reg1%,reg1%,LSR #16
 ORR     reg2%,reg2%,reg2%,LSR #16
]
=0


 REM scale two 16bit samples in reg% by volume in r0 using temp% register
 REM and mask% containing &ffff
 DEF FNscalesamples(reg%,temp%,mask%)
[OPT pass%
 MOV     temp%,reg%,ASR #16
 MUL     temp%,R0,temp%
 MOV     reg%,reg%,LSL #16
 MOV     reg%,reg%,ASR #16
 MUL     reg%,R0,reg%
 AND     temp%,temp%,mask%,LSL #Volume_Shift%
 MOV     temp%,temp%,LSL #(16-Volume_Shift%)
 AND     reg%,reg%,mask%,LSL #Volume_Shift%
 ORR     reg%,temp%,reg%,LSR #Volume_Shift%
]
=0


 REM same, but optimized for shifted operation
 DEF FNscalesampshft(reg1%,reg2%,temp%,mask%)
[OPT pass%
 MOV     temp%,reg2%,LSL #16
 MUL     reg1%,r0,reg1%
 MOV     temp%,temp%,ASR #16
 MUL     temp%,r0,temp%
 AND     temp%,temp%,mask%,LSL #Volume_Shift%
 MOV     temp%,temp%,LSL #(16-Volume_Shift%)
 AND     reg1%,reg1%,mask%,LSL #Volume_Shift%
 ORR     reg1%,temp%,reg1%,LSR #Volume_Shift%
]
=0


