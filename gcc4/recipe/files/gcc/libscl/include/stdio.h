/* stdio.h standard header for the RISC OS SharedCLibrary.
   Copyright (c) 1997-2005 Nick Burrett
   Copyright (c) 2006-2008 UnixLib Developers
   All rights reserved.
 
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
   3. The name of the author may not be used to endorse or promote products
      derived from this software without specific prior written permission.
 
   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


/* To use filename translation, define __RISCOSIFY.  */

#ifndef __STDIO_H
#define __STDIO_H

#ifndef __STDDEF_H
#include <stddef.h>
#endif

#define __need__va_list
#include <stdarg.h>
/* Castle C/C++ compatibility */
#define __va_list va_list

#ifdef __cplusplus
extern "C" {
#endif

#define __LIB_VERSION 500

typedef struct __fpos_t_struct
{
  unsigned long __lo;
} fpos_t;
  
typedef struct __FILE_struct
{
  unsigned char *__ptr;
  int __icnt;
  int __ocnt;
  int __flag;
  unsigned char *__base;
  int __file;
  long __pos;
  int __bufsiz;
  int __signature;
  int *internal;
} FILE;

#define _IOEOF 0x40
#define _IOERR 0x80
/* Full buffering.  */
#define _IOFBF 0x100
/* Line buffering.  */
#define _IOLBF 0x200
/* No buffering.  */
#define _IONBF 0x400
/* Default buffer size.  */
#define BUFSIZ (4096)
/* End of file character.  */
#define EOF (-1)

/* Maximum number of files that can be open at once.  */
#define FOPEN_MAX 8
/* Number of open files that is imposed by this library.  */
#define _SYS_OPEN 16

/* Maximum length of a filename.  */
#define FILENAME_MAX 80


/* Seek from beginning of file.  */
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
/* Seek from current position.  */
#ifndef SEEK_CUR
#define SEEK_CUR 1
#endif
/* Seek from end of file.  */
#ifndef SEEK_END
#define SEEK_END 2
#endif

/* How long an array of chars must be to be passed to tmpnam.  */
#define L_tmpnam 20
/* The maximum number of unique filenames generated by tmpnam.  */
#define TMP_MAX 1000000000

/* Standard streams.  */
extern FILE __iob[];

#define stdin (&__iob[0])
#define stdout (&__iob[1])
#define stderr (&__iob[2])

/* Delete file 'filename'.  */
extern int remove (const char *__filename);

#ifdef __RISCOSIFY
#define remove(f) (remove(__riscosify_scl(f, 0)))
#endif

/* Rename a file called 'oldname' to 'newname'. If rename fails
   it returns -1.  */
extern int rename (const char *__oldname, const char *__newname);

#ifdef __RISCOSIFY
#define rename(f, g) (rename(__riscosify_scl(f, 0), __riscosify_scl(g, 1)))
#endif

/* Create a temporary binary file for updade mode, as if calling
   fopen with mode "wb+".  The file is deleted automatically when
   it is closed or when the program terminates.  */
extern FILE *tmpfile (void);

/* Construct and return a file name that is a valid and does not
   name any existing file. If 'result' is null, the return value
   points to an internal static string. Otherwise, 'result' points
   to an array of at least L_tmpnam chars.  */
extern char *tmpnam (char *__result);

/* Cause 'stream' to be closed and the connection to the corresponding
   file to be broken.  All buffered output is written and buffered
   input is discarded. Returns 0 on success, EOF if an error was detected.  */
extern int fclose (FILE *__stream);

/* Cause any buffered output on 'stream' to be delivered to the file.
   If 'stream' is null, then fflush causes buffered output on all open
   output streams. Returns EOF if a write error occurs, zero otherwise.  */
extern int fflush (FILE *__stream);

/* Open a stream for I/O to the file 'filename' and return a pointer
   to the stream.  */
extern FILE *fopen (const char *__filename, const char *__opentype);
#ifdef __RISCOSIFY
#define fopen(f, t) (fopen(__riscosify_scl(f, (t)[0] == 'a' || (t)[0] == 'w'), t))
#endif

/* Close the stream 'stream', ignoring any errors. Then 'filename'
   is opened with 'opentype' with the same stream object 'stream'.
   Returns null on failure.  Usually used to connect to standard
   streams e.g. stdin, stdout or stderr.  */
extern FILE *freopen (const char *__filename, const char *__opentype,
		      FILE *__stream);
#ifdef __RISCOSIFY
#define freopen(f, t, s) (freopen(__riscosify_scl(f, (t)[0] == 'a' || (t)[0] == 'w'), t, s))
#endif


/* Set file buffering for 'stream'. If 'buf' is null, then
   file buffering is turned off, otherwise we use full file buffering.  */
extern void setbuf (FILE *__stream, char *__buf);

/* Specify that the stream 'stream' should have the buffering mode
   'mode', which can be either _IOFBF (full buffering), _IOLBF (line
   buffering) or _IONBF (unbuffered input/output).

   If 'buf' is null, then setvbuf allocates a buffer itself using
   malloc. This is freed when the stream is closed.

   Otherwise 'buf' is a character array of 'size' characters.  */
extern int setvbuf (FILE *__stream, char *__buf, int __mode,
		    size_t __size);

/* Print the optional arguments under control of the template
   string 'fmt' to the stream stdout. Returns the number of characters
   printed, or a negative value if there was an output error.  */
extern int printf (const char *__restrict __format, ...);

/* Similar to printf except the output is written to the stream
   'stream' instead of stdout.  */
extern int fprintf (FILE *__restrict __stream,
                    const char *__restrict __format, ...);

/* Similar to printf except the output is stored in the array
   'string'. A null terminating character is also written.  */
extern int sprintf (char *__restrict __s,
                    const char *__restrict __format, ...);

/* Read formatted input from the stream stdin under control
   of the template 'fmt'. Returns the number of successful
   assignments.  */
extern int scanf (const char *__restrict __format, ...);

/* Similar to scanf but reads from the stream 'stream'.  */
extern int fscanf (FILE *__restrict __stream,
                   const char *__restrict __format, ...);

/* Similar to scanf but reads from the array 'string'.  */
extern int sscanf (const char *__restrict __s,
                   const char *__restrict __format, ...);

/* Write formatted output to s from argument list arg.  limit is the
   maximum number of characters to produce.  */
extern int vsnprintf (char *__restrict __s, size_t __limit,
                      const char *__restrict __format,
                      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));

/* Write formatted output to s from argument list arg.  */
extern int vsprintf (char *__restrict __s,
                     const char *__restrict __format, __gnuc_va_list __arg);

/* Write formatted output to stream from arg list arg.  */
extern int vfprintf (FILE *__restrict __stream,
                     const char *__restrict __format, __gnuc_va_list __arg);

/* Write formatted output to stdio from arg list arg.  */
extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

#ifdef __GNUC__
extern int __gcc_vsnprintf (char *__restrict __s, size_t __limit,
			    const char *__restrict __format,
			    __gnuc_va_list *__arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));
extern int __gcc_vsprintf (char *__restrict __s,
			   const char *__restrict __format, __gnuc_va_list *__arg);
extern int __gcc_vfprintf (FILE *__restrict __stream,
                     const char *__restrict __format, __gnuc_va_list *__arg);
extern int __gcc_vprintf (const char *__restrict __format, __gnuc_va_list *__arg);

#define vsnprintf(__s,__limit,__fmt,__ap) \
	(__gcc_vsnprintf(__s,__limit,__fmt, &__ap))
#define vsprintf(__s,__fmt,__ap) (__gcc_vsprintf(__s, __fmt, &__ap))
#define vfprintf(__s,__fmt,__ap) (__gcc_vfprintf(__s, __fmt, &__ap))
#define vprintf(__fmt,__ap) (__gcc_vprintf(__fmt, &__ap))
#endif

/* Write formatted output to s.  limit is the maximum number of characters
   to produce.  */
extern int snprintf (char *__restrict __s, size_t __limit,
                     const char *__restrict __format, ...)
     __attribute__ ((__format__ (__printf__, 3, 4)));

/* Read formatted input from stdin into argument list arg.  */
extern int vscanf (const char *__restrict __format, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__scanf__, 1, 0)));

/* Read formatted input from stream into argument list arg.  */
extern int vfscanf (FILE *__restrict __stream,
                    const char *__restrict __format, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__scanf__, 2, 0)));

/* Read formatted input from 's' into argument list arg.  */
extern int vsscanf (const char *__restrict __s,
                    const char *__restrict __format, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__scanf__, 2, 0)));
     
#ifdef __GNUC__
extern int __gcc_vscanf (const char *__restrict __format, __gnuc_va_list *__ap)
     __attribute__ ((__format__ (__scanf__, 1, 0)));
extern int __gcc_vfscanf (FILE *__restrict __stream,
			  const char *__restrict __format, __gnuc_va_list *__ap)
     __attribute__ ((__format__ (__scanf__, 2, 0)));
extern int __gcc_vsscanf (const char *__restrict __s,
                    const char *__restrict __format, __gnuc_va_list *__ap)
     __attribute__ ((__format__ (__scanf__, 2, 0)));

#define vscanf(__fmt,__ap) (__gcc_vscanf(__fmt, &__ap))
#define vfscanf(__s,__fmt,__ap) (__gcc_vfscanf(__s, __fmt, &__ap))
#define vsscanf(__s,__fmt,__ap) (__gcc_vsscanf(__s, __fmt, &__ap))
#endif



/* Read the next character as an unsigned char from the stream
   'stream' and return its value, converted to an int.  EOF
   is returned on read error/end-of-file.  */
extern int fgetc (FILE *__stream);
extern int __filbuf (FILE *__stream);

/* Similar to fgetc but implemented as a macro, so stream can be
   evaluated more than once.  */
extern int getc (FILE *__stream);
#define getc(p) \
 (--((p)->__icnt) >= 0 ? *((p)->__ptr)++ : __filbuf(p))

/* Equivalent to getc with a stream of stdin.  */
extern int getchar (void);
#define getchar() getc(stdin)

/* Read chars from the stream 'stream' up to and including a
   newline character and stores them in the string 's'. A null
   character is added to mark the end of the string.  The number
   of characters to read at most is 'count - 1'.  */
extern char *fgets (char *__s, int __count, FILE *__stream);

/* Read chars from the stream 'stdin' up to and including a
   new line. The newline character is discarded.  */
extern char *gets(char *__s);
extern int __flsbuf(int __c, FILE *__stream);

/* Convert the character 'c' to type unsigned char and writes it
   to stream 'stream'.  EOF is returned if an error occurs;
   otherwise the character 'c' is returned.  */
extern int putc (int __c, FILE *__stream);

#define putc(ch, p) \
 (--((p)->__ocnt) >= 0 ? (*((p)->__ptr)++ = (ch)) : __flsbuf(ch,p))

extern int fputc (int __c, FILE *__stream);

/* Equivalent to putc with stdout as the value of the stream argument.  */
extern int putchar (int __ch);
#define putchar(ch) putc(ch, stdout)


/* Write the string 's' top the stream 'stream'. The terminating null
   character is not written, and a newline character is not added, either.  */
extern int fputs(const char *__s, FILE *__stream);

/* Write the string 's' to stdout.  */
extern int puts (const char *__s);

/* Pushes back the character 'c' onto the input stream 'stream'.
   The next input from 'stream' will read 'c' before anything else.
   If 'c' is EOF, ungetc does nothing and just returns EOF.  */
extern int ungetc (int __c, FILE *__stream);

/* Read up to 'count' objects of size 'size' into the array 'data',
   from the stream 'stream'. Return the number of objects actually
   read.  */
extern size_t fread (void *__data, size_t __size, size_t __count,
		     FILE *stream);

/* Write up to 'count' objects of size 'size' from the array 'data',
   to the stream 'stream'. The return value is normally 'count' if the
   call succeeds.  */
extern size_t fwrite (const void *__data, size_t __size, size_t __count,
		      FILE *__stream);

/* Store the value of the file position indicator for the
   stream 'stream' in the fpos_t object pointed to by 'position'.
   fgetpos returns zero on success.  */
extern int fgetpos (FILE *__stream, fpos_t *__position);

/* Change the file position of the stream 'stream'. 'whence'
   must be one of the constants SEEK_SET, SEEK_CUR, SEEK_END,
   to indicate the meaning of the relative 'offset'.  */
extern int fseek (FILE *__stream, long int __offset, int __whence);

/* Set the file position indicator for the stream 'stream' to the
   position 'position', which must be set by a previous call to
   fgetpos.  */
extern int fsetpos (FILE *__stream, const fpos_t *__position);

/* Return the current file position of the stream 'stream'.
   If a failure occurs, -1 is returned.  */
extern long int ftell (FILE *__stream);

/* Positions the stream 'stream' at the beginning of the file.
   Equivalent to fseek (stream, 0, SEEK_SET).  */
extern void rewind (FILE *__stream);

/* Clears the end-of-file and error indicators for the stream
   'stream'.  */
extern void clearerr (FILE *__stream);

/* Return nonzero if the end-of-file indicator for stream 'stream'
   is set.  */
extern int feof (FILE *__stream);
#define feof(stream) ((stream)->__flag & _IOEOF)

/* Return nonzero if the error indicator for the stream 'stream'
   is set.  */
extern int ferror (FILE *__stream);
#define ferror(stream) ((stream)->__flag & _IOERR)

/* Print an error message to the stream 'stderr'.

   If 'message' is null, the error message corresponding to
   'errno' is printed.  */
extern void perror (const char *__message);

/* Extensions to the SharedCLibrary.  */

#ifdef __RISCOSIFY

#define __RISCOSIFY_STRICT_UNIX_SPECS   0x0001
#define __RISCOSIFY_NO_PROCESS		0x0040
#define __RISCOSIFY_NO_SUFFIX		0x0100
#define __RISCOSIFY_DONT_CHECK_DIR	0x0200
#define __RISCOSIFY_CHECK_DIR_IS_SUFFIX	0x0400
#define __RISCOSIFY_NO_REVERSE_SUFFIX	0x0800
#define __RISCOSIFY_FILETYPE_EXT    	0x1000
#define __RISCOSIFY_FILETYPE_FFF_EXT	0x2000
#define __RISCOSIFY_FILETYPE_NOT_SET    0x4000
#define __RISCOSIFY_MASK                0x7F41
#define __RISCOSIFY_FILETYPE_NOTFOUND   -1
#define __RISCOSIFY_FILETYPE_NOTSPECIFIED -1

extern char *__riscosify_scl (const char *name, int __create_dir);

extern char *__riscosify (const char *__name, int __create_dir,
			  int __riscosify_flags,
			  char *__buffer, size_t __buf_len,
			  int *__filetype);

/* Gets the __riscosify_control value which can be defined by
   the global variable __riscosify_control in the user program.
   Returns a copy of __riscosify_control_internal (with a default
   value of 0) when __riscosify_control is not defined.  */
extern int __get_riscosify_control (void);
/* Sets the __riscosify_control value when it's defined.
   Otherwise __riscosify_control_internal gets written.  */
extern void __set_riscosify_control (int __riscosify_flags);

#endif

/* Return the system file descriptor for stream.  */
extern int fileno (FILE *__stream);

/* Create a new stream that refers to an existing system file descriptor.  */
extern FILE *fdopen (int __fd, const char *__modes);


#ifdef __cplusplus
}
#endif

#endif
