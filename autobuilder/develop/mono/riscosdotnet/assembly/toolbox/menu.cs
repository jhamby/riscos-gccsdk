//
// toolbox/menu.cs - a binding of the RISC OS API to C#.
//
// Author: Lee Noar (leenoar@sky.com)
//

using System;
using System.Text;
using System.Runtime.InteropServices;

namespace riscos
{
	public static partial class Toolbox
	{
		/*! \class MenuEntry
		 * \brief Encapsulates an item in a Menu.
		 *
		 * Stricty speaking, a Menu Entry is not a type of gadget. However, as
		 * a lot of the code is the same, Gadget is used as a base object to
		 * allow code reuse. Where a method does not make sense for a Menu Entry,
		 * it is overridden and will generate an exception if called.<br>
		 * These methods are:<br>
		 * \li Gadget.Type
		 * \li Gadget.BoundingBox
		 * \li Gadget.SetFocus */
		public class MenuEntry : Gadget
		{
			static class Method
			{
				public const int SetTick = 0;
				public const int GetTick = 1;
				public const int SetFade = 2;
				public const int GetFade = 3;
				public const int SetEntryText = 4;
				public const int GetEntryText = 5;
				public const int SetEntrySprite = 6;
				public const int GetEntrySprite = 7;
				public const int SetSubMenuShow = 8;
				public const int GetSubMenuShow = 9;
				public const int SetSubMenuEvent = 10;
				public const int GetSubMenuEvent = 11;
				public const int SetClickShow = 12;
				public const int GetClickShow = 13;
				public const int SetClickEvent = 14;
				public const int GetClickEvent = 15;
				public const int SetEntryHelpMessage = 18;
				public const int GetEntryHelpMessage = 19;
			}

			/*! \class EventCode
			 * \brief Toolbox events that can be generated by entries in a Toolbox Menu object.  */
			public static class EventCode
			{
				public const int SubMenu = 0x828c2;
				public const int Selection = 0x828c3;
			}

			/*! \brief Constants defining event specific data offsets after the header.  */
			public static class EventOffset
			{
				public const int SubMenuX = 16;
				public const int SubMenuY = 20;
			}

			/*! \brief An object that encapsulates the arguments for the event that is raised when 
			 * the user moves the pointer over a submenu arrow.  */
			public class SubMenuEventArgs : ToolboxEventArgs
			{
				/*! \brief The coordinate where the submenu will be shown.  */
				public OS.Coord Position;

				public SubMenuEventArgs (IntPtr unmanagedEventData) : base (unmanagedEventData)
				{
					int x = Marshal.ReadInt32 (RawEventData, EventOffset.SubMenuX);
					int y = Marshal.ReadInt32 (RawEventData, EventOffset.SubMenuY);
					Position = new OS.Coord (x, y);
				}
			}

			/*! \brief The signature of a SubMenu event handler.  */
			public delegate void SubMenuEventHandler (object sender, SubMenuEventArgs e);

			/*! \brief The event handlers that will be called when the pointer if moved.
			 * over the submenu arrow of the menu entry.
			 * 
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, SubMenuEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * MenuEntryObject.SubMenu += handler_name;
			 * \endcode  */
			public event SubMenuEventHandler SubMenu;

			/*! \brief The signature of a Selection event handler.  */
			public delegate void SelectionEventHandler (object sender, ToolboxEventArgs e);

			/*! \brief The event handlers that will be called when this MenuEntry is selected.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, ToolboxEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * MenuEntryObject.Selection += handler_name;
			 * \endcode  */
			public event SelectionEventHandler Selection;

			public MenuEntry (Menu menu, uint cmpID) : base (menu, cmpID)
			{
			}

			/*! \brief Gets or sets the tick state of this MenuEntry.  */
			public bool Ticked
			{
				get {
					return Object.MiscOp_SetR3GetR0 (0,
									 Method.GetTick,
									 ComponentID) != 0;
				}
				set {
					Object.MiscOp_SetR3R4 (0,
							       Method.SetTick,
							       ComponentID,
							       value ? 1U : 0U);
				}
			}

			/*! \brief Gets or sets the fade state of this MenuEntry.  */
			public override bool Faded
			{
				get {
					return Object.MiscOp_SetR3GetR0 (0,
									 Method.GetFade,
									 ComponentID) != 0;
				}
				set {
					Object.MiscOp_SetR3R4 (0,
							       Method.SetFade,
							       ComponentID,
							       value ? 1U : 0U);
				}
			}

			/*! \brief Gets or sets the text used in this MenuEntry.
			 * \exception ArgumentNullException Thrown if text set to null.
			 * \exception OS.ErrorException Thrown if the entry's text buffer is not large
			 * enough to hold the supplied text.
			 * \exception OS.ErrorException Thrown if the entry is sprite only.  */
			public string Text
			{
				get { return GetText (Method.GetEntryText); }
				set
				{
					if (value == null)
						throw new ArgumentNullException ("value", "Attempt to set Menu Entry text to null");
					SetText (Method.SetEntryText, value);
				}
			}

			/*! \brief Gets or sets the sprite which is to be used in this MenuEntry.
			 * \exception ArgumentNullException Thrown if sprite set to null.
			 * \exception OS.ErrorException Thrown if the entry's sprite name buffer is not large
			 * enough to hold the supplied sprite name.
			 * \exception OS.ErrorException Thrown if the entry is text only.  */
			public string Sprite
			{
				get { return GetText (Method.GetEntrySprite); }
				set
				{
					if (value == null)
						throw new ArgumentNullException ("value", "Attempt to set Menu Entry sprite to null");
					SetText (Method.SetEntrySprite, value);
				}
			}

			/*! \brief Gets or sets the Toolbox object that will be shown when the user
			 * moves the pointer over the submenu arrow.
			 * 
			 * If set to null, then no object will be shown.  */
			public Object SubMenuShow
			{
				get {
					uint show_id = Object.MiscOp_SetR3GetR0 (0,
										 Method.GetSubMenuShow,
										 ComponentID);
					if (show_id == 0)
						return null;

					return Object.LookupOrWrap (show_id);
				}
				set {
					Object.MiscOp_SetR3R4 (0,
							       Method.SetSubMenuShow,
							       ComponentID,
							       (value == null) ? 0 : value.ID);
				}
			}

			/*! \brief Gets or sets the Toolbox event that will be raised when the user
			 * moves the pointer over this entry's submenu arrow.
			 * 
			 * If set to null, then default Toolbox event, Menu_SubMenu will be raised.  */
			public uint SubMenuEvent
			{
				get {
					return Object.MiscOp_SetR3GetR0 (0,
									 Method.GetSubMenuEvent,
									 ComponentID);
				}
				set {
					Object.MiscOp_SetR3R4 (0,
							       Method.SetSubMenuEvent,
							       ComponentID,
							       value);
				}
			}

			/*! \brief Gets or sets the Toolbox object that will be shown when the user
			 * clicks on the MenuEntry.
			 * 
			 * If set to null, then no object will be shown.  */
			public Toolbox.ClickShow ClickShow
			{
				get { return GetClickShow (Method.GetClickShow); }
				set { SetClickShow (Method.SetClickShow, value); }
			}

			/*! \brief Gets or sets the Toolbox event that will be raised when the user
			 * clicks on the MenuEntry.
			 * 
			 * If set to 0, then default Toolbox event Menu_Selection will be raised.  */
			public uint ClickEvent
			{
				get {
					return Object.MiscOp_SetR3GetR0 (0,
									 Method.GetClickEvent,
									 ComponentID);
				}
				set {
					Object.MiscOp_SetR3R4 (0,
							       Method.SetClickEvent,
							       ComponentID,
							       value);
				}
			}

			/*! \brief Gets or set the help message which will be returned when a Help
			 * Request message is received for this MenuEntry.
			 * 
			 * If set to null, the Help Message for this MenuEntry is detached.  */
			public override string HelpMessage
			{
				override get { return GetText (Method.GetEntryHelpMessage); }
				override set { SetText (Method.SetEntryHelpMessage, value); }
			}

			// Methods that have no meaning for a MenuEntry.

			/*! \brief A MenuEntry does not have a gadget type.
			 * \warning An exception will be thrown if accessed via a MenuEntry.
			 * \exception InvalidOperationException Thrown if accessed via a MenuEntry object.  */
			public override uint Type
			{
				override get
				{
					throw new InvalidOperationException ("A Menu Entry does not have a gadget type");
				}
			}

			/*! \brief A MenuEntry does not have a bounding box.
			 * \warning An exception will be thrown if accessed via a MenuEntry.
			 * \exception InvalidOperationException Thrown if accessed via a MenuEntry object.  */
			public override OS.Rect BoundingBox
			{
				override get
				{
					throw new InvalidOperationException ("A Menu Entry does not have a bounding box");
				}
				override set
				{
					throw new InvalidOperationException ("You cannot set the bounding box of a Menu Entry");
				}
			}

			/*! \brief Does not make sense for a Menu Entry.
			 * \warning An exception will be thrown if called on a MenuEntry.
			 * \exception InvalidOperationException Thrown if called on a MenuEntry object.  */
			public override void SetFocus ()
			{
				throw new InvalidOperationException ("You cannot set the input focus to a Menu Entry");
			}

			public override void Dispatch (ToolboxEvent ev)
			{
				uint selection_event_code = ClickEvent;

				if (selection_event_code == 0)
				{
					selection_event_code = EventCode.Selection;
				}

				uint submenu_event_code = SubMenuEvent;

				if (submenu_event_code == 0)
				{
					submenu_event_code = EventCode.SubMenu;
				}

				if (ev.ToolboxArgs.Header.EventCode == selection_event_code && Selection != null)
				{
					Selection (this, ev.ToolboxArgs);
				}
				else if (ev.ToolboxArgs.Header.EventCode == submenu_event_code && SubMenu != null)
				{
					SubMenu (this, new SubMenuEventArgs (ev.ToolboxArgs.RawEventData));
				}
			}
		}

		/*! \class Menu
		 * \brief Encapsulates a Toolbox Menu object.  */
		public class Menu : Object
		{
			/*! \brief The Toolbox methods associated with the Toolbox Menu class.  */
			static class Method
			{
				public const int SetHelpMessage = 16;
				public const int GetHelpMessage = 17;
				public const int AddEntry = 20;
				public const int RemoveEntry = 21;
				public const int GetHeight = 22;
				public const int GetWidth = 23;
				public const int SetTitle = 24;
				public const int GetTitle = 25;
			}

			/*! \brief %Flags used in a %Menu %Toolbox template.  */
			public static class Flags
			{
				public const int GenerateAboutToBeShown = (1 << 0);
				public const int GenerateHasBeenHidden = (1 << 1);
			}

			public static class TemplateOffset
			{
				public const int Flags = 36;
				public const int Title = 40;
				public const int MaxTitle = 44;
				public const int HelpMessage = 48;
				public const int MaxHelp = 52;
				public const int ShowEvent = 56;
				public const int HideEvent = 60;
				public const int NumEntries = 64;
			}

			/*! \class EventCode
			 * \brief Toolbox events that can be generated by the Toolbox Menu object.  */
			public static class EventCode
			{
				public const int AboutToBeShown = 0x828c0;
				public const int HasBeenHidden = 0x828c1;
			}

			/*! \brief The event handlers that will be called just before this Menu is shown.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, Object.MenuAboutToBeShownEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * MenuObject.AboutToBeShown += handler_name;
			 * \endcode  */
			public event MenuAboutToBeShownEventHandler AboutToBeShown;

			/*! \brief The event handlers that will be called when this Menu has been hidden.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, ToolboxEventHandler e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * MenuObject.HasBeenHidden += handler_name;
			 * \endcode  */
			public event ToolboxEventHandler HasBeenHidden;

			private int AboutToBeShownEventCode = 0;
			private int HasBeenHiddenEventCode = 0;

			/*! \brief Create a Toolbox Menu object from the named resource.
			 * \param [in] resName The name of the template in the resource file.  */
			public Menu (string resName) : base (resName)
			{
				IntPtr template = TemplateLookup (resName);
				RetrieveEventCodes (template);
			}

			/*! \brief Create a Toolbox Menu from the template data given.
			 * \param[in] templateData Pointer to the menu template.  */
			public Menu (IntPtr templateData)
			{
				Create (templateData);
				RetrieveEventCodes (templateData);
			}

			/*! \brief Create a Menu from a Toolbox object that already exists.
			 * \param [in] objectID The Toolbox ID of the existing object.  */
			public Menu (uint ObjectID) : base (ObjectID)
			{
				IntPtr template = Toolbox.TemplateLookup (TemplateName);
				RetrieveEventCodes (template);
			}

			/*! \todo Method to add a Menu Entry to a menu. Requires
			 * support for creation of objects from template data.  */
			public void AddEntry ()
			{
			}

			/*! \todo Method to remove a Menu Entry from a menu.
			 * Easy to do, but waiting for corresponding AddEntry.  */
			public void RemoveEntry ()
			{
			}

			/*! \brief The title of the Menu.
			 * \exception ArgumentNullException Thrown if the Title property is set to null.  */
			public string Title
			{
				set
				{
					if (value == null)
						throw new ArgumentNullException ("value", "Attempt to set Menu Title property to null");
					SetText (0, Method.SetTitle, value);
				}
				get { return GetText (Method.GetTitle); }
			}

			/*! \brief The help message which will be returned when a Help Message is
			 * received.  */
			public string HelpMessage
			{
				set { SetText (0, Method.SetHelpMessage, value); }
				get { return GetText (Method.GetHelpMessage); }
			}

			/*! \brief The height of the work area of the Menu in OS units.  */
			public int Height
			{
				get { return (int)MiscOp_GetR0 (0, Method.GetHeight); }
			}

			/*! \brief The width of the work area on the Menu in OS units.  */
			public int Width
			{
				get { return (int)MiscOp_GetR0 (0, Method.GetWidth); }
			}

			public override void Dispatch (ToolboxEvent ev)
			{
				// This call is likely to be temporary until events are also dispatched to
				// gadgets as well. Need this now for the Quit event.
//				base.Dispatch (ev);

				if (ev.ToolboxArgs.Header.EventCode == AboutToBeShownEventCode &&
				    AboutToBeShown != null)
				{
					AboutToBeShown (this, new MenuAboutToBeShownEventArgs (ev.ToolboxArgs.RawEventData));
				}
				else if (ev.ToolboxArgs.Header.EventCode == HasBeenHiddenEventCode &&
					 HasBeenHidden != null)
				{
					// There is no additional data after the event header.
					HasBeenHidden (this, ev.ToolboxArgs);
				}
			}

			private void RetrieveEventCodes (IntPtr template)
			{
				// The Acorn User Interface Toolbox Manual states that these event codes are
				// -1 in the template if the default events are to be raised, however, it would
				// seem that they are actually 0.
				int flags = Marshal.ReadInt32 (template, TemplateOffset.Flags);
				if ((flags & Flags.GenerateAboutToBeShown) != 0)
				{
					var show_event = Marshal.ReadInt32 (template,
									    TemplateOffset.ShowEvent);
					AboutToBeShownEventCode = (show_event != 0) ?
								   show_event :
								   EventCode.AboutToBeShown;
				}
				if ((flags & Flags.GenerateHasBeenHidden) != 0)
				{
					var hide_event = Marshal.ReadInt32 (template,
									    TemplateOffset.HideEvent);
					HasBeenHiddenEventCode = (hide_event != 0) ?
								  hide_event :
								  EventCode.HasBeenHidden;
				}
			}
		}
	}
}
