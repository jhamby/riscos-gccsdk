using System;
using System.Runtime.InteropServices;

namespace riscos
{
	public static partial class Toolbox
	{
		/*! \brief Encapsulates a Toolbox %SaveAs Dialogue Box.  */
		public class SaveAsDialogue : Object
		{
			static class Method
			{
				public const int GetWindowID = 0;
				public const int SetTitle = 1;
				public const int GetTitle = 2;
				public const int SetFileName = 3;
				public const int GetFileName = 4;
				public const int SetFileType = 5;
				public const int GetFileType = 6;
				public const int SetFileSize = 7;
				public const int GetFileSize = 8;
				public const int SelectionAvailable = 9;
				public const int SetDataAddress = 10;
				public const int BufferFilled = 11;
				public const int FileSaveCompleted = 12;
			}

			/*! \brief Default Toolbox events that can be generated by the %Toolbox %SaveAs object.  */
			public static class EventCode
			{
				public const int AboutToBeShown = 0x82bc0;
				public const int DialogueCompleted = 0x82bc1;
				public const int SaveToFile = 0x82bc2;
				public const int FillBuffer = 0x82bc3;
				public const int SaveCompleted = 0x82bc4;
			}

			/*! \brief The signature of a AboutToBeShown event handler.  */
			public delegate void AboutToBeShownEventHandler (object sender, AboutToBeShownEventArgs e);

			/*! \brief The event handlers that will be called just before this %SaveAs is shown.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, AboutToBeShownEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * SaveAsObject.AboutToBeShown += handler_name;
			 * \endcode  */
			public event AboutToBeShownEventHandler AboutToBeShown;

			/*! \brief An object that encapsulates the arguments for the event that is raised
			 * after the %SaveAs dialogue has been hidden.  */
			public class DialogueCompleteEventArgs : ToolboxEventArgs
			{
				/*! \brief Constant defining the possible bit flag returned by this event.  */
				public static class Flags
				{
					public const int SaveSuccessful = (1 << 0);
				}

				public readonly bool SaveSuccessful;

				public DialogueCompleteEventArgs (IntPtr unmanagedEventData) : base (unmanagedEventData)
				{
					SaveSuccessful = (Header.Flags & Flags.SaveSuccessful) != 0;
				}
			}

			/*! \brief The signature of a DialogueComplete event handler.  */
			public delegate void DialogueCompleteEventHandler (object sender, DialogueCompleteEventArgs e);

			/*! \brief The event handlers that will be called when this dialogue is hidden.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, DialogueCompleteEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * SaveAsObject.DialogueComplete += handler_name;
			 * \endcode  */
			public event DialogueCompleteEventHandler DialogueComplete;

			/*! \brief An object that encapsulates the arguments for the event that is raised
			 * by a %SaveAs dialogue to request that the client save its data to the given filename.  */
			public class SaveToFileEventArgs : ToolboxEventArgs
			{
				/*! \brief Constant defining event specific data offset after the header.  */
				public static class EventOffset
				{
					public const int Filename = 16;
				}

				/*! \brief Constant defining the possible bit flag returned by this event.  */
				public static class Flags
				{
					public const int SelectionOnly = (1 << 0);
				}

				public readonly string Filename;

				public readonly bool SelectionOnly;

				public SaveToFileEventArgs (IntPtr unmanagedEventData) : base (unmanagedEventData)
				{
					SelectionOnly = (Header.Flags & Flags.SelectionOnly) != 0;
					Filename = Marshal.PtrToStringAnsi (new IntPtr (RawEventData.ToInt32 () +
											EventOffset.Filename));
				}
			}

			/*! \brief The signature of a SaveToFile event handler.  */
			public delegate void SaveToFileEventHandler (object sender, SaveToFileEventArgs e);

			/*! \brief The event handlers that will be called when the client is required to
			 * save its data to a file.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, SaveToFileEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * SaveAsObject.SaveToFile += handler_name;
			 * \endcode  */
			public event SaveToFileEventHandler SaveToFile;

			/*! \brief An object that encapsulates the arguments for the event that is raised
			 * by a %SaveAs dialogue to request that the client fill the given buffer.  */
			public class FillBufferEventArgs : ToolboxEventArgs
			{
				/*! \brief Constants defining event specific data offsets after the header.  */
				public static class EventOffset
				{
					public const int BufferSize = 16;
					public const int BufferAddress = 20;
					public const int BytesTransmitted = 24;
				}

				/*! \brief Constant defining the possible bit flag returned by this event.  */
				public static class Flags
				{
					public const int SelectionOnly = (1 << 0);
				}

				public readonly bool SelectionOnly;

				public readonly int BufferSize;

				public readonly IntPtr BufferAddress;

				public readonly int BytesTransmitted;

				public FillBufferEventArgs (IntPtr unmanagedEventData) : base (unmanagedEventData)
				{
					SelectionOnly = (Header.Flags & Flags.SelectionOnly) != 0;
					BufferSize = Marshal.ReadInt32 (RawEventData, EventOffset.BufferSize);
					BufferAddress = Marshal.ReadIntPtr (RawEventData, EventOffset.BufferAddress);
					BytesTransmitted = Marshal.ReadInt32 (RawEventData, EventOffset.BytesTransmitted);
				}
			}


			/*! \brief The signature of a SaveToFile event handler.  */
			public delegate void FillBufferEventHandler (object sender, FillBufferEventArgs e);

			/*! \brief The event handlers that will be called when the client is required to
			 * fill the given buffer.
			 *
			 * Handlers should have the signature:
			 * \code
			 * void handler_name (object sender, FillBufferEventArgs e);
			 * \endcode
			 * and can be added to the list with:
			 * \code
			 * SaveAsObject.FillBuffer += handler_name;
			 * \endcode  */
			public event FillBufferEventHandler FillBuffer;

			/*! \brief Create a %Toolbox %SaveAs Dialogue from the named template in the
			 * Resource file.
			 * \param[in] resName The name of the %SaveAs template to use.  */
			public SaveAsDialogue (string resName) : base (resName)
			{
			}

			/*! \brief Create a %Toolbox %SaveAs from the template data given.
			 * \param[in] templateData Pointer to the window template.  */
			public SaveAsDialogue (IntPtr templateData)
			{
				Create (templateData);
			}

			/*! \brief Create a %Toolbox %SaveAs from an object that already exists.
			 * \param [in] objectID The Toolbox ID of the existing object.  */
			public SaveAsDialogue (uint objectID) : base (objectID)
			{
			}

			/*! \brief Get the ID of the underlying Window object.  */
			public uint WindowID
			{
				get { return CallMethod_GetR0 (Method.GetWindowID); }
			}

			/*! \brief Gets or sets the text which is to be used in the title bar
			 * of this %SaveAs dialogue.  */
			public string Title
			{
				set { SetText (Method.SetTitle, value); }
				get { return GetText (Method.GetTitle); }
			}

			/*! \brief Gets or sets the text which is to be used in the writable
			 * field of the %SaveAs dialogue.  */
			public string FileName
			{
				set { SetText (Method.SetFileName, value); }
				get { return GetText (Method.GetFileName); }
			}

			/*! \brief Gets or sets the filetype for this %SaveAs dialogue, and therefore
			 * the sprite which will be displayed.  */
			public int FileType
			{
				set { CallMethod_SetR3 (Method.SetFileType, (uint)value); }
				get { return (int)CallMethod_GetR0 (Method.GetFileType); }
			}

			/*! \brief Gets or sets the estimated file size in bytes for this %SaveAs dialogue.  */
			public int FileSize
			{
				set { CallMethod_SetR3 (Method.SetFileSize, (uint)value); }
				get { return (int)CallMethod_GetR0 (Method.GetFileSize); }
			}

			/*! \brief Indicate whether there is a current selection in existence.  */
			public bool SelectionAvailable
			{
				set { CallMethod_SetR3 (Method.SelectionAvailable, value ? 1U : 0); }
			}

			public void SetDataAddress (IntPtr data, int dataSize,
							   IntPtr selection, int selectionSize)
			{
				CallMethod_SetR3R4R5R6 (Method.SetDataAddress,
							data.ToInt32 (),
							dataSize,
							selection.ToInt32 (),
							selectionSize);
			}

			public void BufferFilled (IntPtr buffer, int bytesWritten)
			{
				CallMethod_SetR3R4 (Method.BufferFilled, (uint)buffer.ToInt32(), (uint)bytesWritten);
			}

			public void FileSaveCompleted (string filename, bool wasSuccessful)
			{
				SetText (wasSuccessful ? 1U : 0, Method.FileSaveCompleted, filename);
			}

			/*! \brief Check if the given event is relevant to the %SaveAs dialogue and call the
			 * associated event handlers.  */
			public override void Dispatch (ToolboxEvent ev)
			{
				switch (ev.ToolboxArgs.Header.EventCode)
				{
				case EventCode.AboutToBeShown:
					if (AboutToBeShown != null)
						AboutToBeShown (this, new AboutToBeShownEventArgs (ev.ToolboxArgs.RawEventData));
					break;
				case EventCode.DialogueCompleted:
					if (DialogueComplete != null)
						DialogueComplete (this, new DialogueCompleteEventArgs (ev.ToolboxArgs.RawEventData));
					break;
				case EventCode.SaveToFile:
					if (SaveToFile != null)
						SaveToFile (this, new SaveToFileEventArgs (ev.ToolboxArgs.RawEventData));
					break;
				case EventCode.FillBuffer:
					if (FillBuffer != null)
						FillBuffer (this, new FillBufferEventArgs (ev.ToolboxArgs.RawEventData));
					break;
				}
			}
		}
	}
}
