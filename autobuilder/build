#!/bin/bash -e

AB_PACKAGES=""
AB_DEBUG=no           # Leave source
AB_PACKONLY=no        # Zip only from current directory
AB_NOFETCH=no         # Using existing source fetched from last time
AB_VERBOSE=no         # Echo output
AB_DEPS=yes           # Build dependencies first
AB_TARGET=            # Name added to packages and logs

for param in $@ ; do
  case "$param" in
    -*)
      byte=3
      while true; do
        # The "" parameter for 'echo' is there on purpose because otherwise $param might be
        # interpreted as an 'echo' parameter.  E.g. with option -n, the input for 'cut' is
        # now " -n" instead of an empty string.
        opt=$(echo "" $param | cut -b $byte)
        byte=$((byte + 1))

        case "$opt" in
          "")
            break
            ;;
          d)
            AB_DEBUG=yes
            ;;
          D)
            AB_THISDEBUG=yes
            ;;
          p)
            AB_PACKONLY=yes
            ;;
          f)
            AB_NOFETCH=yes
            ;;
          v)
            AB_VERBOSE=yes
            ;;
          n)
            AB_DEPS=no
            ;;
          *)
          echo "Autobuilder: unknown option -$opt"
          exit 1
          ;;
        esac
      done
       ;;
    *)
       AB_PACKAGES="$AB_PACKAGES $param"
       ;;
  esac
done

# Attempt to guess the host platform's path separator
# Will set AB_PATH_SEPARATOR appropriately, if not already set.
guess_path_separator() {
  # Gratuitously borrowed from autoconf
  if test "${AB_PATH_SEPARATOR+set}" != "set"; then
    echo "#! /bin/sh" > conf$$.sh
    echo "exit 0"    >> conf$$.sh
    chmod +x conf$$.sh
    if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
      AB_PATH_SEPARATOR=';'
    else
      AB_PATH_SEPARATOR=:
    fi
    rm -f conf$$.sh
  fi
}

# Find a program in the current path
# Pass program name in as $1
# Returns 0 iff found, 1 otherwise.
find_program() {
  local PROG_NAME=$1

  fp_old_IFS=$IFS
  IFS=$AB_PATH_SEPARATOR
  for fp_dir in $PATH
  do
    IFS=$fp_old_IFS
    test -z "$fp_dir" && fp_dir=.
    if test -f "$fp_dir/$PROG_NAME"; then
      return 0
    fi
  done

  return 1
}

# Check for presence of required dependencies on the host system.
# Exits with a user-friendly error message if not satisfied.
check_dependencies() {
  for build_prog in cvs svn wget autoconf automake rman realpath pkg-config doxygen ; do
    find_program $build_prog
    if [ $? -ne 0 ]; then
      echo "Autobuilder: $build_prog not found; is it installed on your path?"
      exit 1;
    fi
  done
}

guess_path_separator
check_dependencies

export AB_PACKONLY
export AB_DEBUG
export AB_NOFETCH
set -a

# Autobuilder home
pushd `dirname $0` > /dev/null
AB_HOME=`pwd`
popd > /dev/null

# Determine directory where the packages will be published:
# Note: the libraries (= result of 'make install') will be published at AB_OUTPUTLIB
if [ -z "$AB_OUTPUTPACK" ] ; then
  AB_OUTPUTPACK=$AB_HOME/autobuilder_packages
  if [ ! -d "$AB_OUTPUTPACK" ] ; then
    echo "Autobuilder: will store the packages at $AB_OUTPUTPACK"
    mkdir $AB_OUTPUTPACK
  fi
else
  if [ ! -d "$AB_OUTPUTPACK" ] ; then
    echo "Autobuilder: Autobuilder package directory $AB_OUTPUTPACK (defined by \$AB_OUTPUTPACK) does not exist."
    exit 1
  fi
fi

# Determine directory where the libraries will be published:
# Note: AB_OUTPUTPACK != AB_OUTPUTLIB
if [ -z "$AB_OUTPUTLIB" ] ; then
  AB_OUTPUTLIB=$AB_HOME/autobuilder_libraries
  if [ ! -d "$AB_OUTPUTLIB" ] ; then
    echo "Autobuilder: will store the libraries at $AB_OUTPUTLIB"
    mkdir $AB_OUTPUTLIB
  fi
else
  if [ ! -d "$AB_OUTPUTLIB" ] ; then
    echo "Autobuilder: Autobuilder library directory $AB_OUTPUTLIB (defined by \$AB_OUTPUTLIB) does not exist."
    exit 1
  fi
fi

# Check for values set in a local build directory
if [ -e build-setvars ] ; then
 echo "Autobuilder: using locally set values"
 . build-setvars
fi

# File extension
if [ "$AB_ELFBUILD" == "yes" ] ; then
  export AB_EXEEXT=,e1f
else
  export AB_EXEEXT=,ff8
fi

# GCCSDK Scripts
if [ -z "$GCCSDK_INSTALL_ENV" ] ; then
  GCCSDK_INSTALL_ENV=/home/riscos/env
fi
if [ ! -d "$GCCSDK_INSTALL_ENV" ] ; then
  echo "Autobuilder: directory with porting tools does not exist. \$GCCSDK_INSTALL_ENV not defined or /home/riscos/env does not exist."
  exit 1
fi
export GCCSDK_INSTALL_ENV
export AB_TARGET

# GCCSDK Binaries
if [ -z "$GCCSDK_INSTALL_CROSSBIN" ] ; then
  GCCSDK_INSTALL_CROSSBIN=/home/riscos/cross/bin
fi
if [ ! -d "$GCCSDK_INSTALL_CROSSBIN" ] ; then
  echo "Autobuilder: directory with cross compiling tools does not exist. \$GCCSDK_INSTALL_CROSSBIN not defined or /home/riscos/cross/bin does not exist."
  exit 1
fi
export GCCSDK_INSTALL_CROSSBIN

# build location
AB_TMPDIR=$PWD


# Change to autobuilder home
if [ "$AB_PACKONLY" != "yes" ] ; then
  cd $AB_HOME
fi

# If a specific package is named, build that; otherwise everything
if [ "$AB_PACKAGES" == "" ] ; then
  AB_PACKAGES=$(find -type d)
  if [ "$AB_PACKAGES" == "" ] ; then
    echo "Autobuilder: nothing to build ?"
    exit 1
  fi
fi

if [ "$AB_VERBOSE" == "yes" ] ; then
  AB_STDOUT=
else
  AB_STDOUT=>/dev/null
fi

ab_build() {

  local PACKAGE_NAME=$1
  local IS_DEPENDENCY=$2

  # Because the dependency info only contains the package name, and not the
  # directory, we need to search for the directory containing this package.
  local PACKAGE_DIR=`(cd $AB_HOME ; echo */$PACKAGE_NAME/setvars)`
  if [ ! -e "$AB_HOME/$PACKAGE_DIR" ] ; then
    PACKAGE_DIR=`(cd $AB_HOME ; echo */*/$PACKAGE_NAME/setvars)`
  fi
  PACKAGE_DIR=`dirname $PACKAGE_DIR`

  if [ ! -d $AB_HOME/$PACKAGE_DIR ] ; then
    echo "Autobuilder: No directory found for package \"$PACKAGE_NAME\" - ignoring" 1>&2
    return 0
  fi

  echo "Autobuilder: Package \"$PACKAGE_NAME\" will be built using recipe at \"$AB_HOME/$PACKAGE_DIR\""

  if [ ! -e $AB_HOME/$PACKAGE_DIR/setvars ] ; then
    echo "Autobuilder: No setvars found for package \"$PACKAGE_NAME\" - ignoring" 1>&2
    return 0
  fi

  if [ "$IS_DEPENDENCY" == "1" ] ; then
    if [ -e "$AB_HOME/$PACKAGE_DIR/last-success$AB_TARGET" ] ; then
      echo "Autobuilder: Dependency $PACKAGE_NAME satisfied"
      return 0
    fi
  fi

  if [ "$AB_DEPS" == "yes" ] ; then

    local DEPENDENCIES
    local DEP

    if [ "`which apt-cache 2>/dev/null`" != "" ] ; then
      DEPENDENCIES=`apt-cache depends $PACKAGE_NAME | grep Depends: | sed 's/^.*Depends: //'`
    fi

    if [ -e "$AB_HOME/$PACKAGE_DIR/depends" ] ; then
      DEPENDENCIES=`echo $DEPENDENCIES $(cat $AB_HOME/$PACKAGE_DIR/depends | grep -v \^\#)`
    fi


    for DEP in $DEPENDENCIES ; do
      if ! ab_build $DEP 1 ; then
        return 1
      fi
    done
  fi


  # If we get here then all dependencies for this package should be satisfied.
  AB_PACKAGE=$PACKAGE_NAME
  AB_PACKAGEDIR=$PACKAGE_DIR


  AB_OUTPUT=/tmp/ab-output-$$-$RANDOM
  if [ "$AB_THISDEBUG" == "yes" -a "$IS_DEPENDENCY" == "0" ] ; then
    AB_DEBUG=yes $AB_HOME/build-program 2>&1 | tee $AB_OUTPUT $AB_STDOUT
  else
    $AB_HOME/build-program 2>&1 | tee $AB_OUTPUT $AB_STDOUT
  fi

  if ! grep -q "Autobuilder: Package stage completed" < $AB_OUTPUT ; then
    echo "Package $AB_PACKAGE: ***Failure***"
    mv $AB_OUTPUT $AB_HOME/$AB_PACKAGEDIR/last-failure$AB_TARGET
    return 1
  else
    echo "Package $AB_PACKAGE: Success"

    if ! grep -q "Autobuilder: Running make install" < $AB_OUTPUT   && \
         grep -q "Autobuilder: No files specified to package" < $AB_OUTPUT ; then
      echo "Warning: not installed, and not packaged"
    fi

    mv $AB_OUTPUT $AB_HOME/$AB_PACKAGEDIR/last-success$AB_TARGET
    rm -f $AB_HOME/$AB_PACKAGEDIR/last-failure$AB_TARGET
  fi
  echo


  return 0
}

for PACKAGEDIR in $AB_PACKAGES ; do
 PACKAGE=$(echo "$PACKAGEDIR" | sed -e "s#/\$##" -e "s#/#\n#g" | tail -1)

 ab_build $PACKAGE 0

done
